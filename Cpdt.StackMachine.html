<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Cpdt.StackMachine</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Cpdt.StackMachine</h1>

<div class="code">

<br/>
</div>

<div class="doc">
 
<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

まずは実際に動く例として、ソース言語からスタックマシンへの証明付きコンパイラの構成から始めましょう。最初はシンプルなソース言語から始め、少しずつ複雑なソース言語も扱っていきます。証明に関しては、いくつかの便利なタクティクを紹介し、それらがどのように手動の証明で使われるか、またそれらがどれだけ簡単に自動化できるかを見ていきます。この章では使う機能の完全な説明を与えるつもりはありません。それよりはむしろ、Coq でできることは何なのかを述べるつもりです。後の章ですべての概念をボトムアップに紹介していきます。言い換えれば、ほとんどの読者にとってここで行われることを完璧に理解するのは難しいかもしれませんが、ここでのデモが残りの章への興味に繋がっていただければ十分です！

<div class="paragraph"> </div>

読者はいつでもこの章のソースファイル <tt>StackMachine.v</tt> を Proof General を使って対話的に1ステップずつ見ていくことができます。あるいは、Coq 開発の過程を手で書いて感じたければ、この章のソースコードの一つ一つを Emacs バッファ内で新規の <tt>.v</tt> ファイルに書き込んでいっても良いでしょう。後者の方法を取るなら、ファイルの先頭に以下の三行をコピーしてください。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">Bool</span> <span class="id" title="library">Arith</span> <span class="id" title="library">List</span> <span class="id" title="library">Cpdt.CpdtTactics</span>.<br/>
<span class="id" title="keyword">Set Implicit Arguments</span>.<br/>
<span class="id" title="keyword">Set</span> <span class="id" title="var">Asymmetric</span> <span class="id" title="var">Patterns</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

今後、各章のソースコード内の似たコマンドは文章中では省略するので、省略された部分は以前与えたところからコピー&amp;ペーストする必要があります。具体的には、どの章の始めにも上の三行が挿入されます。ただし、章ごとに <span class="inlinecode"><span class="id" title="keyword">Require</span></span> <span class="inlinecode"><span class="id" title="keyword">Import</span></span> の後を必要に合わせて書き換えなければいけません。二行目のコマンドは型推論に関して定義の標準的なふるまいに影響し、三行目はより簡潔なパターンマッチングの機能を与えます(三行目は Coq のバージョン 8.5 以降のコマンドで、バージョン 8.5 未満には機能しません)。
<div class="paragraph"> </div>

<a name="lab15"></a><h1 class="section">自然数の算術式</h1>

<div class="paragraph"> </div>

 コンパイラの教科書にはおなじみの、数値型の上での算術式から始めましょう。
<div class="paragraph"> </div>

<a name="lab16"></a><h2 class="section">ソース言語</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

ソース言語のシンタックスから始めます。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="binop"><span class="id" title="inductive">binop</span></a> : <span class="id" title="keyword">Set</span> := <a name="Plus"><span class="id" title="constructor">Plus</span></a> | <a name="Times"><span class="id" title="constructor">Times</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

私たちの初めての Coq コードとなるこの一行は、ML や Haskell のプログラマには意外なものではないでしょう。ソース言語の二項演算子を表すため、代数的データ型(algebraic datatype) <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#binop"><span class="id" title="inductive">binop</span></a></span> を定義しました。ここで、ML や Haskell と比較されるべき二つのポイントがあります。一つは、Coq は <tt>data</tt>、<tt>datatype</tt>、<tt>type</tt> の代わりに <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> を使うことです。これは単なる表面上のシンタックスの違いではありません。この章ではごく簡潔にしか触れませんが、Coq の帰納的データ型(inductive data types)はありふれた代数的データ型よりもずっと豊かな表現力を持っていて、とくに数学のすべてを表現することができます。二つ目は、<span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span></span> です。これは、プログラムの構成要素として考えられるべきデータ型を定義していることを宣言します。プログラムの構成要素ではなく、証明の世界のデータ型、さらにプログラムと証明の両方を包含する、無限の階層を持つ世界のデータ型を定義するときのキーワードも後に与えます。後者は、高階の構成をするときに役立ちます。
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="exp"><span class="id" title="inductive">exp</span></a> : <span class="id" title="keyword">Set</span> :=<br/>
| <a name="Const"><span class="id" title="constructor">Const</span></a> : <span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#exp"><span class="id" title="inductive">exp</span></a><br/>
| <a name="Binop"><span class="id" title="constructor">Binop</span></a> : <a class="idref" href="Cpdt.StackMachine.html#binop"><span class="id" title="inductive">binop</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#exp"><span class="id" title="inductive">exp</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#exp"><span class="id" title="inductive">exp</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#exp"><span class="id" title="inductive">exp</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

算術式を定義しました。定数 <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a></span> は一つの自然数値の引数から成り、二項演算子 <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#Binop"><span class="id" title="constructor">Binop</span></a></span> は一つの演算子と二つのオペランド式から成るものとして与えます。

<div class="paragraph"> </div>

本書をPDF版で読んでいる読者への注意：coqdoc は Coq のソースコードを LaTeX や HTML 形式に変換します。この PDF 上の右矢印→はソース上では ASCII テキストの <tt>-</tt>&gt; です。この章では他に、二重の右矢印⇒を <tt>=</tt>&gt;、記号∀を <tt>forall</tt>、デカルト積×を <tt>*</tt> にする置き換えがあります。ASCII テキストでどう書くのかが分からなくなったら、ソースコードを参照してください。

<div class="paragraph"> </div>



<div class="paragraph"> </div>

言語が定義されたので、次にこの言語のプログラムの意味を与えることができます。ここでは、プログラムの意味は、インタプリタを書いて与えることにします。これはごく単純な操作的/表示的意味論として考えることができます。(もしあなたがこれらの意味論的手法に不慣れでも、心配いりません。「あたりまえの」構成をしていきますから。) 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="binopDenote"><span class="id" title="definition">binopDenote</span></a> (<span class="id" title="var">b</span> : <a class="idref" href="Cpdt.StackMachine.html#binop"><span class="id" title="inductive">binop</span></a>) : <span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <span class="id" title="inductive">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#Plus"><span class="id" title="constructor">Plus</span></a> ⇒ <span class="id" title="abbreviation">plus</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#Times"><span class="id" title="constructor">Times</span></a> ⇒ <span class="id" title="abbreviation">mult</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

二項演算子の意味は自然数の二引数関数です。ML や Haskell における <tt>match</tt> や <tt>case</tt> のようなパターンマッチングを使って定義し、Coq の標準ライブラリ内の関数 <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#plus"><span class="id" title="definition">plus</span></a></span> と <span class="inlinecode"><span class="id" title="abbreviation">mult</span></span> を参照しています。<span class="inlinecode"><span class="id" title="keyword">Definition</span></span> キーワードは、Coq の項を名前に束縛するための Coq で頻繁に使われる記法で、場合に応じて構文糖衣を持ちます。上の例でも関数を定義するための構文糖衣が用いられており、展開すると以下のようになります：
<br/>
<span class="inlinecode"><span class="id" title="keyword">Definition</span> <a class="idref" href="Cpdt.StackMachine.html#binopDenote"><span class="id" title="definition">binopDenote</span></a> : <a class="idref" href="Cpdt.StackMachine.html#binop"><span class="id" title="inductive">binop</span></a> → <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> → <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> → <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a> := <span class="id" title="keyword">fun</span> (<a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> : <a class="idref" href="Cpdt.StackMachine.html#binop"><span class="id" title="inductive">binop</span></a>) ⇒<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> ⇒ <a class="idref" href="Cpdt.InductiveTypes.html#plus"><span class="id" title="definition">plus</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#Times"><span class="id" title="constructor">Times</span></a> ⇒ <span class="id" title="abbreviation">mult</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

この例では、次のようにすべての型注釈を外すことができます：
<br/>
<span class="inlinecode"><span class="id" title="keyword">Definition</span> <a class="idref" href="Cpdt.StackMachine.html#binopDenote"><span class="id" title="definition">binopDenote</span></a> := <span class="id" title="keyword">fun</span> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> ⇒<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a> ⇒ <a class="idref" href="Cpdt.InductiveTypes.html#plus"><span class="id" title="definition">plus</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#Times"><span class="id" title="constructor">Times</span></a> ⇒ <span class="id" title="abbreviation">mult</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

ML や Haskell のような言語は <i>principal types</i> 性という有用な性質を持っています。principal types 性とは、型推論がいかに効果的であるかの強い保証を与えます。残念ながら、Coq の型システムは表現力がとても豊かであるがために「完全な」型推論は不可能で、この課題は実際的にも困難です。それでもやはり Coq はとても便利なヒューリスティクスを含んでおり、それらの多くは Coq の単純なコードに落ちるようなプログラムに対する ML や Haskell の型検査器の仕組みを模倣しています。

<div class="paragraph"> </div>

この機会に Coq に関連した様々な種類の言語について触れましょう。Coq の理論的基礎は <i>Calculus of Inductive Constructions</i> (CIC) と呼ばれる形式システムに基いています。CIC は  <i>Calculus of Constructions</i> (CoC) という型システムの拡張です。CIC はメタ理論を証明するのに有用ですが実際の開発には少し厳格すぎるような基礎理論です。しかしながら、CIC は<span class="inlinecode">強正規化性</span>(strong normalizaiton)や Zermelo-Fraenkel 集合論の類似システムに対する<span class="inlinecode">相対無矛盾性</span>(relative consistency)のような性質が証明されていることは知っておいて良いでしょう。強正規化性は、すべてのプログラムが(さらに重要なことに、すべての証明項も)停止するという性質で、相対無矛盾性は簡単に言えば Coq で書かれた証明は対応する数学的命題が「本当に正しい」ことを信じてよいという性質です。

<div class="paragraph"> </div>

Coq は本当は Gallina と呼ばれる CIC の拡張の上に基いています。上のコードの <span class="inlinecode">:=</span> から <span class="inlinecode">.</span> までの中身は Gallina の項です。Gallina は CIC の拡張として考慮されなければいけない有用な特徴を含んでいます。CIC についての重要なメタ定理は形式言語の範囲を越えた特徴の一部にまでは拡張されていませんが、ほとんどの Coq ユーザはこの欠落をさほど気にしていません。

<div class="paragraph"> </div>

さらに、Coq は証明を書いたり手続きを決定するためのドメイン固有言語である Ltac を含みます。この章の後半でいくつかの基本的な Ltac の例を見ていき、本書のほとんどはさらに有用な Ltac の例を挙げることに捧げます。

<div class="paragraph"> </div>

最後に、<span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> や <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> のようなコマンドは Vernacular の一部です。Vernacular は Coq システムに対するあらゆる種類の有用な要求や命令を含みます。すべての Coq のソースファイルは Vernacular コマンドの列であり、たくさんのコマンドは Gallina や Ltac プログラムを引数に取ります(実際は、Coq のソースファイルはネストされたスコープ構造の影響で、列ではなく木に近い形をしています)。

<div class="paragraph"> </div>



<div class="paragraph"> </div>

式の意味の簡単な定義を与えましょう： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="expDenote"><span class="id" title="definition">expDenote</span></a> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.StackMachine.html#exp"><span class="id" title="inductive">exp</span></a>) : <span class="id" title="inductive">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">n</span> ⇒ <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#Binop"><span class="id" title="constructor">Binop</span></a> <span class="id" title="var">b</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ (<a class="idref" href="Cpdt.StackMachine.html#binopDenote"><span class="id" title="definition">binopDenote</span></a> <span class="id" title="var">b</span>) (<a class="idref" href="Cpdt.StackMachine.html#expDenote"><span class="id" title="definition">expDenote</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.StackMachine.html#expDenote"><span class="id" title="definition">expDenote</span></a> <span class="id" title="var">e2</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> キーワードを使って、これは再帰的定義をしていることを明示的に宣言しています。残りの部分は関数型プログラマにとっては目新しいものではないでしょう。 
<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

これらの定義の性質の証明をする前に、テストができれば好都合です。コマンド <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> を使っていくつかの例を評価し、私たちのセマンティクスがもっともらしいことを確かめてみましょう。このコマンドは「簡約戦略」(reduction strategy)、別の言葉で「評価順序」(order of evaluation)を表す引数を取ります。ML の先行評価や、Haskell の遅延評価とは違い、Coq ではこれらや他の様々な評価順序を選べます。これが可能なのはすべての Coq プログラムが停止するからです。実は、Coq は内部で上の <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> で定義した関数の停止性をチェックしています。Coq は再帰呼び出しごとに引数のサイズが単調減少していることを見て、停止性を判断しています。さらに言うと、再帰呼び出しは <span class="inlinecode"><span class="id" title="keyword">match</span></span> 式によって分割された元々の引数によって作られていないといけません。
(この制限を単順に削除するのはCoqを役に立たない定理証明ツールに変えてしまいます。この理由は次の章で学びます。第7章では、<span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>の制限に対処するためのいくつかの方法を見ます。)

<div class="paragraph"> </div>

評価のテストをするために、評価戦略 <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> を使って <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> コマンドを実行しましょう。<span class="inlinecode"><span class="id" title="tactic">simpl</span></span> の定義は Coq の基礎をもっと学むまで後回しにしますが、<span class="inlinecode"><span class="id" title="tactic">simpl</span></span> は通常テストを終わらせてくれます。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.StackMachine.html#expDenote"><span class="id" title="definition">expDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> 42).<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode">42</span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a></span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.StackMachine.html#expDenote"><span class="id" title="definition">expDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Binop"><span class="id" title="constructor">Binop</span></a> <a class="idref" href="Cpdt.StackMachine.html#Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> 2) (<a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> 2)).<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode">4</span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a></span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.StackMachine.html#expDenote"><span class="id" title="definition">expDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Binop"><span class="id" title="constructor">Binop</span></a> <a class="idref" href="Cpdt.StackMachine.html#Times"><span class="id" title="constructor">Times</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Binop"><span class="id" title="constructor">Binop</span></a> <a class="idref" href="Cpdt.StackMachine.html#Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> 2) (<a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> 2)) (<a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> 7)).<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode">28</span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a></span> 
<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

どれも自然な結果でしょう。これで、私たちのコンパイラのターゲット言語の定義に移る準備ができました。 
<div class="paragraph"> </div>

<a name="lab17"></a><h2 class="section">ターゲット言語</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

今まで定義してきたソースプログラムを簡単なスタックマシン上へコンパイルします。ターゲット言語のシンタックスは以下で与えます： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="instr"><span class="id" title="inductive">instr</span></a> : <span class="id" title="keyword">Set</span> :=<br/>
| <a name="iConst"><span class="id" title="constructor">iConst</span></a> : <span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a><br/>
| <a name="iBinop"><span class="id" title="constructor">iBinop</span></a> : <a class="idref" href="Cpdt.StackMachine.html#binop"><span class="id" title="inductive">binop</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="prog"><span class="id" title="definition">prog</span></a> := <span class="id" title="inductive">list</span> <a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="stack"><span class="id" title="definition">stack</span></a> := <span class="id" title="inductive">list</span> <span class="id" title="inductive">nat</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

命令 <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a></span> はスタックの先頭に定数をプッシュする <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#iConst"><span class="id" title="constructor">iConst</span></a></span> か、引数二つをポップし二項演算子に適用した後スタックに結果をプッシュする <span class="inlinecode"><span class="id" title="var">iBinon</span></span> から成ります。ここでのプログラム <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#prog"><span class="id" title="definition">prog</span></a></span> は命令 <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a></span> のリストで、スタック <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a></span> は自然数のリストです。

<div class="paragraph"> </div>

命令の意味をスタックからスタックのオプション型への関数として与えましょう。命令を実行してスタックアンダーフローに陥った場合は <span class="inlinecode"><span class="id" title="constructor">None</span></span>、結果として新たなスタック <span class="inlinecode"><span class="id" title="var">s'</span></span> を得た場合は <span class="inlinecode"><span class="id" title="constructor">Some</span></span> <span class="inlinecode"><span class="id" title="var">s'</span></span> を返します。中置演算子 <span class="inlinecode">::</span> はリストの cons で、Coq の標準ライブラリで定義されています。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="instrDenote"><span class="id" title="definition">instrDenote</span></a> (<span class="id" title="var">i</span> : <a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a>) (<span class="id" title="var">s</span> : <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a>) : <span class="id" title="inductive">option</span> <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.StackMachine.html#i"><span class="id" title="variable">i</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#iConst"><span class="id" title="constructor">iConst</span></a> <span class="id" title="var">n</span> ⇒ <span class="id" title="constructor">Some</span> (<span class="id" title="var">n</span> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#iBinop"><span class="id" title="constructor">iBinop</span></a> <span class="id" title="var">b</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">arg1</span> <span class="id" title="notation">::</span> <span class="id" title="var">arg2</span> <span class="id" title="notation">::</span> <span class="id" title="var">s'</span> ⇒ <span class="id" title="constructor">Some</span> ((<a class="idref" href="Cpdt.StackMachine.html#binopDenote"><span class="id" title="definition">binopDenote</span></a> <span class="id" title="var">b</span>) <span class="id" title="var">arg1</span> <span class="id" title="var">arg2</span> <span class="id" title="notation">::</span> <span class="id" title="var">s'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> ⇒ <span class="id" title="constructor">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#instrDenote"><span class="id" title="definition">instrDenote</span></a></span> が定義されれば、関数 <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a></span> も簡単に定義できます。プログラム全体に対して <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#instrDenote"><span class="id" title="definition">instrDenote</span></a></span> を繰り返し適用させます： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="progDenote"><span class="id" title="definition">progDenote</span></a> (<span class="id" title="var">p</span> : <a class="idref" href="Cpdt.StackMachine.html#prog"><span class="id" title="definition">prog</span></a>) (<span class="id" title="var">s</span> : <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a>) : <span class="id" title="inductive">option</span> <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <span class="id" title="constructor">Some</span> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">i</span> <span class="id" title="notation">::</span> <span class="id" title="var">p'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.StackMachine.html#instrDenote"><span class="id" title="definition">instrDenote</span></a> <span class="id" title="var">i</span> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">None</span> ⇒ <span class="id" title="constructor">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">Some</span> <span class="id" title="var">s'</span> ⇒ <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <span class="id" title="var">p'</span> <span class="id" title="var">s'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

こうして二つのプログラミング言語が定義されたので、コンパイラの定義に移りましょう。 
<div class="paragraph"> </div>

<a name="lab18"></a><h2 class="section">変換</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

私たちのコンパイラは自然に定義されます。リストの結合 <tt>++</tt> は Coq の標準ライブラリにあります。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="compile"><span class="id" title="definition">compile</span></a> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.StackMachine.html#exp"><span class="id" title="inductive">exp</span></a>) : <a class="idref" href="Cpdt.StackMachine.html#prog"><span class="id" title="definition">prog</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> <span class="id" title="var">n</span> ⇒ <a class="idref" href="Cpdt.StackMachine.html#iConst"><span class="id" title="constructor">iConst</span></a> <span class="id" title="var">n</span> <span class="id" title="notation">::</span> <span class="id" title="constructor">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#Binop"><span class="id" title="constructor">Binop</span></a> <span class="id" title="var">b</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> <span class="id" title="var">e2</span> <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> <span class="id" title="var">e1</span> <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.StackMachine.html#iBinop"><span class="id" title="constructor">iBinop</span></a> <span class="id" title="var">b</span> <span class="id" title="notation">::</span> <span class="id" title="constructor">nil</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
このコンパイラが正しいことを証明する前に、先ほどのサンプルプログラムを使っていくつかテストを走らせてみましょう。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> 42).<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#iConst"><span class="id" title="constructor">iConst</span></a></span> <span class="inlinecode">42</span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="constructor">nil</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#prog"><span class="id" title="definition">prog</span></a></span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Binop"><span class="id" title="constructor">Binop</span></a> <a class="idref" href="Cpdt.StackMachine.html#Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> 2) (<a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> 2)).<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#iConst"><span class="id" title="constructor">iConst</span></a></span> <span class="inlinecode">2</span> <span class="inlinecode">::</span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#iConst"><span class="id" title="constructor">iConst</span></a></span> <span class="inlinecode">2</span> <span class="inlinecode">::</span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#iBinop"><span class="id" title="constructor">iBinop</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="constructor">nil</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#prog"><span class="id" title="definition">prog</span></a></span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Binop"><span class="id" title="constructor">Binop</span></a> <a class="idref" href="Cpdt.StackMachine.html#Times"><span class="id" title="constructor">Times</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Binop"><span class="id" title="constructor">Binop</span></a> <a class="idref" href="Cpdt.StackMachine.html#Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> 2) (<a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> 2)) (<a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> 7)).<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#iConst"><span class="id" title="constructor">iConst</span></a></span> <span class="inlinecode">7</span> <span class="inlinecode">::</span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#iConst"><span class="id" title="constructor">iConst</span></a></span> <span class="inlinecode">2</span> <span class="inlinecode">::</span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#iConst"><span class="id" title="constructor">iConst</span></a></span> <span class="inlinecode">2</span> <span class="inlinecode">::</span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#iBinop"><span class="id" title="constructor">iBinop</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Plus"><span class="id" title="constructor">Plus</span></a></span> <span class="inlinecode">::</span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#iBinop"><span class="id" title="constructor">iBinop</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#Times"><span class="id" title="constructor">Times</span></a></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="constructor">nil</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#prog"><span class="id" title="definition">prog</span></a></span> 
<div class="paragraph"> </div>

 コンパイルされたプログラムも実行し、それらが正しい結果を返すこともチェックしましょう。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> 42)) <span class="id" title="constructor">nil</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="constructor">Some</span></span> <span class="inlinecode">(42</span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="constructor">nil</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">option</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a></span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Binop"><span class="id" title="constructor">Binop</span></a> <a class="idref" href="Cpdt.StackMachine.html#Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> 2) (<a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> 2))) <span class="id" title="constructor">nil</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="constructor">Some</span></span> <span class="inlinecode">(4</span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="constructor">nil</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">option</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a></span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Binop"><span class="id" title="constructor">Binop</span></a> <a class="idref" href="Cpdt.StackMachine.html#Times"><span class="id" title="constructor">Times</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Binop"><span class="id" title="constructor">Binop</span></a> <a class="idref" href="Cpdt.StackMachine.html#Plus"><span class="id" title="constructor">Plus</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> 2) (<a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> 2))<br/>
&nbsp;&nbsp;(<a class="idref" href="Cpdt.StackMachine.html#Const"><span class="id" title="constructor">Const</span></a> 7))) <span class="id" title="constructor">nil</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="constructor">Some</span></span> <span class="inlinecode">(28</span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="constructor">nil</span>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">option</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a></span> 
<div class="paragraph"> </div>

 今のところ良いですが、どうすれば<span class="inlinecode">すべての</span>入力プログラムに対してコンパイラが正しく動作することを確かめればよいでしょうか？ 
<div class="paragraph"> </div>

<a name="lab19"></a><h2 class="section">変換の正しさ</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

コンパイラが正しく実装されたことを証明しましょう。証明を始めるためには新たな Vernacular コマンド <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span> を使います。先ほど定義したセマンティクスを用いて変換の正しさを証明しましょう。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="compile_correct"><span class="id" title="lemma">compile_correct</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">e</span>, <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a>) <span class="id" title="constructor">nil</span> <span class="id" title="notation">=</span> <span class="id" title="constructor">Some</span> (<a class="idref" href="Cpdt.StackMachine.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="notation">::</span> <span class="id" title="constructor">nil</span>).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

紙と鉛筆の証明なら「<span class="inlinecode"><a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a></span> に関する帰納法より」と書いて終わらせるかもしれませんが、この証明は直接取り組むのは懸命ではありません。ここでは基本的な手法である<span class="inlinecode">帰納法の仮定の強化</span>をする必要があります。そのために、<span class="inlinecode"><span class="id" title="keyword">Lemma</span></span> コマンドを使って補題を示しましょう。<span class="inlinecode"><span class="id" title="keyword">Lemma</span></span> コマンドは <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span> のシノニムで、慣習的に主定理の証明に必要となる補助的な定理に対して使います。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="compile_correct'"><span class="id" title="lemma">compile_correct'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">e</span> <span class="id" title="var">p</span> <span class="id" title="var">s</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">=</span> <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.StackMachine.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a>).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="keyword">Lemma</span></span> コマンドを読み込むと、<span class="inlinecode">対話的証明モード</span>(interactive proof-editing mode)に入ります。スクリーンに何やら新しいテキストが表示されるのが見えるでしょう：

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">1 <span class="id" title="keyword">subgoal</span><br/>
<br/>
&nbsp;============================<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a> : <a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a>) (<a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a>) (<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a>),<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> <a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a> ++ <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> = <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a> :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Coq は補題の証明を始めようとしています。ここに見えているテキストは、私たちが証明のどこにいるのかを部分的に表しています。今、私たちには証明のゴールが一つあることを伝えられています。一般に、証明の途中で、複数の未証明の部分的なゴールが与えられることがあります。こういったゴールのことを サブゴールと呼び、それらは論理的な命題です。複数のサブゴールはどんな順番で証明してもよいですが、通常は Coq の与えた順番で証明するのが良いでしょう。

<div class="paragraph"> </div>

出力には私たちの一つのサブゴールが完全な詳細とともに書かれています。二重線の上には自由変数や仮定が(もしあれば)示されます。二重線の下は一般的に、仮定を使って証明されるべき結論が書かれています。

<div class="paragraph"> </div>

証明の状態は<span class="inlinecode">タクティク</span>と呼ばれるコマンドを実行することで操作できます。もっとも重要なタクティクの一つである <span class="inlinecode"><span class="id" title="tactic">induction</span></span> から始めましょう。

</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

今、式 <span class="inlinecode"><a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a></span> の構造の帰納法によってこの証明を始めることが宣言されました。始めのサブゴールは、帰納法による証明のための二つの新しいサブゴールに変わりました：

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">2 <span class="id" title="keyword">subgoals</span><br/>
<br/>
&nbsp;<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;============================<br/>
&nbsp;<span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a>) (<a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a>),<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>) ++ <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> =<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>) :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<br/>
<br/>
<span class="id" title="keyword">subgoal</span> 2 <span class="id" title="var">is</span><br/>
<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a>) (<a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Binop"><span class="id" title="constructor">Binop</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>) ++ <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> =<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Binop"><span class="id" title="constructor">Binop</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>) :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

一つ目のサブゴールには二重線と、その上に自由変数や仮定も表示されますが、それ以降のサブゴールは結論だけが表示されます。今自由変数の例が一つ目のサブゴールに見えますね。<span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a></span> 型の自由変数 <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span> です。結論は、元の定理内の <span class="inlinecode"><a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a></span> が <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span> に置き換えられています。同様に、二つ目のサブゴールの <span class="inlinecode"><a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a></span> はコンストラクタ <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#Binop"><span class="id" title="constructor">Binop</span></a></span> の一般的な形に置き換えられています。この両方のサブゴールを証明することは、構造的帰納法による標準的な証明に対応します。

<div class="paragraph"> </div>

一つ目のサブゴールの証明を新しいタクティクから始めましょう。次のタクティクは非常によく使われます。 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

サブゴールは次のように変わります：
<br/>
<span class="inlinecode"><br/>
&nbsp;<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a><br/>
&nbsp;<a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a><br/>
&nbsp;============================<br/>
&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>) ++ <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> =<br/>
&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>) :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="tactic">intros</span></span> は、ゴールの先頭にあった <span class="inlinecode"><span class="id" title="keyword">∀</span></span> によって束縛された変数を自由変数に変えました。

<div class="paragraph"> </div>

さらに証明を進めるためには、ゴール内のいくつかの関数の定義を使う必要があります。<span class="inlinecode"><span class="id" title="tactic">unfold</span></span> タクティクは識別子をその定義に置き換えます。

</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a><br/>
&nbsp;<a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a><br/>
&nbsp;============================<br/>
&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> ((<a class="idref" href="Cpdt.StackMachine.html#iConst"><span class="id" title="constructor">iConst</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> :: <span class="id" title="constructor">nil</span>) ++ <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> =<br/>
&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> (<a class="idref" href="Cpdt.ProgLang.html#HigherOrder.Const"><span class="id" title="constructor">Const</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>) :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)
<div class="paragraph"> </div>

</span>
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Cpdt.StackMachine.html#expDenote"><span class="id" title="definition">expDenote</span></a>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a><br/>
&nbsp;<a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a><br/>
&nbsp;============================<br/>
&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> ((<a class="idref" href="Cpdt.StackMachine.html#iConst"><span class="id" title="constructor">iConst</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> :: <span class="id" title="constructor">nil</span>) ++ <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> = <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

ゴールを証明するには一つ目の <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a></span> を展開(unfold)する必要があります。<span class="inlinecode"><span class="id" title="tactic">at</span></span> 節は <span class="inlinecode"><span class="id" title="tactic">unfold</span></span> と共に使われ、識別子を特定の箇所のみを展開したい場合にその場所を指定します。場所は左から右に数えます。 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <span class="id" title="tactic">at</span> 1.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a><br/>
&nbsp;<a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a><br/>
&nbsp;============================<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">fix</span> <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<span class="id" title="var">p0</span> : <a class="idref" href="Cpdt.StackMachine.html#prog"><span class="id" title="definition">prog</span></a>) (<span class="id" title="var">s0</span> : <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a>) {<span class="id" title="keyword">struct</span> <span class="id" title="var">p0</span>} :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="inductive">option</span> <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">p0</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <span class="id" title="constructor">Some</span> <span class="id" title="var">s0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Large.html#Int.i"><span class="id" title="definition">i</span></a> :: <a class="idref" href="Cpdt.StackMachine.html#p'"><span class="id" title="variable">p'</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.StackMachine.html#instrDenote"><span class="id" title="definition">instrDenote</span></a> <a class="idref" href="Cpdt.Large.html#Int.i"><span class="id" title="definition">i</span></a> <span class="id" title="var">s0</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">Some</span> <span class="id" title="var">s'</span> ⇒ <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p'"><span class="id" title="variable">p'</span></a> <span class="id" title="var">s'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">None</span> ⇒ <span class="id" title="constructor">None</span> (<a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>:=<a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) ((<a class="idref" href="Cpdt.StackMachine.html#iConst"><span class="id" title="constructor">iConst</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> :: <span class="id" title="constructor">nil</span>) ++ <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> =<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

今回の <span class="inlinecode"><span class="id" title="tactic">unfold</span></span> は <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a></span> を無名の再帰関数に変えました(一般に <span class="inlinecode"><span class="id" title="keyword">fun</span></span> や "lambda" が再帰しない無名関数を与えるのと同様に)。これは、再帰的定義を展開するときに一般に起こります。ここで、Coq は引数 <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a></span>, <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a></span> を <span class="inlinecode"><span class="id" title="var">p0</span></span>, <span class="inlinecode"><span class="id" title="var">s0</span></span> へ自動的に変えたことに注意してください。局所的な自由変数と名前の衝突を避けるためです。また、他にも <span class="inlinecode"><span class="id" title="constructor">None</span></span> <span class="inlinecode">(<a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>:=<a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a>)</span> という部分項が見えますね。この項は自身が <span class="inlinecode"><span class="id" title="inductive">option</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a></span> 型を持つということを指示する注釈を含んでいます。このことを <span class="inlinecode"><span class="id" title="inductive">option</span></span> の定義内の型変数 <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a></span> の明示的具体化と呼びます。

<div class="paragraph"> </div>

幸いなことに、今のケースではこの複雑な無名再帰関数をすぐに除くことができます。これは、引数である <span class="inlinecode">(<a class="idref" href="Cpdt.StackMachine.html#iConst"><span class="id" title="constructor">iConst</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="constructor">nil</span>)</span> <span class="inlinecode">++</span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a></span> の構造が、<span class="inlinecode"><span class="id" title="tactic">simpl</span></span> タクティクを使って内部のパターンマッチを簡約することで明らかになるからです。<span class="inlinecode"><span class="id" title="tactic">simpl</span></span> タクティクは先ほど <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> と共に使ったものと同じ簡約戦略を適用します(詳細はまだ触れません)。

</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a><br/>
&nbsp;<a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a><br/>
&nbsp;============================<br/>
&nbsp;(<span class="id" title="keyword">fix</span> <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<span class="id" title="var">p0</span> : <a class="idref" href="Cpdt.StackMachine.html#prog"><span class="id" title="definition">prog</span></a>) (<span class="id" title="var">s0</span> : <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a>) {<span class="id" title="keyword">struct</span> <span class="id" title="var">p0</span>} :<br/>
&nbsp;&nbsp;<span class="id" title="inductive">option</span> <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">p0</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <span class="id" title="constructor">Some</span> <span class="id" title="var">s0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.Large.html#Int.i"><span class="id" title="definition">i</span></a> :: <a class="idref" href="Cpdt.StackMachine.html#p'"><span class="id" title="variable">p'</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.StackMachine.html#instrDenote"><span class="id" title="definition">instrDenote</span></a> <a class="idref" href="Cpdt.Large.html#Int.i"><span class="id" title="definition">i</span></a> <span class="id" title="var">s0</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">Some</span> <span class="id" title="var">s'</span> ⇒ <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p'"><span class="id" title="variable">p'</span></a> <span class="id" title="var">s'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">None</span> ⇒ <span class="id" title="constructor">None</span> (<a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>:=<a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>) = <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

これで <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a></span> の定義を折り畳むことができます：

</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">fold</span> <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a><br/>
<a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a><br/>
============================<br/>
<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>) = <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

自明な等式になったので、このケースの証明はこれで終わりのように見えます。実際、次のタクティクを使えば証明は終わります：

</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

二つ目のサブゴールに入ります：

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> : <a class="idref" href="Cpdt.StackMachine.html#binop"><span class="id" title="inductive">binop</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a> : <a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">IHe1</span> : <span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a>) (<a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a> ++ <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> = <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a> :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a> : <a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">IHe2</span> : <span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a>) (<a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a> ++ <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> = <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a> :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a>) (<a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a>),<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Binop"><span class="id" title="constructor">Binop</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>) ++ <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> =<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Binop"><span class="id" title="constructor">Binop</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>) :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

初めての「仮定」の例が二重線の上に見えますね。部分項 <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a></span>, <span class="inlinecode"><a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a></span> に対応する帰納法の仮定 <span class="inlinecode"><span class="id" title="var">IHe1</span></span>, <span class="inlinecode"><span class="id" title="var">IHe2</span></span> です。

<div class="paragraph"> </div>

前回と同じように、自由変数を導入(<span class="inlinecode"><span class="id" title="tactic">intro</span></span>duce)し、適切な定義を展開(<span class="inlinecode"><span class="id" title="tactic">unfold</span></span>)し折り畳み(<span class="inlinecode"><span class="id" title="tactic">fold</span></span>)ます。<span class="inlinecode"><span class="id" title="tactic">unfold</span></span>/<span class="inlinecode"><span class="id" title="tactic">fold</span></span> は一見つまらないことをやっているように見えますが、実は <span class="inlinecode"><span class="id" title="tactic">unfold</span></span> は時折簡単な簡約を行うので、実に有益に働きます。  
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">fold</span> <a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Cpdt.StackMachine.html#expDenote"><span class="id" title="definition">expDenote</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">fold</span> <a class="idref" href="Cpdt.StackMachine.html#expDenote"><span class="id" title="definition">expDenote</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

今、私たちはこれまで見てきたタクティクでは不十分な地点に着きました。もう定義の展開は不要なので、他のことを試す必要があります。

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> : <a class="idref" href="Cpdt.StackMachine.html#binop"><span class="id" title="inductive">binop</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a> : <a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">IHe1</span> : <span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a>) (<a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a> ++ <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> = <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a> :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a> : <a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">IHe2</span> : <span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a>) (<a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a> ++ <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> = <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a> :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.StackMachine.html#stack"><span class="id" title="definition">stack</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.StackMachine.html#instr"><span class="id" title="inductive">instr</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> ((<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a> ++ <a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a> ++ <a class="idref" href="Cpdt.StackMachine.html#iBinop"><span class="id" title="constructor">iBinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> :: <span class="id" title="constructor">nil</span>) ++ <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> =<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.StackMachine.html#binopDenote"><span class="id" title="definition">binopDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>) :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

今必要なのは、リストの結合に関する結合律(associative law)です。これは標準ライブラリで定理 <span class="inlinecode"><span class="id" title="lemma">app_assoc_reverse</span></span> として利用できます。 (Coqの入力か出力かは、最後にピリオドがあるかどうかで見分けられます。)

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="lemma">app_assoc_reverse</span>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="lemma">app_assoc_reverse</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>), (<a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#m"><span class="id" title="variable">m</span></a>) ++ <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> = <a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#m"><span class="id" title="variable">m</span></a> ++ <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

もし使いたい定理の名前を知らなければ、<span class="inlinecode"><span class="id" title="keyword">SearchRewrite</span></span> コマンドを使って検索できます。<span class="inlinecode"><span class="id" title="keyword">SearchRewrite</span></span> は以下のように書き換えたいパターンを入力して使います： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">SearchRewrite</span> (<span class="id" title="notation">(</span><span class="id" title="var">_</span> <span class="id" title="notation">++</span> <span class="id" title="var">_</span><span class="id" title="notation">)</span> <span class="id" title="notation">++</span> <span class="id" title="var">_</span>).<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="lemma">app_assoc_reverse</span>:<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>), (<a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#m"><span class="id" title="variable">m</span></a>) ++ <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> = <a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#m"><span class="id" title="variable">m</span></a> ++ <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>
<div class="paragraph"> </div>

</span>
<br/>
<span class="inlinecode"><span class="id" title="lemma">app_assoc</span>: <span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a> <a class="idref" href="Cpdt.InductiveTypes.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>), <a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#m"><span class="id" title="variable">m</span></a> ++ <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> = (<a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a> ++ <a class="idref" href="Cpdt.InductiveTypes.html#m"><span class="id" title="variable">m</span></a>) ++ <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="lemma">app_assoc_reverse</span></span> で書き換えを行いましょう：  
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="lemma">app_assoc_reverse</span>.<br/>

<br/>
</div>

<div class="doc">
結論は以下のように変わります：

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a> ++ (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a> ++ <a class="idref" href="Cpdt.StackMachine.html#iBinop"><span class="id" title="constructor">iBinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> :: <span class="id" title="constructor">nil</span>) ++ <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> =<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.StackMachine.html#binopDenote"><span class="id" title="definition">binopDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>) :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

今、等式の左辺は二つ目の帰納法の仮定内の等式の左辺に一致していることが分かります。よってその仮定も書き換えに使えます。 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHe2</span>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> ((<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a> ++ <a class="idref" href="Cpdt.StackMachine.html#iBinop"><span class="id" title="constructor">iBinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> :: <span class="id" title="constructor">nil</span>) ++ <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a> :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>) =<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.StackMachine.html#binopDenote"><span class="id" title="definition">binopDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>) :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

同様のプロセスで残りの仮定も適用できます。 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="lemma">app_assoc_reverse</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHe1</span>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> ((<a class="idref" href="Cpdt.StackMachine.html#iBinop"><span class="id" title="constructor">iBinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> :: <span class="id" title="constructor">nil</span>) ++ <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a> :: <a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a> :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>) =<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.StackMachine.html#binopDenote"><span class="id" title="definition">binopDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>) :: <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

これで、先ほど終わらせた一つ目の証明と同様のタクティクを適用していくことができます。

</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <span class="id" title="tactic">at</span> 1.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">fold</span> <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>

<br/>
</div>

<div class="doc">
これで、以下のメッセージと共に証明が完了しました： 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<pre>
  Proof completed.
</pre>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

私たちの最初の証明ができました。既に、このような単純な定理に対しても、証明のスクリプトは構造化されておらず、あまり読者に教育的ではありません。もしこのアプローチをもっと本格的な定理に拡張しようとすれば、証明のスクリプトは可読性が低く、タクティク・ベースの証明に反対する人々には都合のいい批判の的となるでしょう。幸いなことに、Coq はスクリプトによる高機能な自動化をサポートしており、この補題に対して短い証明を与えることができます(自動化のタクティクは別の場所で定義しています)。これまで書いてきた証明の試みを中止し、新しく初めましょう。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="compile_correct'"><span class="id" title="lemma">compile_correct'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">e</span> <span class="id" title="var">s</span> <span class="id" title="var">p</span>, <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="notation">++</span> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a>) <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">=</span><br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> (<a class="idref" href="Cpdt.StackMachine.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>; <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

必要なのは帰納法による証明の決まり文句を書いて、残りの長々しい推論を自動化するタクティクを呼ぶことだけです。今回の証明ではタクティクの終わりでピリオドの変わりにセミコロンが使われています。セミコロンは二つのタクティクの間に使い、証明を構造化し合成します。タクティク <span class="inlinecode"><a class="idref" href="Cpdt.Reflection.html#t1"><span class="id" title="lemma">t1</span></a>;</span> <span class="inlinecode"><a class="idref" href="Cpdt.Match.html#t2"><span class="id" title="lemma">t2</span></a></span> は <span class="inlinecode"><a class="idref" href="Cpdt.Reflection.html#t1"><span class="id" title="lemma">t1</span></a></span> を適用し、その後残される各サブゴールに <span class="inlinecode"><a class="idref" href="Cpdt.Match.html#t2"><span class="id" title="lemma">t2</span></a></span> を適用します。セミコロンは効果的な証明の自動化のための基本的な構成要素の一つです。ピリオドは証明途中の確認すべき状態がどこにあるのかを予め調べるには便利です。しかし複雑な証明は最終的には、セミコロンなどを使って一つのタクティクに合成し、ピリオドが一つだけになるようにすべきです。

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="var">crush</span></span> タクティクは本書に付随したライブラリにあり、Coq の標準ライブラリ内のものではありません。本書のライブラリは証明の高度な自動化にとても役立つタクティクを他にもいくつか含んでいます。

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="keyword">Qed</span></span> コマンドは証明が実際に完了していることを確かめ、そうであればその証明を保存します。これまで書いてきたタクティクたちは<span class="inlinecode">証明スクリプト</span>、別の言葉で言えば Ltac プログラムの列で、これは正しく型付けされた Gallina の項です。定理が正しいことは、証明スクリプト自体ではなく、証明項が正しいことの(比較的単純な)検査器のみで信用できます。本書の第1部では証明を Gallina の項として表現することの原理について紹介します。

<div class="paragraph"> </div>

主定理は今、容易に証明できます。うまくセミコロンを使い、ピリオド四つで証明をします。この証明はより簡単に進みます。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="compile_correct"><span class="id" title="lemma">compile_correct</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">e</span>, <a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a>) <span class="id" title="constructor">nil</span> <span class="id" title="notation">=</span> <span class="id" title="constructor">Some</span> (<a class="idref" href="Cpdt.StackMachine.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="notation">::</span> <span class="id" title="constructor">nil</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a> : <a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> <a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a>) <span class="id" title="constructor">nil</span> = <span class="id" title="constructor">Some</span> (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a> :: <span class="id" title="constructor">nil</span>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

ここで、左辺を <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#compile_correct'"><span class="id" title="lemma">compile_correct'</span></a></span> の主張に合うように書き換えましょう。標準ライブラリの以下の定理が有効です： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="lemma">app_nil_end</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="lemma">app_nil_end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> (<a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a> : <a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="Cpdt.ProgLang.html#Forall.A"><span class="id" title="variable">A</span></a>), <a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a> = <a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a> ++ <span class="id" title="constructor">nil</span>
<div class="paragraph"> </div>

</span> 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="lemma">app_nil_end</span> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> <span class="id" title="var">e</span>)).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

結論にはリストが複数個現れているので、定理内の変数 <span class="inlinecode"><a class="idref" href="Cpdt.MoreDep.html#l"><span class="id" title="variable">l</span></a></span> の値を明示しました。どれを書き換えたいかを明示しなければ、<span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> タクティクは別の場所を選んで書き換えてしまうことがあります。

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a> : <a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#compile"><span class="id" title="definition">compile</span></a> <a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a> ++ <span class="id" title="constructor">nil</span>) <span class="id" title="constructor">nil</span> = <span class="id" title="constructor">Some</span> (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a> :: <span class="id" title="constructor">nil</span>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

これで補題が適用できます。 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <a class="idref" href="Cpdt.StackMachine.html#compile_correct'"><span class="id" title="lemma">compile_correct'</span></a>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a> : <a class="idref" href="Cpdt.Large.html#exp"><span class="id" title="inductive">exp</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a> <span class="id" title="constructor">nil</span> (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a> :: <span class="id" title="constructor">nil</span>) = <span class="id" title="constructor">Some</span> (<a class="idref" href="Cpdt.DataStruct.html#expDenote"><span class="id" title="definition">expDenote</span></a> <a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a> :: <span class="id" title="constructor">nil</span>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

ほとんどが終わりました。左辺と右辺はシンプルな記号的評価によって一致するように見えます。Coq は記号的評価によって同じ結果に正規化されるものはいつでも同じ項として見なします。<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#progDenote"><span class="id" title="definition">progDenote</span></a></span> の定義よりここでのケースも同様です。詳細は気にせずとも、<span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> タクティクはこの正規化をし左辺と右辺が構文的に等しいことを確かめます。 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

この証明はより短くでき自動化されますが、これは読者への演習問題としましょう。 
<div class="paragraph"> </div>

<a name="lab20"></a><h1 class="section">型付き式</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

この節では、安全のため項の静的片付けを持つような式の構造を追加した最初の例を作ります。 
<div class="paragraph"> </div>

<a name="lab21"></a><h2 class="section">ソース言語</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

式を区別するための型の自明な言語を定義します： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="type"><span class="id" title="inductive">type</span></a> : <span class="id" title="keyword">Set</span> := <a name="Nat"><span class="id" title="constructor">Nat</span></a> | <a name="Bool"><span class="id" title="constructor">Bool</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

ほとんどのプログラミング言語と同様に、Coq は変数名の大文字と小文字を区別します。よって今定義された型 <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a></span> は先ほど多相的な定理の主張の中で見た <span class="inlinecode"><span class="id" title="keyword">Type</span></span> キーワード(詳細は後で述べます)とは異なります。 また、コンストラクタの <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a></span>, <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#Bool"><span class="id" title="constructor">Bool</span></a></span> も標準ライブラリ内の型 <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a></span>, <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#bool"><span class="id" title="inductive">bool</span></a></span> とは異なります。

<div class="paragraph"> </div>

  拡張された二項演算子のセットを定義しましょう。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="tbinop"><span class="id" title="inductive">tbinop</span></a> : <a class="idref" href="Cpdt.StackMachine.html#type"><span class="id" title="inductive">type</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#type"><span class="id" title="inductive">type</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#type"><span class="id" title="inductive">type</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Set</span> :=<br/>
| <a name="TPlus"><span class="id" title="constructor">TPlus</span></a> : <a class="idref" href="Cpdt.StackMachine.html#tbinop"><span class="id" title="inductive">tbinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#Nat"><span class="id" title="constructor">Nat</span></a> <a class="idref" href="Cpdt.StackMachine.html#Nat"><span class="id" title="constructor">Nat</span></a> <a class="idref" href="Cpdt.StackMachine.html#Nat"><span class="id" title="constructor">Nat</span></a><br/>
| <a name="TTimes"><span class="id" title="constructor">TTimes</span></a> : <a class="idref" href="Cpdt.StackMachine.html#tbinop"><span class="id" title="inductive">tbinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#Nat"><span class="id" title="constructor">Nat</span></a> <a class="idref" href="Cpdt.StackMachine.html#Nat"><span class="id" title="constructor">Nat</span></a> <a class="idref" href="Cpdt.StackMachine.html#Nat"><span class="id" title="constructor">Nat</span></a><br/>
| <a name="TEq"><span class="id" title="constructor">TEq</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span>, <a class="idref" href="Cpdt.StackMachine.html#tbinop"><span class="id" title="inductive">tbinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="Cpdt.StackMachine.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="Cpdt.StackMachine.html#Bool"><span class="id" title="constructor">Bool</span></a><br/>
| <a name="TLt"><span class="id" title="constructor">TLt</span></a> : <a class="idref" href="Cpdt.StackMachine.html#tbinop"><span class="id" title="inductive">tbinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#Nat"><span class="id" title="constructor">Nat</span></a> <a class="idref" href="Cpdt.StackMachine.html#Nat"><span class="id" title="constructor">Nat</span></a> <a class="idref" href="Cpdt.StackMachine.html#Bool"><span class="id" title="constructor">Bool</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tbinop"><span class="id" title="inductive">tbinop</span></a></span> の定義は <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#binop"><span class="id" title="inductive">binop</span></a></span> と重要な意味で異なります。<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#binop"><span class="id" title="inductive">binop</span></a></span> は <span class="inlinecode"><span class="id" title="keyword">Set</span></span> 型を持つと宣言されましたが、<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tbinop"><span class="id" title="inductive">tbinop</span></a></span> は <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Set</span></span> 型と宣言しました。<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tbinop"><span class="id" title="inductive">tbinop</span></a></span> は <i>indexed type family</i> として定義します。Indexed inductive types は Coq の表現力の核で、私たちの興味のあるほとんどのものはこれで定義されます。

<div class="paragraph"> </div>

<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tbinop"><span class="id" title="inductive">tbinop</span></a></span> の直感的な説明は、<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tbinop"><span class="id" title="inductive">tbinop</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.Reflection.html#t1"><span class="id" title="lemma">t1</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.Match.html#t2"><span class="id" title="lemma">t2</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a></span> は型 <span class="inlinecode"><a class="idref" href="Cpdt.Reflection.html#t1"><span class="id" title="lemma">t1</span></a></span>, <span class="inlinecode"><a class="idref" href="Cpdt.Match.html#t2"><span class="id" title="lemma">t2</span></a></span> のオペランドを取り、型 <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a></span> の結果を返す二項演算子です。たとえば、コンストラクタ <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#TLt"><span class="id" title="constructor">TLt</span></a></span> (自然数の順序 ≦)は型 <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tbinop"><span class="id" title="inductive">tbinop</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#Bool"><span class="id" title="constructor">Bool</span></a></span> を持ち、引数が自然数、結果がブール値であることを意味します。<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#TEq"><span class="id" title="constructor">TEq</span></a></span> の型は多相性によって少し複雑になっています。<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#TEq"><span class="id" title="constructor">TEq</span></a></span> は同じ型を持つ値を任意に取れるようにしているのです。

<div class="paragraph"> </div>

ML や Haskell は添字付けされた代数的データ型を持ちます。たとえば、ML や Haskell のリスト型はリストの要素の型によって添字付けられています。しかしながら、ML や Haskelll 98 は Coq に比べるとデータ型の定義に関して二つの大きな制限があります。

<div class="paragraph"> </div>

まず、各データコンストラクタの添字はそのデータ型の定義のトップレベルで束縛された型変数でなければいけません。
たとえば、<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#TPlus"><span class="id" title="constructor">TPlus</span></a></span>は添字がすべて<span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a></span>に固定された<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tbinop"><span class="id" title="inductive">tbinop</span></a></span>を構成するコンストラクタですが、ML や Haskell ではそのようなことができません。
 <i>Generalized algebraic datatypes</i> (GADTs) はこの制限をなくす、広く普及した機能で、GHC Haskell、OCaml 4や、その他の言語で使用されます。

<div class="paragraph"> </div>

二つ目の制限は GADTs でも制限されたままです。ML や Haskell では、型の添字は必ず型であって、<span class="inlinecode">式</span>であってはいけません。Coq では、型は任意の Gallina 項により添字付けできます。型添字はプログラムと同じ領域に住むことができ、それらは通常のプログラムと同様に計算できます。
Haskellは
<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

同様にして、片付き式に対して型族を定義できます。型 <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#texp"><span class="id" title="inductive">texp</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a></span> を持つ項は対象言語の型 <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a></span> を割り当てられます。(対話的定理証明の世界では慣習的に、証明支援器の言語を<span class="inlinecode">メタ言語</span>と呼び、形式化されている言語を<span class="inlinecode">対象言語</span>と呼びます。)
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="texp"><span class="id" title="inductive">texp</span></a> : <a class="idref" href="Cpdt.StackMachine.html#type"><span class="id" title="inductive">type</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Set</span> :=<br/>
| <a name="TNConst"><span class="id" title="constructor">TNConst</span></a> : <span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#texp"><span class="id" title="inductive">texp</span></a> <a class="idref" href="Cpdt.StackMachine.html#Nat"><span class="id" title="constructor">Nat</span></a><br/>
| <a name="TBConst"><span class="id" title="constructor">TBConst</span></a> : <span class="id" title="inductive">bool</span> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#texp"><span class="id" title="inductive">texp</span></a> <a class="idref" href="Cpdt.StackMachine.html#Bool"><span class="id" title="constructor">Bool</span></a><br/>
| <a name="TBinop"><span class="id" title="constructor">TBinop</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t1</span> <span class="id" title="var">t2</span> <span class="id" title="var">t</span>, <a class="idref" href="Cpdt.StackMachine.html#tbinop"><span class="id" title="inductive">tbinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#t1"><span class="id" title="variable">t1</span></a> <a class="idref" href="Cpdt.StackMachine.html#t2"><span class="id" title="variable">t2</span></a> <a class="idref" href="Cpdt.StackMachine.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#texp"><span class="id" title="inductive">texp</span></a> <a class="idref" href="Cpdt.StackMachine.html#t1"><span class="id" title="variable">t1</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#texp"><span class="id" title="inductive">texp</span></a> <a class="idref" href="Cpdt.StackMachine.html#t2"><span class="id" title="variable">t2</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#texp"><span class="id" title="inductive">texp</span></a> <a class="idref" href="Cpdt.StackMachine.html#t"><span class="id" title="variable">t</span></a>.<br/>

<br/>
</div>

<div class="doc">
依存型のおかげで、構成から、すべての well-typed な <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#texp"><span class="id" title="inductive">texp</span></a></span> は well-typed なソース言語の式を表します。これは私たちがこれから式についてしたい様々なことに対してとても便利であることが分かります。たとえば、今までのようなセマンティクスを定義するインタプリタのアプローチに適合させるのが簡単です。まず、オブジェクト言語の型を Coq の型に移す写像を定義します： 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="typeDenote"><span class="id" title="definition">typeDenote</span></a> (<span class="id" title="var">t</span> : <a class="idref" href="Cpdt.StackMachine.html#type"><span class="id" title="inductive">type</span></a>) : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.StackMachine.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#Nat"><span class="id" title="constructor">Nat</span></a> ⇒ <span class="id" title="inductive">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#Bool"><span class="id" title="constructor">Bool</span></a> ⇒ <span class="id" title="inductive">bool</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

ここで、いくつかの事実について触れておきましょう。「プログラムの型」の型である <span class="inlinecode"><span class="id" title="keyword">Set</span></span> はそれ自身がファーストクラスの型で、私たちは <span class="inlinecode"><span class="id" title="keyword">Set</span></span> を返す関数を書くことができます。<span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a></span> の定義は明白で、Coq 標準ライブラリの型 <span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#nat"><span class="id" title="inductive">nat</span></a></span>, <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#bool"><span class="id" title="inductive">bool</span></a></span> を使っています。私たちの二項演算子は、標準ライブラリ内の比較関数 <span class="inlinecode"><span class="id" title="definition">eqb</span></span>, <span class="inlinecode"><span class="id" title="abbreviation">beq_nat</span></span> や <span class="inlinecode"><span class="id" title="abbreviation">leb</span></span> を使って定義できます。それぞれ、ブール値間、自然数値間のイコール、自然数の≦を表します。
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="tbinopDenote"><span class="id" title="definition">tbinopDenote</span></a> <span class="id" title="var">arg1</span> <span class="id" title="var">arg2</span> <span class="id" title="var">res</span> (<span class="id" title="var">b</span> : <a class="idref" href="Cpdt.StackMachine.html#tbinop"><span class="id" title="inductive">tbinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#arg1"><span class="id" title="variable">arg1</span></a> <a class="idref" href="Cpdt.StackMachine.html#arg2"><span class="id" title="variable">arg2</span></a> <a class="idref" href="Cpdt.StackMachine.html#res"><span class="id" title="variable">res</span></a>)<br/>
&nbsp;&nbsp;: <a class="idref" href="Cpdt.StackMachine.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#arg1"><span class="id" title="variable">arg1</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#arg2"><span class="id" title="variable">arg2</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#res"><span class="id" title="variable">res</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TPlus"><span class="id" title="constructor">TPlus</span></a> ⇒ <span class="id" title="abbreviation">plus</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TTimes"><span class="id" title="constructor">TTimes</span></a> ⇒ <span class="id" title="abbreviation">mult</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TEq"><span class="id" title="constructor">TEq</span></a> <a class="idref" href="Cpdt.StackMachine.html#Nat"><span class="id" title="constructor">Nat</span></a> ⇒ <span class="id" title="abbreviation">beq_nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TEq"><span class="id" title="constructor">TEq</span></a> <a class="idref" href="Cpdt.StackMachine.html#Bool"><span class="id" title="constructor">Bool</span></a> ⇒ <span class="id" title="definition">eqb</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TLt"><span class="id" title="constructor">TLt</span></a> ⇒ <span class="id" title="abbreviation">leb</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

この関数は先ほど定義した表示関数と比べていくつか違いがあります。まず、<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tbinop"><span class="id" title="inductive">tbinop</span></a></span> は添字付けされた型なので、その添字は <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tbinopDenote"><span class="id" title="definition">tbinopDenote</span></a></span> の追加の引数になります。
次に、それぞれの場合分けでの<span class="inlinecode">型</span>がマッチされる<span class="inlinecode">値</span>に依存する場合には正銘の<span class="inlinecode">依存パターンマッチ</span>が必要です。
ここでは依存パターンマッチを支援するGallinaのたくさんのうまい側面について詳細は述べませんが、このテーマは本書の第2部の中心となります。

<div class="paragraph"> </div>

同じ仕組みにより、式の表示関数を自然な方法で定義できます。
コンストラクタ<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#TBinop"><span class="id" title="constructor">TBinop</span></a></span>の<span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a></span>型の引数はパターンマッチの中で明示的に含まなければいけませんが、ここではそれらの引数を直接参照する必要はないのでアンダースコアを書きます。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="texpDenote"><span class="id" title="definition">texpDenote</span></a> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.StackMachine.html#texp"><span class="id" title="inductive">texp</span></a> <a class="idref" href="Cpdt.StackMachine.html#t"><span class="id" title="variable">t</span></a>) : <a class="idref" href="Cpdt.StackMachine.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#t"><span class="id" title="variable">t</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> <span class="id" title="var">n</span> ⇒ <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TBConst"><span class="id" title="constructor">TBConst</span></a> <span class="id" title="var">b</span> ⇒ <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TBinop"><span class="id" title="constructor">TBinop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">b</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ (<a class="idref" href="Cpdt.StackMachine.html#tbinopDenote"><span class="id" title="definition">tbinopDenote</span></a> <span class="id" title="var">b</span>) (<a class="idref" href="Cpdt.StackMachine.html#texpDenote"><span class="id" title="definition">texpDenote</span></a> <span class="id" title="var">e1</span>) (<a class="idref" href="Cpdt.StackMachine.html#texpDenote"><span class="id" title="definition">texpDenote</span></a> <span class="id" title="var">e2</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

このセマンティクスが正しいことを確かめるためにいくつかのプログラムの例を評価します。
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.StackMachine.html#texpDenote"><span class="id" title="definition">texpDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 42).<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode">42</span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a></span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.StackMachine.html#texpDenote"><span class="id" title="definition">texpDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TBConst"><span class="id" title="constructor">TBConst</span></a> <span class="id" title="constructor">true</span>).<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#true"><span class="id" title="constructor">true</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#Bool"><span class="id" title="constructor">Bool</span></a></span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.StackMachine.html#texpDenote"><span class="id" title="definition">texpDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TBinop"><span class="id" title="constructor">TBinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#TTimes"><span class="id" title="constructor">TTimes</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TBinop"><span class="id" title="constructor">TBinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#TPlus"><span class="id" title="constructor">TPlus</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 2) (<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 2))<br/>
&nbsp;&nbsp;(<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 7)).<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode">28</span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a></span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.StackMachine.html#texpDenote"><span class="id" title="definition">texpDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TBinop"><span class="id" title="constructor">TBinop</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TEq"><span class="id" title="constructor">TEq</span></a> <a class="idref" href="Cpdt.StackMachine.html#Nat"><span class="id" title="constructor">Nat</span></a>) (<a class="idref" href="Cpdt.StackMachine.html#TBinop"><span class="id" title="constructor">TBinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#TPlus"><span class="id" title="constructor">TPlus</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 2) (<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 2))<br/>
&nbsp;&nbsp;(<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 7)).<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#false"><span class="id" title="constructor">false</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#Bool"><span class="id" title="constructor">Bool</span></a></span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.StackMachine.html#texpDenote"><span class="id" title="definition">texpDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TBinop"><span class="id" title="constructor">TBinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#TLt"><span class="id" title="constructor">TLt</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TBinop"><span class="id" title="constructor">TBinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#TPlus"><span class="id" title="constructor">TPlus</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 2) (<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 2))<br/>
&nbsp;&nbsp;(<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 7)).<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#true"><span class="id" title="constructor">true</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#typeDenote"><span class="id" title="definition">typeDenote</span></a></span> <span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#Bool"><span class="id" title="constructor">Bool</span></a></span> 
<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

今、コンパイルのための適切なスタックマシンを定義する準備ができました。
<div class="paragraph"> </div>

<a name="lab22"></a><h2 class="section">ターゲット言語</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

型無しの言語の例では、スタックマシーンプログラムはスタックアンダーフローを起こし動かなくなるかもしれません。私たちのコンパイラはアンダーフローするプログラムを生み出さないことを証明したにも関わらず、そのような複雑な状況を扱うのは好ましくありません。
すべてのスタックマシーンプログラムにアンダーフローがないように強制するために依存型を使えたかもしれません。

<div class="paragraph"> </div>

私たちの言語では、アンダーフローに加えて、ブール値ではなく自然数がスタックに入ったり、その逆が起きたりする問題があります。

<div class="paragraph"> </div>

可能なスタックの集合を区別する、スタック型を定義することから始めます。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="tstack"><span class="id" title="definition">tstack</span></a> := <span class="id" title="inductive">list</span> <a class="idref" href="Cpdt.StackMachine.html#type"><span class="id" title="inductive">type</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tstack"><span class="id" title="definition">tstack</span></a></span>で区別されるスタックは同じ数だけ要素を持ち、各スタックの要素はそのスタック型における同じ位置にある型を持たなければいけません。

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="tinstr"><span class="id" title="inductive">tinstr</span></a> : <a class="idref" href="Cpdt.StackMachine.html#tstack"><span class="id" title="definition">tstack</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#tstack"><span class="id" title="definition">tstack</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Set</span> :=<br/>
| <a name="TiNConst"><span class="id" title="constructor">TiNConst</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">s</span>, <span class="id" title="inductive">nat</span> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#tinstr"><span class="id" title="inductive">tinstr</span></a> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Nat"><span class="id" title="constructor">Nat</span></a> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a>)<br/>
| <a name="TiBConst"><span class="id" title="constructor">TiBConst</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">s</span>, <span class="id" title="inductive">bool</span> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#tinstr"><span class="id" title="inductive">tinstr</span></a> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a> (<a class="idref" href="Cpdt.StackMachine.html#Bool"><span class="id" title="constructor">Bool</span></a> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a>)<br/>
| <a name="TiBinop"><span class="id" title="constructor">TiBinop</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">arg1</span> <span class="id" title="var">arg2</span> <span class="id" title="var">res</span> <span class="id" title="var">s</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#tbinop"><span class="id" title="inductive">tbinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#arg1"><span class="id" title="variable">arg1</span></a> <a class="idref" href="Cpdt.StackMachine.html#arg2"><span class="id" title="variable">arg2</span></a> <a class="idref" href="Cpdt.StackMachine.html#res"><span class="id" title="variable">res</span></a><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#tinstr"><span class="id" title="inductive">tinstr</span></a> (<a class="idref" href="Cpdt.StackMachine.html#arg1"><span class="id" title="variable">arg1</span></a> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.StackMachine.html#arg2"><span class="id" title="variable">arg2</span></a> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a>) (<a class="idref" href="Cpdt.StackMachine.html#res"><span class="id" title="variable">res</span></a> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a>).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

もしここでも<span class="inlinecode"><a class="idref" href="Cpdt.InductiveTypes.html#list"><span class="id" title="inductive">list</span></a></span>型族を使ったら、中間的なスタック型がプログラムに合うことが保証されないので、スタックマシーンプログラムは必ず同様な帰納的なデータでなればいません。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="tprog"><span class="id" title="inductive">tprog</span></a> : <a class="idref" href="Cpdt.StackMachine.html#tstack"><span class="id" title="definition">tstack</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#tstack"><span class="id" title="definition">tstack</span></a> <span class="id" title="notation">→</span> <span class="id" title="keyword">Set</span> :=<br/>
| <a name="TNil"><span class="id" title="constructor">TNil</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">s</span>, <a class="idref" href="Cpdt.StackMachine.html#tprog"><span class="id" title="inductive">tprog</span></a> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a><br/>
| <a name="TCons"><span class="id" title="constructor">TCons</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">s1</span> <span class="id" title="var">s2</span> <span class="id" title="var">s3</span>,<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#tinstr"><span class="id" title="inductive">tinstr</span></a> <a class="idref" href="Cpdt.StackMachine.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="Cpdt.StackMachine.html#s2"><span class="id" title="variable">s2</span></a><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#tprog"><span class="id" title="inductive">tprog</span></a> <a class="idref" href="Cpdt.StackMachine.html#s2"><span class="id" title="variable">s2</span></a> <a class="idref" href="Cpdt.StackMachine.html#s3"><span class="id" title="variable">s3</span></a><br/>
&nbsp;&nbsp;<span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#tprog"><span class="id" title="inductive">tprog</span></a> <a class="idref" href="Cpdt.StackMachine.html#s1"><span class="id" title="variable">s1</span></a> <a class="idref" href="Cpdt.StackMachine.html#s3"><span class="id" title="variable">s3</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

新しいターゲット言語のセマンティクスを定義するために、ランタイムでのスタックの表現が必要です。正しい数と型を持つ要素を含む値のスタックの型を定義します。ここでも型の情報が役立ちます。
この構成の仕方から、スタックは正しい数と型を持つ要素を含むようにスタック型が定義されます。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="vstack"><span class="id" title="definition">vstack</span></a> (<span class="id" title="var">ts</span> : <a class="idref" href="Cpdt.StackMachine.html#tstack"><span class="id" title="definition">tstack</span></a>) : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">nil</span> ⇒ <span class="id" title="inductive">unit</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">t</span> <span class="id" title="notation">::</span> <span class="id" title="var">ts'</span> ⇒ <a class="idref" href="Cpdt.StackMachine.html#typeDenote"><span class="id" title="definition">typeDenote</span></a> <span class="id" title="var">t</span> <span class="id" title="notation">×</span> <a class="idref" href="Cpdt.StackMachine.html#vstack"><span class="id" title="definition">vstack</span></a> <span class="id" title="var">ts'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>%<span class="id" title="var">type</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

新しい<span class="inlinecode"><span class="id" title="keyword">Set</span></span>値関数です。
今回は再帰関数です。<span class="inlinecode"><span class="id" title="keyword">Set</span></span>はどの関数が書かれるかを決めるのに特別に扱われないため、完全に妥当です。
この関数は、空のスタック型のスタック値は<span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#unit"><span class="id" title="inductive">unit</span></a></span>型の任意の値であると言っています。
<span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#unit"><span class="id" title="inductive">unit</span></a></span>はただ一つの値<span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#tt"><span class="id" title="constructor">tt</span></a></span>を持つ型です。
空でないスタック型はペアの値スタックを導きます。ペアの一つ目の要素は適切な型を持ち、二つ目の要素は残りのスタック型の表現に従います。
<span class="inlinecode">%</span><tt>type</tt>と書いてCoqの拡張可能なパーサへある命令をしています。
特に、この命令は<span class="inlinecode"><span class="id" title="keyword">match</span></span>式全体にかかっていて、演算子<span class="inlinecode">×</span>が乗算ではなくデカルト積として解釈されるようにその<span class="inlinecode"><span class="id" title="keyword">match</span></span>式を型であるかのようにパースされるようにしています。
(ここでの<tt>type</tt>は先ほど定義した帰納的データ型<span class="inlinecode"><a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a></span>とはつながりはありません。)

<div class="paragraph"> </div>

この、型を使ったプログラミングのアイデアは身につけるのにしばらくかかりますが、instruction denotationのとてもシンプルな定義を可能にします。
私たちの定義は型情報を無視するLisp的なMLに期待するかもしれないものになっています。
それにもかかわらず、<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tinstrDenote"><span class="id" title="definition">tinstrDenote</span></a></span>が型検査を通るという事実は、私たちのスタックマシーンプログラムは絶対にうまくいかなくなることがないということを保証します。
multi-level tupleを分解するために、<span class="inlinecode"><span class="id" title="keyword">let</span></span>の特殊な形を使います。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="tinstrDenote"><span class="id" title="definition">tinstrDenote</span></a> <span class="id" title="var">ts</span> <span class="id" title="var">ts'</span> (<span class="id" title="var">i</span> : <a class="idref" href="Cpdt.StackMachine.html#tinstr"><span class="id" title="inductive">tinstr</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts'"><span class="id" title="variable">ts'</span></a>) : <a class="idref" href="Cpdt.StackMachine.html#vstack"><span class="id" title="definition">vstack</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#vstack"><span class="id" title="definition">vstack</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts'"><span class="id" title="variable">ts'</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.StackMachine.html#i"><span class="id" title="variable">i</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TiNConst"><span class="id" title="constructor">TiNConst</span></a> <span class="id" title="var">_</span> <span class="id" title="var">n</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <span class="id" title="notation">(</span><span class="id" title="var">n</span><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TiBConst"><span class="id" title="constructor">TiBConst</span></a> <span class="id" title="var">_</span> <span class="id" title="var">b</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <span class="id" title="notation">(</span><span class="id" title="var">b</span><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TiBinop"><span class="id" title="constructor">TiBinop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">b</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> '<span class="id" title="notation">(</span><span class="id" title="var">arg1</span><span class="id" title="notation">,</span> <span class="id" title="notation">(</span><span class="id" title="var">arg2</span><span class="id" title="notation">,</span> <span class="id" title="var">s'</span><span class="id" title="notation">))</span> := <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">(</span>(<a class="idref" href="Cpdt.StackMachine.html#tbinopDenote"><span class="id" title="definition">tbinopDenote</span></a> <span class="id" title="var">b</span>) <span class="id" title="var">arg1</span> <span class="id" title="var">arg2</span><span class="id" title="notation">,</span> <span class="id" title="var">s'</span><span class="id" title="notation">)</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

なぜ<span class="inlinecode"><span class="id" title="keyword">match</span></span>の各ケースで無名関数を使って初期のスタックを束縛したのでしょうか？　代わりに次を考えましょう：
<br/>
<span class="inlinecode"><span class="id" title="keyword">Definition</span> <a class="idref" href="Cpdt.StackMachine.html#tinstrDenote"><span class="id" title="definition">tinstrDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts'"><span class="id" title="variable">ts'</span></a> (<a class="idref" href="Cpdt.Large.html#Int.i"><span class="id" title="definition">i</span></a> : <a class="idref" href="Cpdt.StackMachine.html#tinstr"><span class="id" title="inductive">tinstr</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts'"><span class="id" title="variable">ts'</span></a>) (<a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> : <a class="idref" href="Cpdt.StackMachine.html#vstack"><span class="id" title="definition">vstack</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a>) : <a class="idref" href="Cpdt.StackMachine.html#vstack"><span class="id" title="definition">vstack</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts'"><span class="id" title="variable">ts'</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Large.html#Int.i"><span class="id" title="definition">i</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TiNConst"><span class="id" title="constructor">TiNConst</span></a> <span class="id" title="var">_</span> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> ⇒ (<a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>, <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TiBConst"><span class="id" title="constructor">TiBConst</span></a> <span class="id" title="var">_</span> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> ⇒ (<a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a>, <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TiBinop"><span class="id" title="constructor">TiBinop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> '(<a class="idref" href="Cpdt.StackMachine.html#arg1"><span class="id" title="variable">arg1</span></a>, (<a class="idref" href="Cpdt.StackMachine.html#arg2"><span class="id" title="variable">arg2</span></a>, <span class="id" title="var">s'</span>)) := <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<a class="idref" href="Cpdt.StackMachine.html#tbinopDenote"><span class="id" title="definition">tbinopDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a>) <a class="idref" href="Cpdt.StackMachine.html#arg1"><span class="id" title="variable">arg1</span></a> <a class="idref" href="Cpdt.StackMachine.html#arg2"><span class="id" title="variable">arg2</span></a>, <span class="id" title="var">s'</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Coqの型チェッカは以下のようなエラーを出力します：

<div class="paragraph"> </div>

<pre>
The term "(n, s)" has type "(nat * vstack ts)%type"
 while it is expected to have type "vstack ?119".
</pre>

<div class="paragraph"> </div>

このようなCoqの依存型の型付けの奥深い箇所については2部で述べます。ここでの要点は、関数の引数の型がマッチする値の型に依存するときは、<span class="inlinecode"><span class="id" title="keyword">match</span></span>の分岐の中にそれらの引数を入れるとしばしば役立つということです。後に、この理由はGallinaの型付け規則をより完全に取り扱うことで説明されます。

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

プログラムの表示の直接的な定義によってセマンティクスを終えます。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="tprogDenote"><span class="id" title="definition">tprogDenote</span></a> <span class="id" title="var">ts</span> <span class="id" title="var">ts'</span> (<span class="id" title="var">p</span> : <a class="idref" href="Cpdt.StackMachine.html#tprog"><span class="id" title="inductive">tprog</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts'"><span class="id" title="variable">ts'</span></a>) : <a class="idref" href="Cpdt.StackMachine.html#vstack"><span class="id" title="definition">vstack</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#vstack"><span class="id" title="definition">vstack</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts'"><span class="id" title="variable">ts'</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TNil"><span class="id" title="constructor">TNil</span></a> <span class="id" title="var">_</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TCons"><span class="id" title="constructor">TCons</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">i</span> <span class="id" title="var">p'</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">s</span> ⇒ <a class="idref" href="Cpdt.StackMachine.html#tprogDenote"><span class="id" title="definition">tprogDenote</span></a> <span class="id" title="var">p'</span> (<a class="idref" href="Cpdt.StackMachine.html#tinstrDenote"><span class="id" title="definition">tinstrDenote</span></a> <span class="id" title="var">i</span> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

この定義でも引数を<span class="inlinecode"><span class="id" title="keyword">match</span></span>の中に入れるテクニックが重要となります。

<div class="paragraph"> </div>

<a name="lab23"></a><h2 class="section">翻訳</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

コンパイルを定義するために、二つのスタックマシーンプログラムを結合する補助関数が有用になります。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="tconcat"><span class="id" title="definition">tconcat</span></a> <span class="id" title="var">ts</span> <span class="id" title="var">ts'</span> <span class="id" title="var">ts''</span> (<span class="id" title="var">p</span> : <a class="idref" href="Cpdt.StackMachine.html#tprog"><span class="id" title="inductive">tprog</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts'"><span class="id" title="variable">ts'</span></a>) : <a class="idref" href="Cpdt.StackMachine.html#tprog"><span class="id" title="inductive">tprog</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts'"><span class="id" title="variable">ts'</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts''"><span class="id" title="variable">ts''</span></a> <span class="id" title="notation">→</span> <a class="idref" href="Cpdt.StackMachine.html#tprog"><span class="id" title="inductive">tprog</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts''"><span class="id" title="variable">ts''</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TNil"><span class="id" title="constructor">TNil</span></a> <span class="id" title="var">_</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">p'</span> ⇒ <a class="idref" href="Cpdt.StackMachine.html#p'"><span class="id" title="variable">p'</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TCons"><span class="id" title="constructor">TCons</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">i</span> <span class="id" title="var">p1</span> ⇒ <span class="id" title="keyword">fun</span> <span class="id" title="var">p'</span> ⇒ <a class="idref" href="Cpdt.StackMachine.html#TCons"><span class="id" title="constructor">TCons</span></a> <span class="id" title="var">i</span> (<a class="idref" href="Cpdt.StackMachine.html#tconcat"><span class="id" title="definition">tconcat</span></a> <span class="id" title="var">p1</span> <a class="idref" href="Cpdt.StackMachine.html#p'"><span class="id" title="variable">p'</span></a>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

この関数によって、コンパイル関数は依存型を使う前とよく似た形で定義されます。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="tcompile"><span class="id" title="definition">tcompile</span></a> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.StackMachine.html#texp"><span class="id" title="inductive">texp</span></a> <a class="idref" href="Cpdt.StackMachine.html#t"><span class="id" title="variable">t</span></a>) (<span class="id" title="var">ts</span> : <a class="idref" href="Cpdt.StackMachine.html#tstack"><span class="id" title="definition">tstack</span></a>) : <a class="idref" href="Cpdt.StackMachine.html#tprog"><span class="id" title="inductive">tprog</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> (<a class="idref" href="Cpdt.StackMachine.html#t"><span class="id" title="variable">t</span></a> <span class="id" title="notation">::</span> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> <span class="id" title="var">n</span> ⇒ <a class="idref" href="Cpdt.StackMachine.html#TCons"><span class="id" title="constructor">TCons</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TiNConst"><span class="id" title="constructor">TiNConst</span></a> <span class="id" title="var">_</span> <span class="id" title="var">n</span>) (<a class="idref" href="Cpdt.StackMachine.html#TNil"><span class="id" title="constructor">TNil</span></a> <span class="id" title="var">_</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TBConst"><span class="id" title="constructor">TBConst</span></a> <span class="id" title="var">b</span> ⇒ <a class="idref" href="Cpdt.StackMachine.html#TCons"><span class="id" title="constructor">TCons</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TiBConst"><span class="id" title="constructor">TiBConst</span></a> <span class="id" title="var">_</span> <span class="id" title="var">b</span>) (<a class="idref" href="Cpdt.StackMachine.html#TNil"><span class="id" title="constructor">TNil</span></a> <span class="id" title="var">_</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TBinop"><span class="id" title="constructor">TBinop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">b</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> ⇒ <a class="idref" href="Cpdt.StackMachine.html#tconcat"><span class="id" title="definition">tconcat</span></a> (<a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a> <span class="id" title="var">e2</span> <span class="id" title="var">_</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.StackMachine.html#tconcat"><span class="id" title="definition">tconcat</span></a> (<a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a> <span class="id" title="var">e1</span> <span class="id" title="var">_</span>) (<a class="idref" href="Cpdt.StackMachine.html#TCons"><span class="id" title="constructor">TCons</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TiBinop"><span class="id" title="constructor">TiBinop</span></a> <span class="id" title="var">_</span> <span class="id" title="var">b</span>) (<a class="idref" href="Cpdt.StackMachine.html#TNil"><span class="id" title="constructor">TNil</span></a> <span class="id" title="var">_</span>)))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

この定義の中の一つの面白い特徴は、矢印<span class="inlinecode">⇒</span>の右に現れるアンダースコアです。
HaskellやMLのプログラマーは多相的な値の型パラメータを推論するコンパイラに非常になじみがあるでしょう。
Coqではさらに踏み込んで、特定の値の位置にアンダースコアを書くことで任意の項に対しそれを推論するようにシステムに尋ねることが可能です。
これまでの定義で引数をすべては与えずに関数を呼び出していることに読者のみなさんは気付いているかもしれません。
たとえば、<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a></span>の再帰呼び出しは引数<span class="inlinecode"><a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a></span>を省略しています。
Coqの<i>implicit argument</i>のメカニズムは推論ができるかもしれない引数に対して自動でアンダースコアを挿入します。
しかしそのような値の推論は完全からほど遠いです。
一般に、HaskellやMLの多層型instantiationに似た場合でしか機能しません。

<div class="paragraph"> </div>

ここでのアンダースコアはスタックの型が入ります。
つまり、Coqの型推論器は翻訳されたプログラムの制御フローについてのものを推論していると言えます。
以下のようにして、何の値が入っているか確認できます：

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a> =<br/>
<span class="id" title="keyword">fix</span> <a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a> (<a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a> : <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a>) (<a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a> : <a class="idref" href="Cpdt.StackMachine.html#texp"><span class="id" title="inductive">texp</span></a> <a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a>) (<a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> : <a class="idref" href="Cpdt.StackMachine.html#tstack"><span class="id" title="definition">tstack</span></a>) {<span class="id" title="keyword">struct</span> <a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a>} :<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#tprog"><span class="id" title="inductive">tprog</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> (<a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a> :: <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="Cpdt.Reflection.html#monoid.e"><span class="id" title="variable">e</span></a> <span class="id" title="keyword">in</span> (<a class="idref" href="Cpdt.StackMachine.html#texp"><span class="id" title="inductive">texp</span></a> <span class="id" title="var">t0</span>) <span class="id" title="keyword">return</span> (<a class="idref" href="Cpdt.StackMachine.html#tprog"><span class="id" title="inductive">tprog</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> (<span class="id" title="var">t0</span> :: <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a>)) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a> ⇒ <a class="idref" href="Cpdt.StackMachine.html#TCons"><span class="id" title="constructor">TCons</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TiNConst"><span class="id" title="constructor">TiNConst</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> <a class="idref" href="Cpdt.MoreDep.html#dec_star.dec_star''.n"><span class="id" title="variable">n</span></a>) (<a class="idref" href="Cpdt.StackMachine.html#TNil"><span class="id" title="constructor">TNil</span></a> (<a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a> :: <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a>))<br/>
&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TBConst"><span class="id" title="constructor">TBConst</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> ⇒ <a class="idref" href="Cpdt.StackMachine.html#TCons"><span class="id" title="constructor">TCons</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TiBConst"><span class="id" title="constructor">TiBConst</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a>) (<a class="idref" href="Cpdt.StackMachine.html#TNil"><span class="id" title="constructor">TNil</span></a> (<a class="idref" href="Cpdt.DataStruct.html#Bool"><span class="id" title="constructor">Bool</span></a> :: <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a>))<br/>
&nbsp;&nbsp;| <a class="idref" href="Cpdt.StackMachine.html#TBinop"><span class="id" title="constructor">TBinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#arg1"><span class="id" title="variable">arg1</span></a> <a class="idref" href="Cpdt.StackMachine.html#arg2"><span class="id" title="variable">arg2</span></a> <a class="idref" href="Cpdt.StackMachine.html#res"><span class="id" title="variable">res</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#tconcat"><span class="id" title="definition">tconcat</span></a> (<a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a> <a class="idref" href="Cpdt.StackMachine.html#arg2"><span class="id" title="variable">arg2</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.StackMachine.html#tconcat"><span class="id" title="definition">tconcat</span></a> (<a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a> <a class="idref" href="Cpdt.StackMachine.html#arg1"><span class="id" title="variable">arg1</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a> (<a class="idref" href="Cpdt.StackMachine.html#arg2"><span class="id" title="variable">arg2</span></a> :: <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.StackMachine.html#TCons"><span class="id" title="constructor">TCons</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TiBinop"><span class="id" title="constructor">TiBinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> <a class="idref" href="Cpdt.StackMachine.html#b"><span class="id" title="variable">b</span></a>) (<a class="idref" href="Cpdt.StackMachine.html#TNil"><span class="id" title="constructor">TNil</span></a> (<a class="idref" href="Cpdt.StackMachine.html#res"><span class="id" title="variable">res</span></a> :: <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a>))))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a> : <a class="idref" href="Cpdt.ProgLang.html#type"><span class="id" title="inductive">type</span></a>, <a class="idref" href="Cpdt.StackMachine.html#texp"><span class="id" title="inductive">texp</span></a> <a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a> → <span class="id" title="keyword">∀</span> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> : <a class="idref" href="Cpdt.StackMachine.html#tstack"><span class="id" title="definition">tstack</span></a>, <a class="idref" href="Cpdt.StackMachine.html#tprog"><span class="id" title="inductive">tprog</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> (<a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a> :: <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

上から、適切に振舞うプログラムをコンパイラが生成することを確認できます：

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.StackMachine.html#tprogDenote"><span class="id" title="definition">tprogDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 42) <span class="id" title="constructor">nil</span>) <span class="id" title="constructor">tt</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode">(42,</span> <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#tt"><span class="id" title="constructor">tt</span></a>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#vstack"><span class="id" title="definition">vstack</span></a></span> <span class="inlinecode">(<a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="constructor">nil</span>)</span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.StackMachine.html#tprogDenote"><span class="id" title="definition">tprogDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TBConst"><span class="id" title="constructor">TBConst</span></a> <span class="id" title="constructor">true</span>) <span class="id" title="constructor">nil</span>) <span class="id" title="constructor">tt</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode">(<a class="idref" href="Cpdt.Predicates.html#true"><span class="id" title="constructor">true</span></a>,</span> <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#tt"><span class="id" title="constructor">tt</span></a>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#vstack"><span class="id" title="definition">vstack</span></a></span> <span class="inlinecode">(<a class="idref" href="Cpdt.DataStruct.html#Bool"><span class="id" title="constructor">Bool</span></a></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="constructor">nil</span>)</span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.StackMachine.html#tprogDenote"><span class="id" title="definition">tprogDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TBinop"><span class="id" title="constructor">TBinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#TTimes"><span class="id" title="constructor">TTimes</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TBinop"><span class="id" title="constructor">TBinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#TPlus"><span class="id" title="constructor">TPlus</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 2)<br/>
&nbsp;&nbsp;(<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 2)) (<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 7)) <span class="id" title="constructor">nil</span>) <span class="id" title="constructor">tt</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode">(28,</span> <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#tt"><span class="id" title="constructor">tt</span></a>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#vstack"><span class="id" title="definition">vstack</span></a></span> <span class="inlinecode">(<a class="idref" href="Cpdt.ProgLang.html#Nat"><span class="id" title="constructor">Nat</span></a></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="constructor">nil</span>)</span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.StackMachine.html#tprogDenote"><span class="id" title="definition">tprogDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TBinop"><span class="id" title="constructor">TBinop</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TEq"><span class="id" title="constructor">TEq</span></a> <a class="idref" href="Cpdt.StackMachine.html#Nat"><span class="id" title="constructor">Nat</span></a>) (<a class="idref" href="Cpdt.StackMachine.html#TBinop"><span class="id" title="constructor">TBinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#TPlus"><span class="id" title="constructor">TPlus</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 2)<br/>
&nbsp;&nbsp;(<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 2)) (<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 7)) <span class="id" title="constructor">nil</span>) <span class="id" title="constructor">tt</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode">(<a class="idref" href="Cpdt.Predicates.html#false"><span class="id" title="constructor">false</span></a>,</span> <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#tt"><span class="id" title="constructor">tt</span></a>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#vstack"><span class="id" title="definition">vstack</span></a></span> <span class="inlinecode">(<a class="idref" href="Cpdt.DataStruct.html#Bool"><span class="id" title="constructor">Bool</span></a></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="constructor">nil</span>)</span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <a class="idref" href="Cpdt.StackMachine.html#tprogDenote"><span class="id" title="definition">tprogDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TBinop"><span class="id" title="constructor">TBinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#TLt"><span class="id" title="constructor">TLt</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TBinop"><span class="id" title="constructor">TBinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#TPlus"><span class="id" title="constructor">TPlus</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 2) (<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 2))<br/>
&nbsp;&nbsp;(<a class="idref" href="Cpdt.StackMachine.html#TNConst"><span class="id" title="constructor">TNConst</span></a> 7)) <span class="id" title="constructor">nil</span>) <span class="id" title="constructor">tt</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode">(<a class="idref" href="Cpdt.Predicates.html#true"><span class="id" title="constructor">true</span></a>,</span> <span class="inlinecode"><a class="idref" href="Cpdt.Predicates.html#tt"><span class="id" title="constructor">tt</span></a>)</span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#vstack"><span class="id" title="definition">vstack</span></a></span> <span class="inlinecode">(<a class="idref" href="Cpdt.DataStruct.html#Bool"><span class="id" title="constructor">Bool</span></a></span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="constructor">nil</span>)</span> 
<div class="paragraph"> </div>

 コンパイラは動いているように見えるので、<span class="inlinecode">常に</span>正しく動くことを証明しましょう。 
<div class="paragraph"> </div>

<a name="lab24"></a><h2 class="section">翻訳の正しさ</h2>

<div class="paragraph"> </div>

  前回と同様な正しさの定理を主張します。 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="tcompile_correct"><span class="id" title="lemma">tcompile_correct</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.StackMachine.html#texp"><span class="id" title="inductive">texp</span></a> <a class="idref" href="Cpdt.StackMachine.html#t"><span class="id" title="variable">t</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#tprogDenote"><span class="id" title="definition">tprogDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="constructor">nil</span>) <span class="id" title="constructor">tt</span> <span class="id" title="notation">=</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.StackMachine.html#texpDenote"><span class="id" title="definition">texpDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a><span class="id" title="notation">,</span> <span class="id" title="constructor">tt</span><span class="id" title="notation">)</span>.<br/>

<br/>
</div>

<div class="doc">
帰納法がうまくいくように定理の主張を強くする必要がまたあります。
今回は別のタクティクを見せるために、以下の補題を使って、このような種類の証明に対する代わりのアプローチを取ります。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="tcompile_correct'"><span class="id" title="lemma">tcompile_correct'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.StackMachine.html#texp"><span class="id" title="inductive">texp</span></a> <a class="idref" href="Cpdt.StackMachine.html#t"><span class="id" title="variable">t</span></a>) <span class="id" title="var">ts</span> (<span class="id" title="var">s</span> : <a class="idref" href="Cpdt.StackMachine.html#vstack"><span class="id" title="definition">vstack</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#tprogDenote"><span class="id" title="definition">tprogDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a>) <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">=</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.StackMachine.html#texpDenote"><span class="id" title="definition">texpDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a><span class="id" title="notation">)</span>.<br/>

<br/>
</div>

<div class="doc">
補題<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#compile_correct'"><span class="id" title="lemma">compile_correct'</span></a></span>は私たちが考えている式の「継続」であるようなプログラム上に量化されていますが、ここではwe avoid drawing in any extra syntactic elements.
ソース言語の式とその方に加えて、初めのスタック型とそれに適合するスタックを量化します。
そのスタックから始まるプログラムのコンパイルをすると、その上にプログラムの表示的意味がプッシュされたスタックを得ます。

<div class="paragraph"> </div>

      前節と同じ方法でこの定理を証明しましょう。
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>; <span class="id" title="var">crush</span>.<br/>

<br/>
</div>

<div class="doc">
次の未証明の結論が残されました。

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tprogDenote"><span class="id" title="definition">tprogDenote</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.StackMachine.html#tconcat"><span class="id" title="definition">tconcat</span></a> (<a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.StackMachine.html#tconcat"><span class="id" title="definition">tconcat</span></a> (<a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a> (<a class="idref" href="Cpdt.StackMachine.html#arg2"><span class="id" title="variable">arg2</span></a> :: <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.StackMachine.html#TCons"><span class="id" title="constructor">TCons</span></a> (<a class="idref" href="Cpdt.StackMachine.html#TiBinop"><span class="id" title="constructor">TiBinop</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> <a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a>) (<a class="idref" href="Cpdt.StackMachine.html#TNil"><span class="id" title="constructor">TNil</span></a> (<a class="idref" href="Cpdt.StackMachine.html#res"><span class="id" title="variable">res</span></a> :: <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a>))))) <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a> =<br/>
&nbsp;&nbsp;&nbsp;(<a class="idref" href="Cpdt.StackMachine.html#tbinopDenote"><span class="id" title="definition">tbinopDenote</span></a> <a class="idref" href="Cpdt.DataStruct.html#cfoldCond.t"><span class="id" title="variable">t</span></a> (<a class="idref" href="Cpdt.StackMachine.html#texpDenote"><span class="id" title="definition">texpDenote</span></a> <a class="idref" href="Cpdt.Subset.html#e1"><span class="id" title="variable">e1</span></a>) (<a class="idref" href="Cpdt.StackMachine.html#texpDenote"><span class="id" title="definition">texpDenote</span></a> <a class="idref" href="Cpdt.Subset.html#e2"><span class="id" title="variable">e2</span></a>), <a class="idref" href="Cpdt.MoreDep.html#dec_star.s"><span class="id" title="variable">s</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

前節でゴールを書き換えるのに使った定理<span class="inlinecode"><span class="id" title="lemma">app_assoc_reverse</span></span>の類似物が必要です。
証明を中止して<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tconcat"><span class="id" title="definition">tconcat</span></a></span>についてのそのような補題を証明します。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="tconcat_correct"><span class="id" title="lemma">tconcat_correct</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">ts</span> <span class="id" title="var">ts'</span> <span class="id" title="var">ts''</span> (<span class="id" title="var">p</span> : <a class="idref" href="Cpdt.StackMachine.html#tprog"><span class="id" title="inductive">tprog</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts'"><span class="id" title="variable">ts'</span></a>) (<span class="id" title="var">p'</span> : <a class="idref" href="Cpdt.StackMachine.html#tprog"><span class="id" title="inductive">tprog</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts'"><span class="id" title="variable">ts'</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts''"><span class="id" title="variable">ts''</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">s</span> : <a class="idref" href="Cpdt.StackMachine.html#vstack"><span class="id" title="definition">vstack</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#tprogDenote"><span class="id" title="definition">tprogDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#tconcat"><span class="id" title="definition">tconcat</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="Cpdt.StackMachine.html#p'"><span class="id" title="variable">p'</span></a>) <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a><br/>
&nbsp;&nbsp;<span class="id" title="notation">=</span> <a class="idref" href="Cpdt.StackMachine.html#tprogDenote"><span class="id" title="definition">tprogDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p'"><span class="id" title="variable">p'</span></a> (<a class="idref" href="Cpdt.StackMachine.html#tprogDenote"><span class="id" title="definition">tprogDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">p</span>; <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

これは完全に自動で証明されます。

<div class="paragraph"> </div>

裏であるコードは<span class="inlinecode"><span class="id" title="lemma">app_assoc_reverse</span></span>を<span class="inlinecode"><span class="id" title="var">crush</span></span>のために登録しています。
同じ効果を得るために、同様に<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tconcat_correct"><span class="id" title="lemma">tconcat_correct</span></a></span>を登録しなければいけません：

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Hint Rewrite</span> <a class="idref" href="Cpdt.StackMachine.html#tconcat_correct"><span class="id" title="lemma">tconcat_correct</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

ここで、<span class="inlinecode">ヒント</span>という有用な概念を学びましょう。
たくさんの証明は可能な証明ステップの組み合わせの徹底的な列挙によって発見されます。
ヒントは考えるべきステップの集合を与えます。
タクティク<span class="inlinecode"><span class="id" title="var">crush</span></span>はそのようなしらみつぶし探索を暗黙で適用し、ヒントに与えた以上の可能性を考えます。
この<span class="inlinecode"><span class="id" title="keyword">Hint</span></span> <span class="inlinecode"><span class="id" title="keyword">Rewrite</span></span> <span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tconcat_correct"><span class="id" title="lemma">tconcat_correct</span></a></span>は補題<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tconcat_correct"><span class="id" title="lemma">tconcat_correct</span></a></span>を左から右への書換に使うようにヒントとして与えています。

<div class="paragraph"> </div>

これで、<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tcompile_correct'"><span class="id" title="lemma">tcompile_correct'</span></a></span>に戻って自動で証明する準備ができました。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="tcompile_correct'"><span class="id" title="lemma">tcompile_correct'</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.StackMachine.html#texp"><span class="id" title="inductive">texp</span></a> <a class="idref" href="Cpdt.StackMachine.html#t"><span class="id" title="variable">t</span></a>) <span class="id" title="var">ts</span> (<span class="id" title="var">s</span> : <a class="idref" href="Cpdt.StackMachine.html#vstack"><span class="id" title="definition">vstack</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#tprogDenote"><span class="id" title="definition">tprogDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="Cpdt.StackMachine.html#ts"><span class="id" title="variable">ts</span></a>) <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a> <span class="id" title="notation">=</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.StackMachine.html#texpDenote"><span class="id" title="definition">texpDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a><span class="id" title="notation">,</span> <a class="idref" href="Cpdt.StackMachine.html#s"><span class="id" title="variable">s</span></a><span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">e</span>; <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

この主補題を新しいヒントとして登録し、最後の定理を自明に証明することができます。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Hint Rewrite</span> <a class="idref" href="Cpdt.StackMachine.html#tcompile_correct'"><span class="id" title="lemma">tcompile_correct'</span></a>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <a name="tcompile_correct"><span class="id" title="lemma">tcompile_correct</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <a class="idref" href="Cpdt.StackMachine.html#texp"><span class="id" title="inductive">texp</span></a> <a class="idref" href="Cpdt.StackMachine.html#t"><span class="id" title="variable">t</span></a>),<br/>
&nbsp;&nbsp;<a class="idref" href="Cpdt.StackMachine.html#tprogDenote"><span class="id" title="definition">tprogDenote</span></a> (<a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a> <span class="id" title="constructor">nil</span>) <span class="id" title="constructor">tt</span> <span class="id" title="notation">=</span> <span class="id" title="notation">(</span><a class="idref" href="Cpdt.StackMachine.html#texpDenote"><span class="id" title="definition">texpDenote</span></a> <a class="idref" href="Cpdt.StackMachine.html#e"><span class="id" title="variable">e</span></a><span class="id" title="notation">,</span> <span class="id" title="constructor">tt</span><span class="id" title="notation">)</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

ここで、私たちは数学的モデルを構築する以上のことをしています。
私たちのコンパイラは効率的に実行できる関数型プログラムです。

<div class="paragraph"> </div>

そのようにする一つの戦略は、CoqコードからOCamlコードを生成する、<span class="inlinecode">プログラム抽出</span>に基きます。
たとえば、OCaml版の<span class="inlinecode"><a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a></span>を出力するためのコマンドを実行しましょう：

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Extraction</span> <a class="idref" href="Cpdt.StackMachine.html#tcompile"><span class="id" title="definition">tcompile</span></a>.<br/>

<br/>
</div>

<div class="doc">
 <tt>
let rec tcompile t e ts =
  match e with
  | TNConst n -&gt;
    TCons (ts, (Cons (Nat, ts)), (Cons (Nat, ts)), (TiNConst (ts, n)), (TNil
      (Cons (Nat, ts))))
  | TBConst b -&gt;
    TCons (ts, (Cons (Bool, ts)), (Cons (Bool, ts)), (TiBConst (ts, b)),
      (TNil (Cons (Bool, ts))))
  | TBinop (t1, t2, t0, b, e1, e2) -&gt;
    tconcat ts (Cons (t2, ts)) (Cons (t0, ts)) (tcompile t2 e2 ts)
      (tconcat (Cons (t2, ts)) (Cons (t1, (Cons (t2, ts)))) (Cons (t0, ts))
        (tcompile t1 e1 (Cons (t2, ts))) (TCons ((Cons (t1, (Cons (t2,
        ts)))), (Cons (t0, ts)), (Cons (t0, ts)), (TiBinop (t1, t2, t0, ts,
        b)), (TNil (Cons (t0, ts))))))
</tt>
<div class="paragraph"> </div>

このコードは普段使うOCamlのコンパイラでコンパイでき、そこそこ良いパフォーマンスの実行可能プログラムが得られます。

<div class="paragraph"> </div>

この章は筆者の提案するCoq開発のスタイルの二つの例を紹介するあわただしい案内でした。
この本の第2部と第3部はこのスタイルの主要素、依存型とscripted proof automationにそれぞれ焦点を当てます。
それらの前に、第1部ではより標準的な基礎的題材について触れます。
第1部の早い段階から強い自動証明のスタイルを取るので、経験抱負なCoqハッカーにも第1部は興味深いかもしれません。

</div>
<div class="code">
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>