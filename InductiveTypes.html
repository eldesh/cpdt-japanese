<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>InductiveTypes</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library InductiveTypes</h1>

<div class="code">

<br/>

<br/>
</div>

<div class="doc">
 
<div class="paragraph"> </div>

 The logical foundation of Coq is the Calculus of Inductive Constructions, or CIC.  In a sense, CIC is built from just two relatively straightforward features: function types and inductive types.  From this modest foundation, we can prove essentially all of the theorems of math and carry out effectively all program verifications, with enough effort expended.  This chapter introduces induction and recursion for functional programming in Coq.  Most of our examples reproduce functionality from the Coq standard library, and I have tried to copy the standard library's choices of identifiers, where possible, so many of the definitions here are already available in the default Coq environment.

<div class="paragraph"> </div>

The last chapter took a deep dive into some of the more advanced Coq features, to highlight the unusual approach that I advocate in this book.  However, from this point on, we will rewind and go back to basics, presenting the relevant features of Coq in a more bottom-up manner.  A useful first step is a discussion of the differences and relationships between proofs and programs in Coq. 
<div class="paragraph"> </div>

<a name="lab43"></a><h1 class="section">Proof Terms</h1>

<div class="paragraph"> </div>

 Mainstream presentations of mathematics treat proofs as objects that exist outside of the universe of mathematical objects.  However, for a variety of reasoning tasks, it is convenient to encode proofs, traditional mathematical objects, and programs within a single formal language.  Validity checks on mathematical objects are useful in any setting, to catch typos and other uninteresting errors.  The benefits of static typing for programs are widely recognized, and Coq brings those benefits to both mathematical objects and programs via a uniform mechanism.  In fact, from this point on, we will not bother to distinguish between programs and mathematical objects.  Many mathematical formalisms are most easily encoded in terms of programs.

<div class="paragraph"> </div>

Proofs are fundamentally different from programs, because any two proofs of a theorem are considered equivalent, from a formal standpoint if not from an engineering standpoint.  However, we can use the same type-checking technology to check proofs as we use to validate our programs.  This is the <i>Curry-Howard correspondence</i> , an approach for relating proofs and programs.  We represent mathematical theorems as types, such that a theorem's proofs are exactly those programs that type-check at the corresponding type.

<div class="paragraph"> </div>

The last chapter's example already snuck in an instance of Curry-Howard.  We used the token <span class="inlinecode">-&gt;</span> to stand for both function types and logical implications.  One reasonable conclusion upon seeing this might be that some fancy overloading of notations is at work.  In fact, functions and implications are precisely identical according to Curry-Howard!  That is, they are just two ways of describing the same computational phenomenon.

<div class="paragraph"> </div>

A short demonstration should explain how this can be.  The identity function over the natural numbers is certainly not a controversial program. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">x</span>).<br/>
</div>

<div class="doc">
<span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="inductive">nat</span></span> 
<div class="paragraph"> </div>

 Consider this alternate program, which is almost identical to the last one. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">True</span> =&gt; <span class="id" title="var">x</span>).<br/>
</div>

<div class="doc">
<span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">True</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="inductive">True</span></span> 
<div class="paragraph"> </div>

 The identity program is interpreted as a proof that <span class="inlinecode"><span class="id" title="inductive">True</span></span>, the always-true proposition, implies itself!  What we see is that Curry-Howard interprets implications as functions, where an input is a proposition being assumed and an output is a proposition being deduced.  This intuition is not too far from a common one for informal theorem proving, where we might already think of an implication proof as a process for transforming a hypothesis into a conclusion.

<div class="paragraph"> </div>

There are also more primitive proof forms available.  For instance, the term <span class="inlinecode"><span class="id" title="constructor">I</span></span> is the single proof of <span class="inlinecode"><span class="id" title="inductive">True</span></span>, applicable in any context. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">I</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">True</span></span> 
<div class="paragraph"> </div>

 With <span class="inlinecode"><span class="id" title="constructor">I</span></span>, we can prove another simple propositional theorem. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> : <span class="id" title="var">False</span> =&gt; <span class="id" title="var">I</span>).<br/>
</div>

<div class="doc">
<span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">False</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="inductive">True</span></span> 
<div class="paragraph"> </div>

 No proofs of <span class="inlinecode"><span class="id" title="inductive">False</span></span> exist in the top-level context, but the implication-as-function analogy gives us an easy way to, for example, show that <span class="inlinecode"><span class="id" title="inductive">False</span></span> implies itself. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">False</span> =&gt; <span class="id" title="var">x</span>).<br/>
</div>

<div class="doc">
<span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">False</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="inductive">False</span></span> 
<div class="paragraph"> </div>

 Every one of these example programs whose type looks like a logical formula is a <i>proof term</i>.  We use that name for any Gallina term of a logical type, and we will elaborate shortly on what makes a type logical.

<div class="paragraph"> </div>

In the rest of this chapter, we will introduce different ways of defining types.  Every example type can be interpreted alternatively as a type of programs or proofs.

<div class="paragraph"> </div>

One of the first types we introduce will be <span class="inlinecode"><span class="id" title="inductive">bool</span></span>, with constructors <span class="inlinecode"><span class="id" title="constructor">true</span></span> and <span class="inlinecode"><span class="id" title="constructor">false</span></span>.  Newcomers to Coq often wonder about the distinction between <span class="inlinecode"><span class="id" title="inductive">True</span></span> and <span class="inlinecode"><span class="id" title="constructor">true</span></span> and the distinction between <span class="inlinecode"><span class="id" title="inductive">False</span></span> and <span class="inlinecode"><span class="id" title="constructor">false</span></span>.  One glib answer is that <span class="inlinecode"><span class="id" title="inductive">True</span></span> and <span class="inlinecode"><span class="id" title="inductive">False</span></span> are types, but <span class="inlinecode"><span class="id" title="constructor">true</span></span> and <span class="inlinecode"><span class="id" title="constructor">false</span></span> are not.  A more useful answer is that Coq's metatheory guarantees that any term of type <span class="inlinecode"><span class="id" title="inductive">bool</span></span> <i>evaluates</i> to either <span class="inlinecode"><span class="id" title="constructor">true</span></span> or <span class="inlinecode"><span class="id" title="constructor">false</span></span>.  This means that we have an <i>algorithm</i> for answering any question phrased as an expression of type <span class="inlinecode"><span class="id" title="inductive">bool</span></span>.  Conversely, most propositions do not evaluate to <span class="inlinecode"><span class="id" title="inductive">True</span></span> or <span class="inlinecode"><span class="id" title="inductive">False</span></span>; the language of inductively defined propositions is much richer than that.  We ought to be glad that we have no algorithm for deciding our formalized version of mathematical truth, since otherwise it would be clear that we could not formalize undecidable properties, like almost any interesting property of general-purpose programs. 
<div class="paragraph"> </div>

<a name="lab44"></a><h1 class="section">Enumerations</h1>

<div class="paragraph"> </div>

 Coq inductive types generalize the algebraic datatypes found in Haskell and ML.  Confusingly enough, inductive types also generalize generalized algebraic datatypes (GADTs), by adding the possibility for type dependency.  Even so, it is worth backing up from the examples of the last chapter and going over basic, algebraic-datatype uses of inductive datatypes, because the chance to prove things about the values of these types adds new wrinkles beyond usual practice in Haskell and ML.

<div class="paragraph"> </div>

The singleton type <span class="inlinecode"><span class="id" title="inductive">unit</span></span> is an inductive type: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">unit</span> : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">tt</span>.<br/>

<br/>
</div>

<div class="doc">
This vernacular command defines a new inductive type <span class="inlinecode"><span class="id" title="inductive">unit</span></span> whose only value is <span class="inlinecode"><span class="id" title="constructor">tt</span></span>.  We can verify the types of the two identifiers we introduce: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">unit</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="inductive">unit</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Set</span></span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">tt</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="constructor">tt</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">unit</span></span> 
<div class="paragraph"> </div>

 We can prove that <span class="inlinecode"><span class="id" title="inductive">unit</span></span> is a genuine singleton type. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">unit_singleton</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">unit</span>, <span class="id" title="var">x</span> = <span class="id" title="var">tt</span>.<br/>

<br/>
</div>

<div class="doc">
The important thing about an inductive type is, unsurprisingly, that you can do induction over its values, and induction is the key to proving this theorem.  We ask to proceed by induction on the variable <span class="inlinecode"><span class="id" title="variable">x</span></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
The goal changes to:
<br/>
<span class="inlinecode">&nbsp;<span class="id" title="constructor">tt</span> = <span class="id" title="constructor">tt</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

 ...which we can discharge trivially. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
It seems kind of odd to write a proof by induction with no inductive hypotheses.  We could have arrived at the same result by beginning the proof with: <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="variable">x</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

...which corresponds to "proof by case analysis" in classical math.  For non-recursive inductive types, the two tactics will always have identical behavior.  Often case analysis is sufficient, even in proofs about recursive types, and it is nice to avoid introducing unneeded induction hypotheses.

<div class="paragraph"> </div>

What exactly <i>is</i> the induction principle for <span class="inlinecode"><span class="id" title="inductive">unit</span></span>?  We can ask Coq: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">unit_ind</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="definition">unit_ind</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="variable">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">unit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>,</span> <span class="inlinecode"><span class="id" title="variable">P</span></span> <span class="inlinecode"><span class="id" title="constructor">tt</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="variable">u</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">unit</span>,</span> <span class="inlinecode"><span class="id" title="variable">P</span></span> <span class="inlinecode"><span class="id" title="variable">u</span></span> 
<div class="paragraph"> </div>

 Every <span class="inlinecode"><span class="id" title="keyword">Inductive</span></span> command defining a type <span class="inlinecode"><span class="id" title="variable">T</span></span> also defines an induction principle named <span class="inlinecode"><span class="id" title="var">T_ind</span></span>.  Recall from the last section that our type, operations over it, and principles for reasoning about it all live in the same language and are described by the same type system.  The key to telling what is a program and what is a proof lies in the distinction between the type <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, which appears in our induction principle; and the type <span class="inlinecode"><span class="id" title="keyword">Set</span></span>, which we have seen a few times already.

<div class="paragraph"> </div>

The convention goes like this: <span class="inlinecode"><span class="id" title="keyword">Set</span></span> is the type of normal types used in programming, and the values of such types are programs.  <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> is the type of logical propositions, and the values of such types are proofs.  Thus, an induction principle has a type that shows us that it is a function for building proofs.

<div class="paragraph"> </div>

Specifically, <span class="inlinecode"><span class="id" title="definition">unit_ind</span></span> quantifies over a predicate <span class="inlinecode"><span class="id" title="variable">P</span></span> over <span class="inlinecode"><span class="id" title="inductive">unit</span></span> values.  If we can present a proof that <span class="inlinecode"><span class="id" title="variable">P</span></span> holds of <span class="inlinecode"><span class="id" title="constructor">tt</span></span>, then we are rewarded with a proof that <span class="inlinecode"><span class="id" title="variable">P</span></span> holds for any value <span class="inlinecode"><span class="id" title="variable">u</span></span> of type <span class="inlinecode"><span class="id" title="inductive">unit</span></span>.  In our last proof, the predicate was <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="variable">u</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">unit</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="variable">u</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="constructor">tt</span>)</span>.

<div class="paragraph"> </div>

The definition of <span class="inlinecode"><span class="id" title="inductive">unit</span></span> places the type in <span class="inlinecode"><span class="id" title="keyword">Set</span></span>.  By replacing <span class="inlinecode"><span class="id" title="keyword">Set</span></span> with <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, <span class="inlinecode"><span class="id" title="inductive">unit</span></span> with <span class="inlinecode"><span class="id" title="inductive">True</span></span>, and <span class="inlinecode"><span class="id" title="constructor">tt</span></span> with <span class="inlinecode"><span class="id" title="constructor">I</span></span>, we arrive at precisely the definition of <span class="inlinecode"><span class="id" title="inductive">True</span></span> that the Coq standard library employs!  The program type <span class="inlinecode"><span class="id" title="inductive">unit</span></span> is the Curry-Howard equivalent of the proposition <span class="inlinecode"><span class="id" title="inductive">True</span></span>.  We might make the tongue-in-cheek claim that, while philosophers have expended much ink on the nature of truth, we have now determined that truth is the <span class="inlinecode"><span class="id" title="inductive">unit</span></span> type of functional programming.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

We can define an inductive type even simpler than <span class="inlinecode"><span class="id" title="inductive">unit</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Empty_set</span> : <span class="id" title="keyword">Set</span> := .<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="inductive">Empty_set</span></span> has no elements.  We can prove fun theorems about it: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">the_sky_is_falling</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">Empty_set</span>, 2 + 2 = 5.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> 1.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Because <span class="inlinecode"><span class="id" title="inductive">Empty_set</span></span> has no elements, the fact of having an element of this type implies anything.  We use <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode">1</span> instead of <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> <span class="inlinecode"><span class="id" title="variable">x</span></span> in the proof because unused quantified variables are relegated to being referred to by number.  (There is a good reason for this, related to the unity of quantifiers and implication.  At least within Coq's logical foundation of constructive logic, which we elaborate on more in the next chapter, an implication is just a quantification over a proof, where the quantified variable is never used.  It generally makes more sense to refer to implication hypotheses by number than by name, and Coq treats our quantifier over an unused variable as an implication in determining the proper behavior.)

<div class="paragraph"> </div>

We can see the induction principle that made this proof so easy: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">Empty_set_ind</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="definition">Empty_set_ind</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="variable">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">Empty_set</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>)</span> <span class="inlinecode">(<span class="id" title="variable">e</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">Empty_set</span>),</span> <span class="inlinecode"><span class="id" title="variable">P</span></span> <span class="inlinecode"><span class="id" title="variable">e</span></span> 
<div class="paragraph"> </div>

 In other words, any predicate over values from the empty set holds vacuously of every such element.  In the last proof, we chose the predicate <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">Empty_set</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">5)</span>.

<div class="paragraph"> </div>

We can also apply this get-out-of-jail-free card programmatically.  Here is a lazy way of converting values of <span class="inlinecode"><span class="id" title="inductive">Empty_set</span></span> to values of <span class="inlinecode"><span class="id" title="inductive">unit</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">e2u</span> (<span class="id" title="var">e</span> : <span class="id" title="var">Empty_set</span>) : <span class="id" title="var">unit</span> := <span class="id" title="keyword">match</span> <span class="id" title="var">e</span> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
We employ <span class="inlinecode"><span class="id" title="keyword">match</span></span> pattern matching as in the last chapter.  Since we match on a value whose type has no constructors, there is no need to provide any branches.  It turns out that <span class="inlinecode"><span class="id" title="inductive">Empty_set</span></span> is the Curry-Howard equivalent of <span class="inlinecode"><span class="id" title="inductive">False</span></span>.  As for why <span class="inlinecode"><span class="id" title="inductive">Empty_set</span></span> starts with a capital letter and not a lowercase letter like <span class="inlinecode"><span class="id" title="inductive">unit</span></span> does, we must refer the reader to the authors of the Coq standard library, to which we try to be faithful.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

Moving up the ladder of complexity, we can define the Booleans: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">bool</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">true</span><br/>
| <span class="id" title="var">false</span>.<br/>

<br/>
</div>

<div class="doc">
We can use less vacuous pattern matching to define Boolean negation. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">negb</span> (<span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">b</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
An alternative definition desugars to the above, thanks to an <span class="inlinecode"><span class="id" title="keyword">if</span></span> notation overloaded to work with any inductive type that has exactly two constructors: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">negb'</span> (<span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">false</span> <span class="id" title="keyword">else</span> <span class="id" title="var">true</span>.<br/>

<br/>
</div>

<div class="doc">
We might want to prove that <span class="inlinecode"><span class="id" title="definition">negb</span></span> is its own inverse operation. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">negb_inverse</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">negb</span> (<span class="id" title="var">negb</span> <span class="id" title="var">b</span>) = <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>.<br/>

<br/>
</div>

<div class="doc">
After we case-analyze on <span class="inlinecode"><span class="id" title="variable">b</span></span>, we are left with one subgoal for each constructor of <span class="inlinecode"><span class="id" title="inductive">bool</span></span>.
<br/>
<span class="inlinecode">&nbsp;&nbsp;2 <span class="id" title="keyword">subgoals</span><br/>
<br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="definition">negb</span> (<span class="id" title="definition">negb</span> <span class="id" title="constructor">true</span>) = <span class="id" title="constructor">true</span><br/>
<br/>
<span class="id" title="keyword">subgoal</span> 2 <span class="id" title="var">is</span><br/>
<br/>
&nbsp;<span class="id" title="definition">negb</span> (<span class="id" title="definition">negb</span> <span class="id" title="constructor">false</span>) = <span class="id" title="constructor">false</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The first subgoal follows by Coq's rules of computation, so we can dispatch it easily: 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>

<br/>
</div>

<div class="doc">
Likewise for the second subgoal, so we can restart the proof and give a very compact justification. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Restart</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Another theorem about Booleans illustrates another useful tactic. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">negb_ineq</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">negb</span> <span class="id" title="var">b</span> &lt;&gt; <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">discriminate</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span> tactic is used to prove that two values of an inductive type are not equal, whenever the values are formed with different constructors.  In this case, the different constructors are <span class="inlinecode"><span class="id" title="constructor">true</span></span> and <span class="inlinecode"><span class="id" title="constructor">false</span></span>.

<div class="paragraph"> </div>

At this point, it is probably not hard to guess what the underlying induction principle for <span class="inlinecode"><span class="id" title="inductive">bool</span></span> is. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">bool_ind</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="definition">bool_ind</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="variable">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">bool</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>,</span> <span class="inlinecode"><span class="id" title="variable">P</span></span> <span class="inlinecode"><span class="id" title="constructor">true</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="variable">P</span></span> <span class="inlinecode"><span class="id" title="constructor">false</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="variable">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">bool</span>,</span> <span class="inlinecode"><span class="id" title="variable">P</span></span> <span class="inlinecode"><span class="id" title="variable">b</span></span> 
<div class="paragraph"> </div>

 That is, to prove that a property describes all <span class="inlinecode"><span class="id" title="inductive">bool</span></span>s, prove that it describes both <span class="inlinecode"><span class="id" title="constructor">true</span></span> and <span class="inlinecode"><span class="id" title="constructor">false</span></span>.

<div class="paragraph"> </div>

There is no interesting Curry-Howard analogue of <span class="inlinecode"><span class="id" title="inductive">bool</span></span>.  Of course, we can define such a type by replacing <span class="inlinecode"><span class="id" title="keyword">Set</span></span> by <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> above, but the proposition we arrive at is not very useful.  It is logically equivalent to <span class="inlinecode"><span class="id" title="inductive">True</span></span>, but it provides two indistinguishable primitive proofs, <span class="inlinecode"><span class="id" title="constructor">true</span></span> and <span class="inlinecode"><span class="id" title="constructor">false</span></span>.   In the rest of the chapter, we will skip commenting on Curry-Howard versions of inductive definitions where such versions are not interesting. 
<div class="paragraph"> </div>

<a name="lab45"></a><h1 class="section">Simple Recursive Types</h1>

<div class="paragraph"> </div>

 The natural numbers are the simplest common example of an inductive type that actually deserves the name. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">nat</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">O</span> : <span class="id" title="var">nat</span><br/>
| <span class="id" title="var">S</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span>.<br/>

<br/>
</div>

<div class="doc">
The constructor <span class="inlinecode"><span class="id" title="constructor">O</span></span> is zero, and <span class="inlinecode"><span class="id" title="variable">S</span></span> is the successor function, so that <span class="inlinecode">0</span> is syntactic sugar for <span class="inlinecode"><span class="id" title="constructor">O</span></span>, <span class="inlinecode">1</span> for <span class="inlinecode"><span class="id" title="variable">S</span></span> <span class="inlinecode"><span class="id" title="constructor">O</span></span>, <span class="inlinecode">2</span> for <span class="inlinecode"><span class="id" title="variable">S</span></span> <span class="inlinecode">(<span class="id" title="variable">S</span></span> <span class="inlinecode"><span class="id" title="constructor">O</span>)</span>, and so on.

<div class="paragraph"> </div>

Pattern matching works as we demonstrated in the last chapter: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">isZero</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pred</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="var">n'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
We can prove theorems by case analysis with <span class="inlinecode"><span class="id" title="tactic">destruct</span></span> as for simpler inductive types, but we can also now get into genuine inductive theorems.  First, we will need a recursive function, to make things interesting. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">plus</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">plus</span> <span class="id" title="var">n'</span> <span class="id" title="var">m</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Recall that <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> is Coq's mechanism for recursive function definitions.  Some theorems about <span class="inlinecode"><span class="id" title="definition">plus</span></span> can be proved without induction. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">O_plus_n</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus</span> <span class="id" title="var">O</span> <span class="id" title="var">n</span> = <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Coq's computation rules automatically simplify the application of <span class="inlinecode"><span class="id" title="definition">plus</span></span>, because unfolding the definition of <span class="inlinecode"><span class="id" title="definition">plus</span></span> gives us a <span class="inlinecode"><span class="id" title="keyword">match</span></span> expression where the branch to be taken is obvious from syntax alone.  If we just reverse the order of the arguments, though, this no longer works, and we need induction. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">n_plus_O</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus</span> <span class="id" title="var">n</span> <span class="id" title="var">O</span> = <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>.<br/>

<br/>
</div>

<div class="doc">
Our first subgoal is <span class="inlinecode"><span class="id" title="definition">plus</span></span> <span class="inlinecode"><span class="id" title="constructor">O</span></span> <span class="inlinecode"><span class="id" title="constructor">O</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="constructor">O</span></span>, which <i>is</i> trivial by computation. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>

<br/>
</div>

<div class="doc">
Our second subgoal requires more work and also demonstrates our first inductive hypothesis.

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span><br/>
&nbsp;&nbsp;<span class="id" title="var">IHn</span> : <span class="id" title="definition">plus</span> <span class="id" title="variable">n</span> <span class="id" title="constructor">O</span> = <span class="id" title="variable">n</span><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="definition">plus</span> (<span class="id" title="variable">S</span> <span class="id" title="variable">n</span>) <span class="id" title="constructor">O</span> = <span class="id" title="variable">S</span> <span class="id" title="variable">n</span><br/>
&nbsp;
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

We can start out by using computation to simplify the goal as far as we can. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>

<br/>
</div>

<div class="doc">
Now the conclusion is <span class="inlinecode"><span class="id" title="variable">S</span></span> <span class="inlinecode">(<span class="id" title="definition">plus</span></span> <span class="inlinecode"><span class="id" title="variable">n</span></span> <span class="inlinecode"><span class="id" title="constructor">O</span>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="variable">S</span></span> <span class="inlinecode"><span class="id" title="variable">n</span></span>.  Using our inductive hypothesis: 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">IHn</span>.<br/>

<br/>
</div>

<div class="doc">
...we get a trivial conclusion <span class="inlinecode"><span class="id" title="variable">S</span></span> <span class="inlinecode"><span class="id" title="variable">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="variable">S</span></span> <span class="inlinecode"><span class="id" title="variable">n</span></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>

<br/>
</div>

<div class="doc">
Not much really went on in this proof, so the <span class="inlinecode"><span class="id" title="var">crush</span></span> tactic from the <span class="inlinecode"><span class="id" title="library">CpdtTactics</span></span> module can prove this theorem automatically. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Restart</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>; <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We can check out the induction principle at work here: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">nat_ind</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="definition">nat_ind</span> : <span class="id" title="keyword">forall</span> <span class="id" title="variable">P</span> : <span class="id" title="inductive">nat</span> -&gt; <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="variable">P</span> <span class="id" title="constructor">O</span> -&gt; (<span class="id" title="keyword">forall</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">n</span> -&gt; <span class="id" title="variable">P</span> (<span class="id" title="variable">S</span> <span class="id" title="variable">n</span>)) -&gt; <span class="id" title="keyword">forall</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">n</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Each of the two cases of our last proof came from the type of one of the arguments to <span class="inlinecode"><span class="id" title="definition">nat_ind</span></span>.  We chose <span class="inlinecode"><span class="id" title="variable">P</span></span> to be <span class="inlinecode">(<span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="variable">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">nat</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="definition">plus</span></span> <span class="inlinecode"><span class="id" title="variable">n</span></span> <span class="inlinecode"><span class="id" title="constructor">O</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="variable">n</span>)</span>.  The first proof case corresponded to <span class="inlinecode"><span class="id" title="variable">P</span></span> <span class="inlinecode"><span class="id" title="constructor">O</span></span> and the second case to <span class="inlinecode">(<span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="variable">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">nat</span>,</span> <span class="inlinecode"><span class="id" title="variable">P</span></span> <span class="inlinecode"><span class="id" title="variable">n</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="variable">P</span></span> <span class="inlinecode">(<span class="id" title="variable">S</span></span> <span class="inlinecode"><span class="id" title="variable">n</span>))</span>.  The free variable <span class="inlinecode"><span class="id" title="variable">n</span></span> and inductive hypothesis <span class="inlinecode"><span class="id" title="var">IHn</span></span> came from the argument types given here.

<div class="paragraph"> </div>

Since <span class="inlinecode"><span class="id" title="inductive">nat</span></span> has a constructor that takes an argument, we may sometimes need to know that that constructor is injective. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">S_inj</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">S</span> <span class="id" title="var">n</span> = <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">n</span> = <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">injection</span> 1; <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" title="tactic">injection</span></span> tactic refers to a premise by number, adding new equalities between the corresponding arguments of equated terms that are formed with the same constructor.  We end up needing to prove <span class="inlinecode"><span class="id" title="variable">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="variable">m</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="variable">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="variable">m</span></span>, so it is unsurprising that a tactic named <span class="inlinecode"><span class="id" title="tactic">trivial</span></span> is able to finish the proof.  This tactic attempts a variety of single proof steps, drawn from a user-specified database that we will later see how to extend.

<div class="paragraph"> </div>

There is also a very useful tactic called <span class="inlinecode"><span class="id" title="tactic">congruence</span></span> that can prove this theorem immediately.  The <span class="inlinecode"><span class="id" title="tactic">congruence</span></span> tactic generalizes <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span> and <span class="inlinecode"><span class="id" title="tactic">injection</span></span>, and it also adds reasoning about the general properties of equality, such as that a function returns equal results on equal arguments.  That is, <span class="inlinecode"><span class="id" title="tactic">congruence</span></span> is a <i>complete decision procedure for the theory of equality and uninterpreted functions</i>, plus some smarts about inductive types.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

We can define a type of lists of natural numbers. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">nat_list</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">NNil</span> : <span class="id" title="var">nat_list</span><br/>
| <span class="id" title="var">NCons</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat_list</span> -&gt; <span class="id" title="var">nat_list</span>.<br/>

<br/>
</div>

<div class="doc">
Recursive definitions over <span class="inlinecode"><span class="id" title="inductive">nat_list</span></span> are straightforward extensions of what we have seen before. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">nlength</span> (<span class="id" title="var">ls</span> : <span class="id" title="var">nat_list</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">NNil</span> =&gt; <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">NCons</span> <span class="id" title="var">_</span> <span class="id" title="var">ls'</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">nlength</span> <span class="id" title="var">ls'</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">napp</span> (<span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span> : <span class="id" title="var">nat_list</span>) : <span class="id" title="var">nat_list</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">NNil</span> =&gt; <span class="id" title="var">ls2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">NCons</span> <span class="id" title="var">n</span> <span class="id" title="var">ls1'</span> =&gt; <span class="id" title="var">NCons</span> <span class="id" title="var">n</span> (<span class="id" title="var">napp</span> <span class="id" title="var">ls1'</span> <span class="id" title="var">ls2</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Inductive theorem proving can again be automated quite effectively. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">nlength_napp</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span> : <span class="id" title="var">nat_list</span>, <span class="id" title="var">nlength</span> (<span class="id" title="var">napp</span> <span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span>)<br/>
&nbsp;&nbsp;= <span class="id" title="var">plus</span> (<span class="id" title="var">nlength</span> <span class="id" title="var">ls1</span>) (<span class="id" title="var">nlength</span> <span class="id" title="var">ls2</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">ls1</span>; <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">nat_list_ind</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="definition">nat_list_ind</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="variable">P</span> : <span class="id" title="inductive">nat_list</span> -&gt; <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="variable">P</span> <span class="id" title="constructor">NNil</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>) (<span class="id" title="variable">n0</span> : <span class="id" title="inductive">nat_list</span>), <span class="id" title="variable">P</span> <span class="id" title="variable">n0</span> -&gt; <span class="id" title="variable">P</span> (<span class="id" title="constructor">NCons</span> <span class="id" title="variable">n</span> <span class="id" title="variable">n0</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat_list</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">n</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>



<div class="paragraph"> </div>

In general, we can implement any "tree" type as an inductive type.  For example, here are binary trees of naturals. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">nat_btree</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">NLeaf</span> : <span class="id" title="var">nat_btree</span><br/>
| <span class="id" title="var">NNode</span> : <span class="id" title="var">nat_btree</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat_btree</span> -&gt; <span class="id" title="var">nat_btree</span>.<br/>

<br/>
</div>

<div class="doc">
Here are two functions whose intuitive explanations are not so important.  The first one computes the size of a tree, and the second performs some sort of splicing of one tree into the leftmost available leaf node of another. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">nsize</span> (<span class="id" title="var">tr</span> : <span class="id" title="var">nat_btree</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">tr</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">NLeaf</span> =&gt; <span class="id" title="var">S</span> <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">NNode</span> <span class="id" title="var">tr1</span> <span class="id" title="var">_</span> <span class="id" title="var">tr2</span> =&gt; <span class="id" title="var">plus</span> (<span class="id" title="var">nsize</span> <span class="id" title="var">tr1</span>) (<span class="id" title="var">nsize</span> <span class="id" title="var">tr2</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">nsplice</span> (<span class="id" title="var">tr1</span> <span class="id" title="var">tr2</span> : <span class="id" title="var">nat_btree</span>) : <span class="id" title="var">nat_btree</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">tr1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">NLeaf</span> =&gt; <span class="id" title="var">NNode</span> <span class="id" title="var">tr2</span> <span class="id" title="var">O</span> <span class="id" title="var">NLeaf</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">NNode</span> <span class="id" title="var">tr1'</span> <span class="id" title="var">n</span> <span class="id" title="var">tr2'</span> =&gt; <span class="id" title="var">NNode</span> (<span class="id" title="var">nsplice</span> <span class="id" title="var">tr1'</span> <span class="id" title="var">tr2</span>) <span class="id" title="var">n</span> <span class="id" title="var">tr2'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_assoc</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span> <span class="id" title="var">n3</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus</span> (<span class="id" title="var">plus</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span>) <span class="id" title="var">n3</span> = <span class="id" title="var">plus</span> <span class="id" title="var">n1</span> (<span class="id" title="var">plus</span> <span class="id" title="var">n2</span> <span class="id" title="var">n3</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n1</span>; <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Hint Rewrite</span> <span class="id" title="var">n_plus_O</span> <span class="id" title="var">plus_assoc</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">nsize_nsplice</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">tr1</span> <span class="id" title="var">tr2</span> : <span class="id" title="var">nat_btree</span>, <span class="id" title="var">nsize</span> (<span class="id" title="var">nsplice</span> <span class="id" title="var">tr1</span> <span class="id" title="var">tr2</span>)<br/>
&nbsp;&nbsp;= <span class="id" title="var">plus</span> (<span class="id" title="var">nsize</span> <span class="id" title="var">tr2</span>) (<span class="id" title="var">nsize</span> <span class="id" title="var">tr1</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">tr1</span>; <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
It is convenient that these proofs go through so easily, but it is still useful to look into the details of what happened, by checking the statement of the tree induction principle. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">nat_btree_ind</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="definition">nat_btree_ind</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="variable">P</span> : <span class="id" title="inductive">nat_btree</span> -&gt; <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="variable">P</span> <span class="id" title="constructor">NLeaf</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat_btree</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="variable">P</span> <span class="id" title="variable">n</span> -&gt; <span class="id" title="keyword">forall</span> (<span class="id" title="variable">n0</span> : <span class="id" title="inductive">nat</span>) (<span class="id" title="variable">n1</span> : <span class="id" title="inductive">nat_btree</span>), <span class="id" title="variable">P</span> <span class="id" title="variable">n1</span> -&gt; <span class="id" title="variable">P</span> (<span class="id" title="constructor">NNode</span> <span class="id" title="variable">n</span> <span class="id" title="variable">n0</span> <span class="id" title="variable">n1</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat_btree</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">n</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

We have the usual two cases, one for each constructor of <span class="inlinecode"><span class="id" title="inductive">nat_btree</span></span>. 
<div class="paragraph"> </div>

<a name="lab46"></a><h1 class="section">Parameterized Types</h1>

<div class="paragraph"> </div>

 We can also define polymorphic inductive types, as with algebraic datatypes in Haskell and ML. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">list</span> (<span class="id" title="var">T</span> : <span class="id" title="keyword">Set</span>) : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">Nil</span> : <span class="id" title="var">list</span> <span class="id" title="var">T</span><br/>
| <span class="id" title="var">Cons</span> : <span class="id" title="var">T</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">T</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">T</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">length</span> <span class="id" title="var">T</span> (<span class="id" title="var">ls</span> : <span class="id" title="var">list</span> <span class="id" title="var">T</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Nil</span> =&gt; <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Cons</span> <span class="id" title="var">_</span> <span class="id" title="var">ls'</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">length</span> <span class="id" title="var">ls'</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">app</span> <span class="id" title="var">T</span> (<span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span> : <span class="id" title="var">list</span> <span class="id" title="var">T</span>) : <span class="id" title="var">list</span> <span class="id" title="var">T</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Nil</span> =&gt; <span class="id" title="var">ls2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Cons</span> <span class="id" title="var">x</span> <span class="id" title="var">ls1'</span> =&gt; <span class="id" title="var">Cons</span> <span class="id" title="var">x</span> (<span class="id" title="var">app</span> <span class="id" title="var">ls1'</span> <span class="id" title="var">ls2</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">length_app</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">T</span> (<span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span> : <span class="id" title="var">list</span> <span class="id" title="var">T</span>), <span class="id" title="var">length</span> (<span class="id" title="var">app</span> <span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span>)<br/>
&nbsp;&nbsp;= <span class="id" title="var">plus</span> (<span class="id" title="var">length</span> <span class="id" title="var">ls1</span>) (<span class="id" title="var">length</span> <span class="id" title="var">ls2</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">ls1</span>; <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
There is a useful shorthand for writing many definitions that share the same parameter, based on Coq's <i>section</i> mechanism.  The following block of code is equivalent to the above: 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">list</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">T</span> : <span class="id" title="keyword">Set</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <span class="id" title="var">list</span> : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">Nil</span> : <span class="id" title="var">list</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">Cons</span> : <span class="id" title="var">T</span> -&gt; <span class="id" title="var">list</span> -&gt; <span class="id" title="var">list</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">length</span> (<span class="id" title="var">ls</span> : <span class="id" title="var">list</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Nil</span> =&gt; <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Cons</span> <span class="id" title="var">_</span> <span class="id" title="var">ls'</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">length</span> <span class="id" title="var">ls'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">app</span> (<span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span> : <span class="id" title="var">list</span>) : <span class="id" title="var">list</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Nil</span> =&gt; <span class="id" title="var">ls2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Cons</span> <span class="id" title="var">x</span> <span class="id" title="var">ls1'</span> =&gt; <span class="id" title="var">Cons</span> <span class="id" title="var">x</span> (<span class="id" title="var">app</span> <span class="id" title="var">ls1'</span> <span class="id" title="var">ls2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <span class="id" title="var">length_app</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span> : <span class="id" title="var">list</span>, <span class="id" title="var">length</span> (<span class="id" title="var">app</span> <span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id" title="var">plus</span> (<span class="id" title="var">length</span> <span class="id" title="var">ls1</span>) (<span class="id" title="var">length</span> <span class="id" title="var">ls2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">ls1</span>; <span class="id" title="var">crush</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">list</span>.<br/>

<br/>
<span class="id" title="keyword">Implicit Arguments</span> <span class="id" title="var">Nil</span> [<span class="id" title="var">T</span>].<br/>

<br/>
</div>

<div class="doc">
After we end the section, the <span class="inlinecode"><span class="id" title="keyword">Variable</span></span>s we used are added as extra function parameters for each defined identifier, as needed.  With an <span class="inlinecode"><span class="id" title="keyword">Implicit</span></span> <span class="inlinecode"><span class="id" title="var">Arguments</span></span> command, we ask that <span class="inlinecode"><span class="id" title="variable">T</span></span> be inferred when we use <span class="inlinecode"><span class="id" title="constructor">Nil</span></span>; Coq's heuristics already decided to apply a similar policy to <span class="inlinecode"><span class="id" title="constructor">Cons</span></span>, because of the <span class="inlinecode"><span class="id" title="keyword">Set</span></span> <span class="inlinecode"><span class="id" title="keyword">Implicit</span></span> <span class="inlinecode"><span class="id" title="var">Arguments</span></span> command elided at the beginning of this chapter.  We verify that our definitions have been saved properly using the <span class="inlinecode"><span class="id" title="keyword">Print</span></span> command, a cousin of <span class="inlinecode"><span class="id" title="keyword">Check</span></span> which shows the definition of a symbol, rather than just its type. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">list</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <span class="id" title="inductive">list</span> (<span class="id" title="variable">T</span> : <span class="id" title="keyword">Set</span>) : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="constructor">Nil</span> : <span class="id" title="inductive">list</span> <span class="id" title="variable">T</span> | <span class="id" title="constructor">Cons</span> : <span class="id" title="variable">T</span> -&gt; <span class="id" title="inductive">list</span> <span class="id" title="variable">T</span> -&gt; <span class="id" title="inductive">list</span> <span class="id" title="variable">T</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The final definition is the same as what we wrote manually before.  The other elements of the section are altered similarly, turning out exactly as they were before, though we managed to write their definitions more succinctly. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">length</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="definition">length</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="variable">T</span> : <span class="id" title="keyword">Set</span>, <span class="id" title="inductive">list</span> <span class="id" title="variable">T</span> -&gt; <span class="id" title="inductive">nat</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The parameter <span class="inlinecode"><span class="id" title="variable">T</span></span> is treated as a new argument to the induction principle, too. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">list_ind</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="definition">list_ind</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> (<span class="id" title="variable">T</span> : <span class="id" title="keyword">Set</span>) (<span class="id" title="variable">P</span> : <span class="id" title="inductive">list</span> <span class="id" title="variable">T</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="variable">P</span> (<span class="id" title="constructor">Nil</span> <span class="id" title="variable">T</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="variable">t</span> : <span class="id" title="variable">T</span>) (<span class="id" title="variable">l</span> : <span class="id" title="inductive">list</span> <span class="id" title="variable">T</span>), <span class="id" title="variable">P</span> <span class="id" title="variable">l</span> -&gt; <span class="id" title="variable">P</span> (<span class="id" title="constructor">Cons</span> <span class="id" title="variable">t</span> <span class="id" title="variable">l</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="variable">l</span> : <span class="id" title="inductive">list</span> <span class="id" title="variable">T</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">l</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Thus, despite a very real sense in which the type <span class="inlinecode"><span class="id" title="variable">T</span></span> is an argument to the constructor <span class="inlinecode"><span class="id" title="constructor">Cons</span></span>, the inductive case in the type of <span class="inlinecode"><span class="id" title="definition">list_ind</span></span> (i.e., the third line of the type) includes no quantifier for <span class="inlinecode"><span class="id" title="variable">T</span></span>, even though all of the other arguments are quantified explicitly.  Parameters in other inductive definitions are treated similarly in stating induction principles. 
<div class="paragraph"> </div>

<a name="lab47"></a><h1 class="section">Mutually Inductive Types</h1>

<div class="paragraph"> </div>

 We can define inductive types that refer to each other: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">even_list</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">ENil</span> : <span class="id" title="var">even_list</span><br/>
| <span class="id" title="var">ECons</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">odd_list</span> -&gt; <span class="id" title="var">even_list</span><br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">odd_list</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">OCons</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">even_list</span> -&gt; <span class="id" title="var">odd_list</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">elength</span> (<span class="id" title="var">el</span> : <span class="id" title="var">even_list</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">el</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">ENil</span> =&gt; <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">ECons</span> <span class="id" title="var">_</span> <span class="id" title="var">ol</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">olength</span> <span class="id" title="var">ol</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">olength</span> (<span class="id" title="var">ol</span> : <span class="id" title="var">odd_list</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ol</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">OCons</span> <span class="id" title="var">_</span> <span class="id" title="var">el</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">elength</span> <span class="id" title="var">el</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">eapp</span> (<span class="id" title="var">el1</span> <span class="id" title="var">el2</span> : <span class="id" title="var">even_list</span>) : <span class="id" title="var">even_list</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">el1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">ENil</span> =&gt; <span class="id" title="var">el2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">ECons</span> <span class="id" title="var">n</span> <span class="id" title="var">ol</span> =&gt; <span class="id" title="var">ECons</span> <span class="id" title="var">n</span> (<span class="id" title="var">oapp</span> <span class="id" title="var">ol</span> <span class="id" title="var">el2</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
<br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">oapp</span> (<span class="id" title="var">ol</span> : <span class="id" title="var">odd_list</span>) (<span class="id" title="var">el</span> : <span class="id" title="var">even_list</span>) : <span class="id" title="var">odd_list</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ol</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">OCons</span> <span class="id" title="var">n</span> <span class="id" title="var">el'</span> =&gt; <span class="id" title="var">OCons</span> <span class="id" title="var">n</span> (<span class="id" title="var">eapp</span> <span class="id" title="var">el'</span> <span class="id" title="var">el</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Everything is going roughly the same as in past examples, until we try to prove a theorem similar to those that came before. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">elength_eapp</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">el1</span> <span class="id" title="var">el2</span> : <span class="id" title="var">even_list</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">elength</span> (<span class="id" title="var">eapp</span> <span class="id" title="var">el1</span> <span class="id" title="var">el2</span>) = <span class="id" title="var">plus</span> (<span class="id" title="var">elength</span> <span class="id" title="var">el1</span>) (<span class="id" title="var">elength</span> <span class="id" title="var">el2</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">el1</span>; <span class="id" title="var">crush</span>.<br/>

<br/>
</div>

<div class="doc">
One goal remains: <br/>
<span class="inlinecode"><br/>
&nbsp;&nbsp;<span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span><br/>
&nbsp;&nbsp;<span class="id" title="variable">o</span> : <span class="id" title="inductive">odd_list</span><br/>
&nbsp;&nbsp;<span class="id" title="variable">el2</span> : <span class="id" title="inductive">even_list</span><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="variable">S</span> (<span class="id" title="definition">olength</span> (<span class="id" title="definition">oapp</span> <span class="id" title="variable">o</span> <span class="id" title="variable">el2</span>)) = <span class="id" title="variable">S</span> (<span class="id" title="definition">plus</span> (<span class="id" title="definition">olength</span> <span class="id" title="variable">o</span>) (<span class="id" title="definition">elength</span> <span class="id" title="variable">el2</span>))
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

   We have no induction hypothesis, so we cannot prove this goal without starting another induction, which would reach a similar point, sending us into a futile infinite chain of inductions.  The problem is that Coq's generation of <span class="inlinecode"><span class="id" title="var">T_ind</span></span> principles is incomplete.  We only get non-mutual induction principles generated by default. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Abort</span>.<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">even_list_ind</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="definition">even_list_ind</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="variable">P</span> : <span class="id" title="inductive">even_list</span> -&gt; <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="variable">P</span> <span class="id" title="constructor">ENil</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>) (<span class="id" title="variable">o</span> : <span class="id" title="inductive">odd_list</span>), <span class="id" title="variable">P</span> (<span class="id" title="constructor">ECons</span> <span class="id" title="variable">n</span> <span class="id" title="variable">o</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="variable">e</span> : <span class="id" title="inductive">even_list</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">e</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

We see that no inductive hypotheses are included anywhere in the type.  To get them, we must ask for mutual principles as we need them, using the <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span> command. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">even_list_mut</span> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">even_list</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Prop</span><br/>
<span class="id" title="keyword">with</span> <span class="id" title="var">odd_list_mut</span> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">odd_list</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Prop</span>.<br/>

<br/>
</div>

<div class="doc">
This invocation of <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span> asks for the creation of induction principles <span class="inlinecode"><span class="id" title="definition">even_list_mut</span></span> for the type <span class="inlinecode"><span class="id" title="inductive">even_list</span></span> and <span class="inlinecode"><span class="id" title="definition">odd_list_mut</span></span> for the type <span class="inlinecode"><span class="id" title="inductive">odd_list</span></span>.  The <span class="inlinecode"><span class="id" title="keyword">Induction</span></span> keyword says we want standard induction schemes, since <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span> supports more exotic choices.  Finally, <span class="inlinecode"><span class="id" title="keyword">Sort</span></span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> establishes that we really want induction schemes, not recursion schemes, which are the same according to Curry-Howard, save for the <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>/<span class="inlinecode"><span class="id" title="keyword">Set</span></span> distinction. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">even_list_mut</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="definition">even_list_mut</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> (<span class="id" title="variable">P</span> : <span class="id" title="inductive">even_list</span> -&gt; <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">P0</span> : <span class="id" title="inductive">odd_list</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="variable">P</span> <span class="id" title="constructor">ENil</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>) (<span class="id" title="variable">o</span> : <span class="id" title="inductive">odd_list</span>), <span class="id" title="var">P0</span> <span class="id" title="variable">o</span> -&gt; <span class="id" title="variable">P</span> (<span class="id" title="constructor">ECons</span> <span class="id" title="variable">n</span> <span class="id" title="variable">o</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>) (<span class="id" title="variable">e</span> : <span class="id" title="inductive">even_list</span>), <span class="id" title="variable">P</span> <span class="id" title="variable">e</span> -&gt; <span class="id" title="var">P0</span> (<span class="id" title="constructor">OCons</span> <span class="id" title="variable">n</span> <span class="id" title="variable">e</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="variable">e</span> : <span class="id" title="inductive">even_list</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">e</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

This is the principle we wanted in the first place.

<div class="paragraph"> </div>

The <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span> command is for asking Coq to generate particular induction schemes that are mutual among a set of inductive types (possibly only one such type, in which case we get a normal induction principle).  In a sense, it generalizes the induction scheme generation that goes on automatically for each inductive definition.  Future Coq versions might make that automatic generation smarter, so that <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span> is needed in fewer places.  In a few sections, we will see how induction principles are derived theorems in Coq, so that there is not actually any need to build in <i>any</i> automatic scheme generation.

<div class="paragraph"> </div>

There is one more wrinkle left in using the <span class="inlinecode"><span class="id" title="definition">even_list_mut</span></span> induction principle: the <span class="inlinecode"><span class="id" title="tactic">induction</span></span> tactic will not apply it for us automatically.  It will be helpful to look at how to prove one of our past examples without using <span class="inlinecode"><span class="id" title="tactic">induction</span></span>, so that we can then generalize the technique to mutual inductive types. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">n_plus_O'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">plus</span> <span class="id" title="var">n</span> <span class="id" title="var">O</span> = <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">nat_ind</span>.<br/>
</div>

<div class="doc">
Here we use <span class="inlinecode"><span class="id" title="tactic">apply</span></span>, which is one of the most essential basic tactics.  When we are trying to prove fact <span class="inlinecode"><span class="id" title="variable">P</span></span>, and when <span class="inlinecode"><span class="id" title="var">thm</span></span> is a theorem whose conclusion can be made to match <span class="inlinecode"><span class="id" title="variable">P</span></span> by proper choice of quantified variable values, the invocation <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">thm</span></span> will replace the current goal with one new goal for each premise of <span class="inlinecode"><span class="id" title="var">thm</span></span>.

<div class="paragraph"> </div>

     This use of <span class="inlinecode"><span class="id" title="tactic">apply</span></span> may seem a bit <i>too</i> magical.  To better see what is going on, we use a variant where we partially apply the theorem <span class="inlinecode"><span class="id" title="definition">nat_ind</span></span> to give an explicit value for the predicate that gives our induction hypothesis. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Undo</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">nat_ind</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> =&gt; <span class="id" title="var">plus</span> <span class="id" title="var">n</span> <span class="id" title="var">O</span> = <span class="id" title="var">n</span>)); <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
From this example, we can see that <span class="inlinecode"><span class="id" title="tactic">induction</span></span> is not magic.  It only does some bookkeeping for us to make it easy to apply a theorem, which we can do directly with the <span class="inlinecode"><span class="id" title="tactic">apply</span></span> tactic.

<div class="paragraph"> </div>

This technique generalizes to our mutual example: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">elength_eapp</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">el1</span> <span class="id" title="var">el2</span> : <span class="id" title="var">even_list</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">elength</span> (<span class="id" title="var">eapp</span> <span class="id" title="var">el1</span> <span class="id" title="var">el2</span>) = <span class="id" title="var">plus</span> (<span class="id" title="var">elength</span> <span class="id" title="var">el1</span>) (<span class="id" title="var">elength</span> <span class="id" title="var">el2</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">even_list_mut</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">el1</span> : <span class="id" title="var">even_list</span> =&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">el2</span> : <span class="id" title="var">even_list</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">elength</span> (<span class="id" title="var">eapp</span> <span class="id" title="var">el1</span> <span class="id" title="var">el2</span>) = <span class="id" title="var">plus</span> (<span class="id" title="var">elength</span> <span class="id" title="var">el1</span>) (<span class="id" title="var">elength</span> <span class="id" title="var">el2</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">ol</span> : <span class="id" title="var">odd_list</span> =&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">el</span> : <span class="id" title="var">even_list</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">olength</span> (<span class="id" title="var">oapp</span> <span class="id" title="var">ol</span> <span class="id" title="var">el</span>) = <span class="id" title="var">plus</span> (<span class="id" title="var">olength</span> <span class="id" title="var">ol</span>) (<span class="id" title="var">elength</span> <span class="id" title="var">el</span>))); <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We simply need to specify two predicates, one for each of the mutually inductive types.  In general, it is not a good idea to assume that a proof assistant can infer extra predicates, so this way of applying mutual induction is about as straightforward as we may hope for. 
<div class="paragraph"> </div>

<a name="lab48"></a><h1 class="section">Reflexive Types</h1>

<div class="paragraph"> </div>

 A kind of inductive type called a <i>reflexive type</i> includes at least one constructor that takes as an argument <i>a function returning the same type we are defining</i>.  One very useful class of examples is in modeling variable binders.  Our example will be an encoding of the syntax of first-order logic.  Since the idea of syntactic encodings of logic may require a bit of acclimation, let us first consider a simpler formula type for a subset of propositional logic.  We are not yet using a reflexive type, but later we will extend the example reflexively. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">pformula</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">Truth</span> : <span class="id" title="var">pformula</span><br/>
| <span class="id" title="var">Falsehood</span> : <span class="id" title="var">pformula</span><br/>
| <span class="id" title="var">Conjunction</span> : <span class="id" title="var">pformula</span> -&gt; <span class="id" title="var">pformula</span> -&gt; <span class="id" title="var">pformula</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
A key distinction here is between, for instance, the <i>syntax</i> <span class="inlinecode"><span class="id" title="constructor">Truth</span></span> and its <i>semantics</i> <span class="inlinecode"><span class="id" title="inductive">True</span></span>.  We can make the semantics explicit with a recursive function.  This function uses the infix operator <span class="inlinecode">/\</span>, which desugars to instances of the type family <span class="inlinecode"><span class="id" title="inductive">and</span></span> from the standard library.  The family <span class="inlinecode"><span class="id" title="inductive">and</span></span> implements conjunction, the <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> Curry-Howard analogue of the usual pair type from functional programming (which is the type family <span class="inlinecode"><span class="id" title="inductive">prod</span></span> in Coq's standard library). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">pformulaDenote</span> (<span class="id" title="var">f</span> : <span class="id" title="var">pformula</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">f</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Truth</span> =&gt; <span class="id" title="var">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Falsehood</span> =&gt; <span class="id" title="var">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Conjunction</span> <span class="id" title="var">f1</span> <span class="id" title="var">f2</span> =&gt; <span class="id" title="var">pformulaDenote</span> <span class="id" title="var">f1</span> /\ <span class="id" title="var">pformulaDenote</span> <span class="id" title="var">f2</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
This is just a warm-up that does not use reflexive types, the new feature we mean to introduce.  When we set our sights on first-order logic instead, it becomes very handy to give constructors recursive arguments that are functions. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">formula</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">Eq</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">formula</span><br/>
| <span class="id" title="var">And</span> : <span class="id" title="var">formula</span> -&gt; <span class="id" title="var">formula</span> -&gt; <span class="id" title="var">formula</span><br/>
| <span class="id" title="var">Forall</span> : (<span class="id" title="var">nat</span> -&gt; <span class="id" title="var">formula</span>) -&gt; <span class="id" title="var">formula</span>.<br/>

<br/>
</div>

<div class="doc">
Our kinds of formulas are equalities between naturals, conjunction, and universal quantification over natural numbers.  We avoid needing to include a notion of "variables" in our type, by using Coq functions to encode the syntax of quantification.  For instance, here is the encoding of <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="variable">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="inductive">nat</span>,</span> <span class="inlinecode"><span class="id" title="variable">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="variable">x</span></span>: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Example</span> <span class="id" title="var">forall_refl</span> : <span class="id" title="var">formula</span> := <span class="id" title="var">Forall</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">Eq</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>).<br/>

<br/>
</div>

<div class="doc">
We can write recursive functions over reflexive types quite naturally.  Here is one translating our formulas into native Coq propositions. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">formulaDenote</span> (<span class="id" title="var">f</span> : <span class="id" title="var">formula</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">f</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Eq</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span> =&gt; <span class="id" title="var">n1</span> = <span class="id" title="var">n2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">And</span> <span class="id" title="var">f1</span> <span class="id" title="var">f2</span> =&gt; <span class="id" title="var">formulaDenote</span> <span class="id" title="var">f1</span> /\ <span class="id" title="var">formulaDenote</span> <span class="id" title="var">f2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Forall</span> <span class="id" title="var">f'</span> =&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">formulaDenote</span> (<span class="id" title="var">f'</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
We can also encode a trivial formula transformation that swaps the order of equality and conjunction operands. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">swapper</span> (<span class="id" title="var">f</span> : <span class="id" title="var">formula</span>) : <span class="id" title="var">formula</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">f</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Eq</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span> =&gt; <span class="id" title="var">Eq</span> <span class="id" title="var">n2</span> <span class="id" title="var">n1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">And</span> <span class="id" title="var">f1</span> <span class="id" title="var">f2</span> =&gt; <span class="id" title="var">And</span> (<span class="id" title="var">swapper</span> <span class="id" title="var">f2</span>) (<span class="id" title="var">swapper</span> <span class="id" title="var">f1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Forall</span> <span class="id" title="var">f'</span> =&gt; <span class="id" title="var">Forall</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> =&gt; <span class="id" title="var">swapper</span> (<span class="id" title="var">f'</span> <span class="id" title="var">n</span>))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
It is helpful to prove that this transformation does not make true formulas false. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">swapper_preserves_truth</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">f</span>, <span class="id" title="var">formulaDenote</span> <span class="id" title="var">f</span> -&gt; <span class="id" title="var">formulaDenote</span> (<span class="id" title="var">swapper</span> <span class="id" title="var">f</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">f</span>; <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We can take a look at the induction principle behind this proof. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">formula_ind</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="definition">formula_ind</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="variable">P</span> : <span class="id" title="inductive">formula</span> -&gt; <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="variable">n</span> <span class="id" title="variable">n0</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="variable">P</span> (<span class="id" title="constructor">Eq</span> <span class="id" title="variable">n</span> <span class="id" title="variable">n0</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">f0</span> : <span class="id" title="inductive">formula</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="variable">P</span> <span class="id" title="var">f0</span> -&gt; <span class="id" title="keyword">forall</span> <span class="id" title="variable">f1</span> : <span class="id" title="inductive">formula</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">f1</span> -&gt; <span class="id" title="variable">P</span> (<span class="id" title="constructor">And</span> <span class="id" title="var">f0</span> <span class="id" title="variable">f1</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="variable">f1</span> : <span class="id" title="inductive">nat</span> -&gt; <span class="id" title="inductive">formula</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="variable">P</span> (<span class="id" title="variable">f1</span> <span class="id" title="variable">n</span>)) -&gt; <span class="id" title="variable">P</span> (<span class="id" title="constructor">Forall</span> <span class="id" title="variable">f1</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="variable">f2</span> : <span class="id" title="inductive">formula</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">f2</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Focusing on the <span class="inlinecode"><span class="id" title="constructor">Forall</span></span> case, which comes third, we see that we are allowed to assume that the theorem holds <i>for any application of the argument function <span class="inlinecode"><span class="id" title="variable">f1</span></span></i>.  That is, Coq induction principles do not follow a simple rule that the textual representations of induction variables must get shorter in appeals to induction hypotheses.  Luckily for us, the people behind the metatheory of Coq have verified that this flexibility does not introduce unsoundness.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

Up to this point, we have seen how to encode in Coq more and more of what is possible with algebraic datatypes in Haskell and ML.  This may have given the inaccurate impression that inductive types are a strict extension of algebraic datatypes.  In fact, Coq must rule out some types allowed by Haskell and ML, for reasons of soundness.  Reflexive types provide our first good example of such a case; only some of them are legal.

<div class="paragraph"> </div>

Given our last example of an inductive type, many readers are probably eager to try encoding the syntax of lambda calculus.  Indeed, the function-based representation technique that we just used, called <i>higher-order abstract syntax</i> (HOAS), is the representation of choice for lambda calculi in Twelf and in many applications implemented in Haskell and ML.  Let us try to import that choice to Coq: 
</div>
<div class="code">
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="keyword">Inductive</span> <span class="id" title="inductive">term</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="constructor">App</span> : <span class="id" title="inductive">term</span> -&gt; <span class="id" title="inductive">term</span> -&gt; <span class="id" title="inductive">term</span><br/>
| <span class="id" title="constructor">Abs</span> : (<span class="id" title="inductive">term</span> -&gt; <span class="id" title="inductive">term</span>) -&gt; <span class="id" title="inductive">term</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
Error: Non strictly positive occurrence of "term" in "(term -&gt; term) -&gt; term"
</pre>

<div class="paragraph"> </div>

We have run afoul of the <i>strict positivity requirement</i> for inductive definitions, which says that the type being defined may not occur to the left of an arrow in the type of a constructor argument.  It is important that the type of a constructor is viewed in terms of a series of arguments and a result, since obviously we need recursive occurrences to the lefts of the outermost arrows if we are to have recursive occurrences at all.  Our candidate definition above violates the positivity requirement because it involves an argument of type <span class="inlinecode"><span class="id" title="inductive">term</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="inductive">term</span></span>, where the type <span class="inlinecode"><span class="id" title="inductive">term</span></span> that we are defining appears to the left of an arrow.  The candidate type of <span class="inlinecode"><span class="id" title="constructor">App</span></span> is fine, however, since every occurrence of <span class="inlinecode"><span class="id" title="inductive">term</span></span> is either a constructor argument or the final result type.

<div class="paragraph"> </div>

Why must Coq enforce this restriction?  Imagine that our last definition had been accepted, allowing us to write this function:

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Definition</span> <span class="id" title="lemma">uhoh</span> (<span class="id" title="variable">t</span> : <span class="id" title="inductive">term</span>) : <span class="id" title="inductive">term</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="variable">t</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">Abs</span> <span class="id" title="variable">f</span> =&gt; <span class="id" title="variable">f</span> <span class="id" title="variable">t</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="variable">t</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Using an informal idea of Coq's semantics, it is easy to verify that the application <span class="inlinecode"><span class="id" title="lemma">uhoh</span></span> <span class="inlinecode">(<span class="id" title="constructor">Abs</span></span> <span class="inlinecode"><span class="id" title="lemma">uhoh</span>)</span> will run forever.  This would be a mere curiosity in OCaml and Haskell, where non-termination is commonplace, though the fact that we have a non-terminating program without explicit recursive function definitions is unusual.

<div class="paragraph"> </div>

For Coq, however, this would be a disaster.  The possibility of writing such a function would destroy all our confidence that proving a theorem means anything.  Since Coq combines programs and proofs in one language, we would be able to prove every theorem with an infinite loop.

<div class="paragraph"> </div>

Nonetheless, the basic insight of HOAS is a very useful one, and there are ways to realize most benefits of HOAS in Coq.  We will study a particular technique of this kind in the final chapter, on programming language syntax and semantics. 
<div class="paragraph"> </div>

<a name="lab49"></a><h1 class="section">An Interlude on Induction Principles</h1>

<div class="paragraph"> </div>

 As we have emphasized a few times already, Coq proofs are actually programs, written in the same language we have been using in our examples all along.  We can get a first sense of what this means by taking a look at the definitions of some of the induction principles we have used.  A close look at the details here will help us construct induction principles manually, which we will see is necessary for some more advanced inductive definitions. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">nat_ind</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="definition">nat_ind</span> = <br/>
<span class="id" title="keyword">fun</span> <span class="id" title="variable">P</span> : <span class="id" title="inductive">nat</span> -&gt; <span class="id" title="keyword">Prop</span> =&gt; <span class="id" title="definition">nat_rect</span> <span class="id" title="variable">P</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="variable">P</span> : <span class="id" title="inductive">nat</span> -&gt; <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="variable">P</span> <span class="id" title="constructor">O</span> -&gt; (<span class="id" title="keyword">forall</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">n</span> -&gt; <span class="id" title="variable">P</span> (<span class="id" title="variable">S</span> <span class="id" title="variable">n</span>)) -&gt; <span class="id" title="keyword">forall</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">n</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

We see that this induction principle is defined in terms of a more general principle, <span class="inlinecode"><span class="id" title="definition">nat_rect</span></span>.  The <tt>rec</tt> stands for "recursion principle," and the <tt>t</tt> at the end stands for <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">nat_rect</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="definition">nat_rect</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="variable">P</span> : <span class="id" title="inductive">nat</span> -&gt; <span class="id" title="keyword">Type</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="variable">P</span> <span class="id" title="constructor">O</span> -&gt; (<span class="id" title="keyword">forall</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">n</span> -&gt; <span class="id" title="variable">P</span> (<span class="id" title="variable">S</span> <span class="id" title="variable">n</span>)) -&gt; <span class="id" title="keyword">forall</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">n</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The principle <span class="inlinecode"><span class="id" title="definition">nat_rect</span></span> gives <span class="inlinecode"><span class="id" title="variable">P</span></span> type <span class="inlinecode"><span class="id" title="inductive">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span> instead of <span class="inlinecode"><span class="id" title="inductive">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.  This <span class="inlinecode"><span class="id" title="keyword">Type</span></span> is another universe, like <span class="inlinecode"><span class="id" title="keyword">Set</span></span> and <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.  In fact, it is a common supertype of both.  Later on, we will discuss exactly what the significances of the different universes are.  For now, it is just important that we can use <span class="inlinecode"><span class="id" title="keyword">Type</span></span> as a sort of meta-universe that may turn out to be either <span class="inlinecode"><span class="id" title="keyword">Set</span></span> or <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.  We can see the symmetry inherent in the subtyping relationship by printing the definition of another principle that was generated for <span class="inlinecode"><span class="id" title="inductive">nat</span></span> automatically: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">nat_rec</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="definition">nat_rec</span> = <br/>
<span class="id" title="keyword">fun</span> <span class="id" title="variable">P</span> : <span class="id" title="inductive">nat</span> -&gt; <span class="id" title="keyword">Set</span> =&gt; <span class="id" title="definition">nat_rect</span> <span class="id" title="variable">P</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="variable">P</span> : <span class="id" title="inductive">nat</span> -&gt; <span class="id" title="keyword">Set</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="variable">P</span> <span class="id" title="constructor">O</span> -&gt; (<span class="id" title="keyword">forall</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">n</span> -&gt; <span class="id" title="variable">P</span> (<span class="id" title="variable">S</span> <span class="id" title="variable">n</span>)) -&gt; <span class="id" title="keyword">forall</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">n</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

This is identical to the definition for <span class="inlinecode"><span class="id" title="definition">nat_ind</span></span>, except that we have substituted <span class="inlinecode"><span class="id" title="keyword">Set</span></span> for <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.  For most inductive types <span class="inlinecode"><span class="id" title="variable">T</span></span>, then, we get not just induction principles <span class="inlinecode"><span class="id" title="var">T_ind</span></span>, but also recursion principles <span class="inlinecode"><span class="id" title="var">T_rec</span></span>.  We can use <span class="inlinecode"><span class="id" title="var">T_rec</span></span> to write recursive definitions without explicit <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span> recursion.  For instance, the following two definitions are equivalent: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">plus_recursive</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">m</span> =&gt; <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">m</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">plus_recursive</span> <span class="id" title="var">n'</span> <span class="id" title="var">m</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">plus_rec</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">nat_rec</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">m</span> =&gt; <span class="id" title="var">m</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">r</span> <span class="id" title="var">m</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">r</span> <span class="id" title="var">m</span>)).<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_equivalent</span> : <span class="id" title="var">plus_recursive</span> = <span class="id" title="var">plus_rec</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Going even further down the rabbit hole, <span class="inlinecode"><span class="id" title="definition">nat_rect</span></span> itself is not even a primitive.  It is a functional program that we can write manually. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">nat_rect</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="definition">nat_rect</span> = <br/>
<span class="id" title="keyword">fun</span> (<span class="id" title="variable">P</span> : <span class="id" title="inductive">nat</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="variable">f</span> : <span class="id" title="variable">P</span> <span class="id" title="constructor">O</span>) (<span class="id" title="var">f0</span> : <span class="id" title="keyword">forall</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">n</span> -&gt; <span class="id" title="variable">P</span> (<span class="id" title="variable">S</span> <span class="id" title="variable">n</span>)) =&gt;<br/>
<span class="id" title="keyword">fix</span> <span class="id" title="variable">F</span> (<span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>) : <span class="id" title="variable">P</span> <span class="id" title="variable">n</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="variable">n</span> <span class="id" title="keyword">as</span> <span class="id" title="variable">n0</span> <span class="id" title="keyword">return</span> (<span class="id" title="variable">P</span> <span class="id" title="variable">n0</span>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="constructor">O</span> =&gt; <span class="id" title="variable">f</span><br/>
&nbsp;&nbsp;| <span class="id" title="variable">S</span> <span class="id" title="variable">n0</span> =&gt; <span class="id" title="var">f0</span> <span class="id" title="variable">n0</span> (<span class="id" title="variable">F</span> <span class="id" title="variable">n0</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="variable">P</span> : <span class="id" title="inductive">nat</span> -&gt; <span class="id" title="keyword">Type</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="variable">P</span> <span class="id" title="constructor">O</span> -&gt; (<span class="id" title="keyword">forall</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">n</span> -&gt; <span class="id" title="variable">P</span> (<span class="id" title="variable">S</span> <span class="id" title="variable">n</span>)) -&gt; <span class="id" title="keyword">forall</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">n</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The only new wrinkles here are, first, an anonymous recursive function definition, using the <span class="inlinecode"><span class="id" title="keyword">fix</span></span> keyword of Gallina (which is like <span class="inlinecode"><span class="id" title="keyword">fun</span></span> with recursion supported); and, second, the annotations on the <span class="inlinecode"><span class="id" title="keyword">match</span></span> expression.  This is a <i>dependently typed</i> pattern match, because the <i>type</i> of the expression depends on the <i>value</i> being matched on.  We will meet more involved examples later, especially in Part II of the book.

<div class="paragraph"> </div>

Type inference for dependent pattern matching is undecidable, which can be proved by reduction from higher-order unification.  Thus, we often find ourselves needing to annotate our programs in a way that explains dependencies to the type checker.  In the example of <span class="inlinecode"><span class="id" title="definition">nat_rect</span></span>, we have an <span class="inlinecode"><span class="id" title="keyword">as</span></span> clause, which binds a name for the discriminee; and a <span class="inlinecode"><span class="id" title="keyword">return</span></span> clause, which gives a way to compute the <span class="inlinecode"><span class="id" title="keyword">match</span></span> result type as a function of the discriminee.

<div class="paragraph"> </div>

To prove that <span class="inlinecode"><span class="id" title="definition">nat_rect</span></span> is nothing special, we can reimplement it manually. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">nat_rect'</span> (<span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Type</span>) <br/>
&nbsp;&nbsp;(<span class="id" title="var">HO</span> : <span class="id" title="var">P</span> <span class="id" title="var">O</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">HS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">return</span> <span class="id" title="var">P</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="var">HO</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="var">HS</span> <span class="id" title="var">n'</span> (<span class="id" title="var">nat_rect'</span> <span class="id" title="var">P</span> <span class="id" title="var">HO</span> <span class="id" title="var">HS</span> <span class="id" title="var">n'</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
We can understand the definition of <span class="inlinecode"><span class="id" title="definition">nat_rect</span></span> better by reimplementing <span class="inlinecode"><span class="id" title="definition">nat_ind</span></span> using sections. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">nat_ind'</span>.<br/>
</div>

<div class="doc">
First, we have the property of natural numbers that we aim to prove. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">P</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span>.<br/>

<br/>
</div>

<div class="doc">
Then we require a proof of the <span class="inlinecode"><span class="id" title="constructor">O</span></span> case, which we declare with the command <span class="inlinecode"><span class="id" title="keyword">Hypothesis</span></span>, which is a synonym for <span class="inlinecode"><span class="id" title="keyword">Variable</span></span> that, by convention, is used for variables whose types are propositions. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">O_case</span> : <span class="id" title="var">P</span> <span class="id" title="var">O</span>.<br/>

<br/>
</div>

<div class="doc">
Next is a proof of the <span class="inlinecode"><span class="id" title="variable">S</span></span> case, which may assume an inductive hypothesis. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">S_case</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>).<br/>

<br/>
</div>

<div class="doc">
Finally, we define a recursive function to tie the pieces together. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">nat_ind'</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">P</span> <span class="id" title="var">n</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="var">O_case</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="var">S_case</span> (<span class="id" title="var">nat_ind'</span> <span class="id" title="var">n'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">nat_ind'</span>.<br/>

<br/>
</div>

<div class="doc">
Closing the section adds the <span class="inlinecode"><span class="id" title="keyword">Variable</span></span>s and <span class="inlinecode"><span class="id" title="keyword">Hypothesis</span></span>es as new <span class="inlinecode"><span class="id" title="keyword">fun</span></span>-bound arguments to <span class="inlinecode"><span class="id" title="definition">nat_ind'</span></span>, and, modulo the use of <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> instead of <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, we end up with the exact same definition that was generated automatically for <span class="inlinecode"><span class="id" title="definition">nat_rect</span></span>.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

We can also examine the definition of <span class="inlinecode"><span class="id" title="definition">even_list_mut</span></span>, which we generated with <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span> for a mutually recursive type. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">even_list_mut</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="definition">even_list_mut</span> = <br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<span class="id" title="variable">P</span> : <span class="id" title="inductive">even_list</span> -&gt; <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">P0</span> : <span class="id" title="inductive">odd_list</span> -&gt; <span class="id" title="keyword">Prop</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="variable">f</span> : <span class="id" title="variable">P</span> <span class="id" title="constructor">ENil</span>) (<span class="id" title="var">f0</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>) (<span class="id" title="variable">o</span> : <span class="id" title="inductive">odd_list</span>), <span class="id" title="var">P0</span> <span class="id" title="variable">o</span> -&gt; <span class="id" title="variable">P</span> (<span class="id" title="constructor">ECons</span> <span class="id" title="variable">n</span> <span class="id" title="variable">o</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="variable">f1</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>) (<span class="id" title="variable">e</span> : <span class="id" title="inductive">even_list</span>), <span class="id" title="variable">P</span> <span class="id" title="variable">e</span> -&gt; <span class="id" title="var">P0</span> (<span class="id" title="constructor">OCons</span> <span class="id" title="variable">n</span> <span class="id" title="variable">e</span>)) =&gt;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fix</span> <span class="id" title="variable">F</span> (<span class="id" title="variable">e</span> : <span class="id" title="inductive">even_list</span>) : <span class="id" title="variable">P</span> <span class="id" title="variable">e</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="variable">e</span> <span class="id" title="keyword">as</span> <span class="id" title="var">e0</span> <span class="id" title="keyword">return</span> (<span class="id" title="variable">P</span> <span class="id" title="var">e0</span>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">ENil</span> =&gt; <span class="id" title="variable">f</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">ECons</span> <span class="id" title="variable">n</span> <span class="id" title="variable">o</span> =&gt; <span class="id" title="var">f0</span> <span class="id" title="variable">n</span> <span class="id" title="variable">o</span> (<span class="id" title="var">F0</span> <span class="id" title="variable">o</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">with</span> <span class="id" title="var">F0</span> (<span class="id" title="variable">o</span> : <span class="id" title="inductive">odd_list</span>) : <span class="id" title="var">P0</span> <span class="id" title="variable">o</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="variable">o</span> <span class="id" title="keyword">as</span> <span class="id" title="var">o0</span> <span class="id" title="keyword">return</span> (<span class="id" title="var">P0</span> <span class="id" title="var">o0</span>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">OCons</span> <span class="id" title="variable">n</span> <span class="id" title="variable">e</span> =&gt; <span class="id" title="variable">f1</span> <span class="id" title="variable">n</span> <span class="id" title="variable">e</span> (<span class="id" title="variable">F</span> <span class="id" title="variable">e</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">for</span> <span class="id" title="variable">F</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> (<span class="id" title="variable">P</span> : <span class="id" title="inductive">even_list</span> -&gt; <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">P0</span> : <span class="id" title="inductive">odd_list</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="variable">P</span> <span class="id" title="constructor">ENil</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>) (<span class="id" title="variable">o</span> : <span class="id" title="inductive">odd_list</span>), <span class="id" title="var">P0</span> <span class="id" title="variable">o</span> -&gt; <span class="id" title="variable">P</span> (<span class="id" title="constructor">ECons</span> <span class="id" title="variable">n</span> <span class="id" title="variable">o</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>) (<span class="id" title="variable">e</span> : <span class="id" title="inductive">even_list</span>), <span class="id" title="variable">P</span> <span class="id" title="variable">e</span> -&gt; <span class="id" title="var">P0</span> (<span class="id" title="constructor">OCons</span> <span class="id" title="variable">n</span> <span class="id" title="variable">e</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="variable">e</span> : <span class="id" title="inductive">even_list</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">e</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

We see a mutually recursive <span class="inlinecode"><span class="id" title="keyword">fix</span></span>, with the different functions separated by <span class="inlinecode"><span class="id" title="keyword">with</span></span> in the same way that they would be separated by <tt>and</tt> in ML.  A final <span class="inlinecode"><span class="id" title="keyword">for</span></span> clause identifies which of the mutually recursive functions should be the final value of the <span class="inlinecode"><span class="id" title="keyword">fix</span></span> expression.  Using this definition as a template, we can reimplement <span class="inlinecode"><span class="id" title="definition">even_list_mut</span></span> directly. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">even_list_mut'</span>.<br/>
</div>

<div class="doc">
First, we need the properties that we are proving. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">Peven</span> : <span class="id" title="var">even_list</span> -&gt; <span class="id" title="keyword">Prop</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">Podd</span> : <span class="id" title="var">odd_list</span> -&gt; <span class="id" title="keyword">Prop</span>.<br/>

<br/>
</div>

<div class="doc">
Next, we need proofs of the three cases. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">ENil_case</span> : <span class="id" title="var">Peven</span> <span class="id" title="var">ENil</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">ECons_case</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">o</span> : <span class="id" title="var">odd_list</span>), <span class="id" title="var">Podd</span> <span class="id" title="var">o</span> -&gt; <span class="id" title="var">Peven</span> (<span class="id" title="var">ECons</span> <span class="id" title="var">n</span> <span class="id" title="var">o</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">OCons_case</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">e</span> : <span class="id" title="var">even_list</span>), <span class="id" title="var">Peven</span> <span class="id" title="var">e</span> -&gt; <span class="id" title="var">Podd</span> (<span class="id" title="var">OCons</span> <span class="id" title="var">n</span> <span class="id" title="var">e</span>).<br/>

<br/>
</div>

<div class="doc">
Finally, we define the recursive functions. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">even_list_mut'</span> (<span class="id" title="var">e</span> : <span class="id" title="var">even_list</span>) : <span class="id" title="var">Peven</span> <span class="id" title="var">e</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">e</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">ENil</span> =&gt; <span class="id" title="var">ENil_case</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">ECons</span> <span class="id" title="var">n</span> <span class="id" title="var">o</span> =&gt; <span class="id" title="var">ECons_case</span> <span class="id" title="var">n</span> (<span class="id" title="var">odd_list_mut'</span> <span class="id" title="var">o</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">with</span> <span class="id" title="var">odd_list_mut'</span> (<span class="id" title="var">o</span> : <span class="id" title="var">odd_list</span>) : <span class="id" title="var">Podd</span> <span class="id" title="var">o</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">o</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">OCons</span> <span class="id" title="var">n</span> <span class="id" title="var">e</span> =&gt; <span class="id" title="var">OCons_case</span> <span class="id" title="var">n</span> (<span class="id" title="var">even_list_mut'</span> <span class="id" title="var">e</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">even_list_mut'</span>.<br/>

<br/>
</div>

<div class="doc">
Even induction principles for reflexive types are easy to implement directly.  For our <span class="inlinecode"><span class="id" title="inductive">formula</span></span> type, we can use a recursive definition much like those we wrote above. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">formula_ind'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">P</span> : <span class="id" title="var">formula</span> -&gt; <span class="id" title="keyword">Prop</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">Eq_case</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> (<span class="id" title="var">Eq</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">And_case</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">f1</span> <span class="id" title="var">f2</span> : <span class="id" title="var">formula</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">P</span> <span class="id" title="var">f1</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">f2</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">And</span> <span class="id" title="var">f1</span> <span class="id" title="var">f2</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">Forall_case</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">f</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">formula</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">P</span> (<span class="id" title="var">f</span> <span class="id" title="var">n</span>)) -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">Forall</span> <span class="id" title="var">f</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">formula_ind'</span> (<span class="id" title="var">f</span> : <span class="id" title="var">formula</span>) : <span class="id" title="var">P</span> <span class="id" title="var">f</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">f</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Eq</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span> =&gt; <span class="id" title="var">Eq_case</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">And</span> <span class="id" title="var">f1</span> <span class="id" title="var">f2</span> =&gt; <span class="id" title="var">And_case</span> (<span class="id" title="var">formula_ind'</span> <span class="id" title="var">f1</span>) (<span class="id" title="var">formula_ind'</span> <span class="id" title="var">f2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Forall</span> <span class="id" title="var">f'</span> =&gt; <span class="id" title="var">Forall_case</span> <span class="id" title="var">f'</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> =&gt; <span class="id" title="var">formula_ind'</span> (<span class="id" title="var">f'</span> <span class="id" title="var">n</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">formula_ind'</span>.<br/>

<br/>
</div>

<div class="doc">
It is apparent that induction principle implementations involve some tedium but not terribly much creativity. 
<div class="paragraph"> </div>

<a name="lab50"></a><h1 class="section">Nested Inductive Types</h1>

<div class="paragraph"> </div>

 Suppose we want to extend our earlier type of binary trees to trees with arbitrary finite branching.  We can use lists to give a simple definition. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">nat_tree</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">NNode'</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">nat_tree</span> -&gt; <span class="id" title="var">nat_tree</span>.<br/>

<br/>
</div>

<div class="doc">
This is an example of a <i>nested</i> inductive type definition, because we use the type we are defining as an argument to a parameterized type family.  Coq will not allow all such definitions; it effectively pretends that we are defining <span class="inlinecode"><span class="id" title="inductive">nat_tree</span></span> mutually with a version of <span class="inlinecode"><span class="id" title="inductive">list</span></span> specialized to <span class="inlinecode"><span class="id" title="inductive">nat_tree</span></span>, checking that the resulting expanded definition satisfies the usual rules.  For instance, if we replaced <span class="inlinecode"><span class="id" title="inductive">list</span></span> with a type family that used its parameter as a function argument, then the definition would be rejected as violating the positivity restriction.

<div class="paragraph"> </div>

As we encountered with mutual inductive types, we find that the automatically generated induction principle for <span class="inlinecode"><span class="id" title="inductive">nat_tree</span></span> is too weak. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">nat_tree_ind</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="definition">nat_tree_ind</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="variable">P</span> : <span class="id" title="inductive">nat_tree</span> -&gt; <span class="id" title="keyword">Prop</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>) (<span class="id" title="variable">l</span> : <span class="id" title="inductive">list</span> <span class="id" title="inductive">nat_tree</span>), <span class="id" title="variable">P</span> (<span class="id" title="constructor">NNode'</span> <span class="id" title="variable">n</span> <span class="id" title="variable">l</span>)) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat_tree</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">n</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

There is no command like <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span> that will implement an improved principle for us.  In general, it takes creativity to figure out <i>good</i> ways to incorporate nested uses of different type families.  Now that we know how to implement induction principles manually, we are in a position to apply just such creativity to this problem.

<div class="paragraph"> </div>

Many induction principles for types with nested uses of <span class="inlinecode"><span class="id" title="inductive">list</span></span> could benefit from a unified predicate capturing the idea that some property holds of every element in a list.  By defining this generic predicate once, we facilitate reuse of library theorems about it.  (Here, we are actually duplicating the standard library's <span class="inlinecode"><span class="id" title="constructor">Forall</span></span> predicate, with a different implementation, for didactic purposes.) 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="keyword">All</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">T</span> : <span class="id" title="keyword">Set</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">P</span> : <span class="id" title="var">T</span> -&gt; <span class="id" title="keyword">Prop</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <span class="id" title="keyword">All</span> (<span class="id" title="var">ls</span> : <span class="id" title="var">list</span> <span class="id" title="var">T</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Nil</span> =&gt; <span class="id" title="var">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Cons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> =&gt; <span class="id" title="var">P</span> <span class="id" title="var">h</span> /\ <span class="id" title="keyword">All</span> <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="keyword">All</span>.<br/>

<br/>
</div>

<div class="doc">
It will be useful to review the definitions of <span class="inlinecode"><span class="id" title="inductive">True</span></span> and <span class="inlinecode">/\</span>, since we will want to write manual proofs of them below. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">True</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <span class="id" title="inductive">True</span> : <span class="id" title="keyword">Prop</span> :=  <span class="id" title="constructor">I</span> : <span class="id" title="inductive">True</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

That is, <span class="inlinecode"><span class="id" title="inductive">True</span></span> is a proposition with exactly one proof, <span class="inlinecode"><span class="id" title="constructor">I</span></span>, which we may always supply trivially.

<div class="paragraph"> </div>

Finding the definition of <span class="inlinecode">/\</span> takes a little more work.  Coq supports user registration of arbitrary parsing rules, and it is such a rule that is letting us write <span class="inlinecode">/\</span> instead of an application of some inductive type family.  We can find the underlying inductive type with the <span class="inlinecode"><span class="id" title="var">Locate</span></span> command, whose argument may be a parsing token. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Locate</span> "/\".<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;"A /\ B" := <span class="id" title="inductive">and</span> <span class="id" title="variable">A</span> <span class="id" title="variable">B</span>  : <span class="id" title="var">type_scope</span> (<span class="id" title="variable">default</span> <span class="id" title="var">interpretation</span>)
<div class="paragraph"> </div>

</span>
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">and</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <span class="id" title="inductive">and</span> (<span class="id" title="variable">A</span> : <span class="id" title="keyword">Prop</span>) (<span class="id" title="variable">B</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=  <span class="id" title="constructor">conj</span> : <span class="id" title="variable">A</span> -&gt; <span class="id" title="variable">B</span> -&gt; <span class="id" title="variable">A</span> /\ <span class="id" title="variable">B</span>
<div class="paragraph"> </div>

</span>
<pre>
  For conj: Arguments A, B are implicit
</pre>

<div class="paragraph"> </div>

In addition to the definition of <span class="inlinecode"><span class="id" title="inductive">and</span></span> itself, we get information on implicit arguments (and some other information that we omit here).  The implicit argument information tells us that we build a proof of a conjunction by calling the constructor <span class="inlinecode"><span class="id" title="constructor">conj</span></span> on proofs of the conjuncts, with no need to include the types of those proofs as explicit arguments.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

Now we create a section for our induction principle, following the same basic plan as in the previous section of this chapter. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">nat_tree_ind'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">P</span> : <span class="id" title="var">nat_tree</span> -&gt; <span class="id" title="keyword">Prop</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">NNode'_case</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">ls</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat_tree</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">All</span> <span class="id" title="var">P</span> <span class="id" title="var">ls</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">NNode'</span> <span class="id" title="var">n</span> <span class="id" title="var">ls</span>).<br/>

<br/>

<br/>
</div>

<div class="doc">
A first attempt at writing the induction principle itself follows the intuition that nested inductive type definitions are expanded into mutual inductive definitions.

<div class="paragraph"> </div>

  <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <span class="id" title="definition">nat_tree_ind'</span> (<span class="id" title="variable">tr</span> : <span class="id" title="inductive">nat_tree</span>) : <span class="id" title="variable">P</span> <span class="id" title="variable">tr</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="variable">tr</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">NNode'</span> <span class="id" title="variable">n</span> <span class="id" title="variable">ls</span> =&gt; <span class="id" title="variable">NNode'_case</span> <span class="id" title="variable">n</span> <span class="id" title="variable">ls</span> (<span class="id" title="definition">list_nat_tree_ind</span> <span class="id" title="variable">ls</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
<br/>
&nbsp;&nbsp;<span class="id" title="keyword">with</span> <span class="id" title="definition">list_nat_tree_ind</span> (<span class="id" title="variable">ls</span> : <span class="id" title="inductive">list</span> <span class="id" title="inductive">nat_tree</span>) : <span class="id" title="keyword">All</span> <span class="id" title="variable">P</span> <span class="id" title="variable">ls</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="variable">ls</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">Nil</span> =&gt; <span class="id" title="constructor">I</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">Cons</span> <span class="id" title="variable">tr</span> <span class="id" title="var">rest</span> =&gt; <span class="id" title="constructor">conj</span> (<span class="id" title="definition">nat_tree_ind'</span> <span class="id" title="variable">tr</span>) (<span class="id" title="definition">list_nat_tree_ind</span> <span class="id" title="var">rest</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
&nbsp;&nbsp;
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

  Coq rejects this definition, saying
<pre>
  Recursive call to nat_tree_ind' has principal argument equal to "tr"
  instead of rest.
</pre>

<div class="paragraph"> </div>

  There is no deep theoretical reason why this program should be rejected; Coq applies incomplete termination-checking heuristics, and it is necessary to learn a few of the most important rules.  The term "nested inductive type" hints at the solution to this particular problem.  Just as mutually inductive types require mutually recursive induction principles, nested types require nested recursion. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">nat_tree_ind'</span> (<span class="id" title="var">tr</span> : <span class="id" title="var">nat_tree</span>) : <span class="id" title="var">P</span> <span class="id" title="var">tr</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">tr</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">NNode'</span> <span class="id" title="var">n</span> <span class="id" title="var">ls</span> =&gt; <span class="id" title="var">NNode'_case</span> <span class="id" title="var">n</span> <span class="id" title="var">ls</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" title="keyword">fix</span> <span class="id" title="var">list_nat_tree_ind</span> (<span class="id" title="var">ls</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat_tree</span>) : <span class="id" title="keyword">All</span> <span class="id" title="var">P</span> <span class="id" title="var">ls</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Nil</span> =&gt; <span class="id" title="var">I</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Cons</span> <span class="id" title="var">tr'</span> <span class="id" title="var">rest</span> =&gt; <span class="id" title="var">conj</span> (<span class="id" title="var">nat_tree_ind'</span> <span class="id" title="var">tr'</span>) (<span class="id" title="var">list_nat_tree_ind</span> <span class="id" title="var">rest</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) <span class="id" title="var">ls</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
We include an anonymous <span class="inlinecode"><span class="id" title="keyword">fix</span></span> version of <span class="inlinecode"><span class="id" title="definition">list_nat_tree_ind</span></span> that is literally <i>nested</i> inside the definition of the recursive function corresponding to the inductive definition that had the nested use of <span class="inlinecode"><span class="id" title="inductive">list</span></span>.   
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">nat_tree_ind'</span>.<br/>

<br/>
</div>

<div class="doc">
We can try our induction principle out by defining some recursive functions on <span class="inlinecode"><span class="id" title="inductive">nat_tree</span></span> and proving a theorem about them.  First, we define some helper functions that operate on lists. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">map</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variables</span> <span class="id" title="var">T</span> <span class="id" title="var">T'</span> : <span class="id" title="keyword">Set</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">F</span> : <span class="id" title="var">T</span> -&gt; <span class="id" title="var">T'</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">map</span> (<span class="id" title="var">ls</span> : <span class="id" title="var">list</span> <span class="id" title="var">T</span>) : <span class="id" title="var">list</span> <span class="id" title="var">T'</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Nil</span> =&gt; <span class="id" title="var">Nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Cons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> =&gt; <span class="id" title="var">Cons</span> (<span class="id" title="var">F</span> <span class="id" title="var">h</span>) (<span class="id" title="var">map</span> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">map</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">sum</span> (<span class="id" title="var">ls</span> : <span class="id" title="var">list</span> <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Nil</span> =&gt; <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Cons</span> <span class="id" title="var">h</span> <span class="id" title="var">t</span> =&gt; <span class="id" title="var">plus</span> <span class="id" title="var">h</span> (<span class="id" title="var">sum</span> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Now we can define a size function over our trees. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">ntsize</span> (<span class="id" title="var">tr</span> : <span class="id" title="var">nat_tree</span>) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">tr</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">NNode'</span> <span class="id" title="var">_</span> <span class="id" title="var">trs</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">sum</span> (<span class="id" title="var">map</span> <span class="id" title="var">ntsize</span> <span class="id" title="var">trs</span>))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Notice that Coq was smart enough to expand the definition of <span class="inlinecode"><span class="id" title="definition">map</span></span> to verify that we are using proper nested recursion, even through a use of a higher-order function. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">ntsplice</span> (<span class="id" title="var">tr1</span> <span class="id" title="var">tr2</span> : <span class="id" title="var">nat_tree</span>) : <span class="id" title="var">nat_tree</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">tr1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">NNode'</span> <span class="id" title="var">n</span> <span class="id" title="var">Nil</span> =&gt; <span class="id" title="var">NNode'</span> <span class="id" title="var">n</span> (<span class="id" title="var">Cons</span> <span class="id" title="var">tr2</span> <span class="id" title="var">Nil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">NNode'</span> <span class="id" title="var">n</span> (<span class="id" title="var">Cons</span> <span class="id" title="var">tr</span> <span class="id" title="var">trs</span>) =&gt; <span class="id" title="var">NNode'</span> <span class="id" title="var">n</span> (<span class="id" title="var">Cons</span> (<span class="id" title="var">ntsplice</span> <span class="id" title="var">tr</span> <span class="id" title="var">tr2</span>) <span class="id" title="var">trs</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
We have defined another arbitrary notion of tree splicing, similar to before, and we can prove an analogous theorem about its relationship with tree size.  We start with a useful lemma about addition. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">plus_S</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">plus</span> <span class="id" title="var">n1</span> (<span class="id" title="var">S</span> <span class="id" title="var">n2</span>) = <span class="id" title="var">S</span> (<span class="id" title="var">plus</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n1</span>; <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Now we begin the proof of the theorem, adding the lemma <span class="inlinecode"><span class="id" title="lemma">plus_S</span></span> as a hint. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Hint Rewrite</span> <span class="id" title="var">plus_S</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">ntsize_ntsplice</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">tr1</span> <span class="id" title="var">tr2</span> : <span class="id" title="var">nat_tree</span>, <span class="id" title="var">ntsize</span> (<span class="id" title="var">ntsplice</span> <span class="id" title="var">tr1</span> <span class="id" title="var">tr2</span>)<br/>
&nbsp;&nbsp;= <span class="id" title="var">plus</span> (<span class="id" title="var">ntsize</span> <span class="id" title="var">tr2</span>) (<span class="id" title="var">ntsize</span> <span class="id" title="var">tr1</span>).<br/>
</div>

<div class="doc">
We know that the standard induction principle is insufficient for the task, so we need to provide a <span class="inlinecode"><span class="id" title="keyword">using</span></span> clause for the <span class="inlinecode"><span class="id" title="tactic">induction</span></span> tactic to specify our alternate principle. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">tr1</span> <span class="id" title="keyword">using</span> <span class="id" title="var">nat_tree_ind'</span>; <span class="id" title="var">crush</span>.<br/>

<br/>
</div>

<div class="doc">
One subgoal remains: <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span><br/>
&nbsp;&nbsp;<span class="id" title="variable">ls</span> : <span class="id" title="inductive">list</span> <span class="id" title="inductive">nat_tree</span><br/>
&nbsp;&nbsp;<span class="id" title="variable">H</span> : <span class="id" title="keyword">All</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="variable">tr1</span> : <span class="id" title="inductive">nat_tree</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="variable">tr2</span> : <span class="id" title="inductive">nat_tree</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">ntsize</span> (<span class="id" title="definition">ntsplice</span> <span class="id" title="variable">tr1</span> <span class="id" title="variable">tr2</span>) = <span class="id" title="definition">plus</span> (<span class="id" title="definition">ntsize</span> <span class="id" title="variable">tr2</span>) (<span class="id" title="definition">ntsize</span> <span class="id" title="variable">tr1</span>)) <span class="id" title="variable">ls</span><br/>
&nbsp;&nbsp;<span class="id" title="variable">tr2</span> : <span class="id" title="inductive">nat_tree</span><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="definition">ntsize</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="variable">ls</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">Nil</span> =&gt; <span class="id" title="constructor">NNode'</span> <span class="id" title="variable">n</span> (<span class="id" title="constructor">Cons</span> <span class="id" title="variable">tr2</span> <span class="id" title="constructor">Nil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">Cons</span> <span class="id" title="variable">tr</span> <span class="id" title="var">trs</span> =&gt; <span class="id" title="constructor">NNode'</span> <span class="id" title="variable">n</span> (<span class="id" title="constructor">Cons</span> (<span class="id" title="definition">ntsplice</span> <span class="id" title="variable">tr</span> <span class="id" title="variable">tr2</span>) <span class="id" title="var">trs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> = <span class="id" title="variable">S</span> (<span class="id" title="definition">plus</span> (<span class="id" title="definition">ntsize</span> <span class="id" title="variable">tr2</span>) (<span class="id" title="inductive">sum</span> (<span class="id" title="definition">map</span> <span class="id" title="definition">ntsize</span> <span class="id" title="variable">ls</span>)))<br/>
&nbsp;
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

     After a few moments of squinting at this goal, it becomes apparent that we need to do a case analysis on the structure of <span class="inlinecode"><span class="id" title="variable">ls</span></span>.  The rest is routine. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">ls</span>; <span class="id" title="var">crush</span>.<br/>

<br/>
</div>

<div class="doc">
We can go further in automating the proof by exploiting the hint mechanism. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Restart</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Extern</span> 1 (<span class="id" title="var">ntsize</span> (<span class="id" title="keyword">match</span> ?<span class="id" title="var">LS</span> <span class="id" title="keyword">with</span> <span class="id" title="var">Nil</span> =&gt; <span class="id" title="var">_</span> | <span class="id" title="var">Cons</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">_</span> <span class="id" title="keyword">end</span>) = <span class="id" title="var">_</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">LS</span>; <span class="id" title="var">crush</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">tr1</span> <span class="id" title="keyword">using</span> <span class="id" title="var">nat_tree_ind'</span>; <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We will go into great detail on hints in a later chapter, but the only important thing to note here is that we register a pattern that describes a conclusion we expect to encounter during the proof.  The pattern may contain unification variables, whose names are prefixed with question marks, and we may refer to those bound variables in a tactic that we ask to have run whenever the pattern matches.

<div class="paragraph"> </div>

The advantage of using the hint is not very clear here, because the original proof was so short.  However, the hint has fundamentally improved the readability of our proof.  Before, the proof referred to the local variable <span class="inlinecode"><span class="id" title="variable">ls</span></span>, which has an automatically generated name.  To a human reading the proof script without stepping through it interactively, it was not clear where <span class="inlinecode"><span class="id" title="variable">ls</span></span> came from.  The hint explains to the reader the process for choosing which variables to case analyze, and the hint can continue working even if the rest of the proof structure changes significantly. 
<div class="paragraph"> </div>

<a name="lab51"></a><h1 class="section">Manual Proofs About Constructors</h1>

<div class="paragraph"> </div>

 It can be useful to understand how tactics like <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span> and <span class="inlinecode"><span class="id" title="tactic">injection</span></span> work, so it is worth stepping through a manual proof of each kind.  We will start with a proof fit for <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">true_neq_false</span> : <span class="id" title="var">true</span> &lt;&gt; <span class="id" title="var">false</span>.<br/>

<br/>
</div>

<div class="doc">
We begin with the tactic <span class="inlinecode"><span class="id" title="tactic">red</span></span>, which is short for "one step of reduction," to unfold the definition of logical negation. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">red</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="constructor">true</span> = <span class="id" title="constructor">false</span> -&gt; <span class="id" title="inductive">False</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The negation is replaced with an implication of falsehood.  We use the tactic <span class="inlinecode"><span class="id" title="tactic">intro</span></span> <span class="inlinecode"><span class="id" title="variable">H</span></span> to change the assumption of the implication into a hypothesis named <span class="inlinecode"><span class="id" title="variable">H</span></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">H</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="variable">H</span> : <span class="id" title="constructor">true</span> = <span class="id" title="constructor">false</span><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="inductive">False</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

This is the point in the proof where we apply some creativity.  We define a function whose utility will become clear soon. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">toProp</span> (<span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) := <span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">True</span> <span class="id" title="keyword">else</span> <span class="id" title="var">False</span>.<br/>

<br/>
</div>

<div class="doc">
It is worth recalling the difference between the lowercase and uppercase versions of truth and falsehood: <span class="inlinecode"><span class="id" title="inductive">True</span></span> and <span class="inlinecode"><span class="id" title="inductive">False</span></span> are logical propositions, while <span class="inlinecode"><span class="id" title="constructor">true</span></span> and <span class="inlinecode"><span class="id" title="constructor">false</span></span> are Boolean values that we can case-analyze.  We have defined <span class="inlinecode"><span class="id" title="definition">toProp</span></span> such that our conclusion of <span class="inlinecode"><span class="id" title="inductive">False</span></span> is computationally equivalent to <span class="inlinecode"><span class="id" title="definition">toProp</span></span> <span class="inlinecode"><span class="id" title="constructor">false</span></span>.  Thus, the <span class="inlinecode"><span class="id" title="tactic">change</span></span> tactic will let us change the conclusion to <span class="inlinecode"><span class="id" title="definition">toProp</span></span> <span class="inlinecode"><span class="id" title="constructor">false</span></span>.  The general form <span class="inlinecode"><span class="id" title="tactic">change</span></span> <span class="inlinecode"><span class="id" title="variable">e</span></span> replaces the conclusion with <span class="inlinecode"><span class="id" title="variable">e</span></span>, whenever Coq's built-in computation rules suffice to establish the equivalence of <span class="inlinecode"><span class="id" title="variable">e</span></span> with the original conclusion. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">toProp</span> <span class="id" title="var">false</span>).<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="variable">H</span> : <span class="id" title="constructor">true</span> = <span class="id" title="constructor">false</span><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="definition">toProp</span> <span class="id" title="constructor">false</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Now the righthand side of <span class="inlinecode"><span class="id" title="variable">H</span></span>'s equality appears in the conclusion, so we can rewrite, using the notation <span class="inlinecode">&lt;-</span> to request to replace the righthand side of the equality with the lefthand side. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">H</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="variable">H</span> : <span class="id" title="constructor">true</span> = <span class="id" title="constructor">false</span><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="definition">toProp</span> <span class="id" title="constructor">true</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

We are almost done.  Just how close we are to done is revealed by computational simplification. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="variable">H</span> : <span class="id" title="constructor">true</span> = <span class="id" title="constructor">false</span><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="inductive">True</span>
<div class="paragraph"> </div>

</span>
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
I have no trivial automated version of this proof to suggest, beyond using <span class="inlinecode"><span class="id" title="tactic">discriminate</span></span> or <span class="inlinecode"><span class="id" title="tactic">congruence</span></span> in the first place.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

We can perform a similar manual proof of injectivity of the constructor <span class="inlinecode"><span class="id" title="variable">S</span></span>.  I leave a walk-through of the details to curious readers who want to run the proof script interactively. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">S_inj'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">S</span> <span class="id" title="var">n</span> = <span class="id" title="var">S</span> <span class="id" title="var">m</span> -&gt; <span class="id" title="var">n</span> = <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">pred</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>) = <span class="id" title="var">pred</span> (<span class="id" title="var">S</span> <span class="id" title="var">m</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The key piece of creativity in this theorem comes in the use of the natural number predecessor function <span class="inlinecode"><span class="id" title="definition">pred</span></span>.  Embodied in the implementation of <span class="inlinecode"><span class="id" title="tactic">injection</span></span> is a generic recipe for writing such type-specific functions.

<div class="paragraph"> </div>

The examples in this section illustrate an important aspect of the design philosophy behind Coq.  We could certainly design a Gallina replacement that built in rules for constructor discrimination and injectivity, but a simpler alternative is to include a few carefully chosen rules that enable the desired reasoning patterns and many others.  A key benefit of this philosophy is that the complexity of proof checking is minimized, which bolsters our confidence that proved theorems are really true. 
</div>
<div class="code">
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>