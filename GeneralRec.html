<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>GeneralRec</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library GeneralRec</h1>

<div class="code">

<br/>

<br/>
</div>

<div class="doc">
 
<div class="paragraph"> </div>

 Termination of all programs is a crucial property of Gallina.  Non-terminating programs introduce logical inconsistency, where any theorem can be proved with an infinite loop.  Coq uses a small set of conservative, syntactic criteria to check termination of all recursive definitions.  These criteria are insufficient to support the natural encodings of a variety of important programming idioms.  Further, since Coq makes it so convenient to encode mathematics computationally, with functional programs, we may find ourselves wanting to employ more complicated recursion in mathematical definitions.

<div class="paragraph"> </div>

   What exactly are the conservative criteria that we run up against?  For <i>recursive</i> definitions, recursive calls are only allowed on <i>syntactic subterms</i> of the original primary argument, a restriction known as <i>primitive recursion</i>.  In fact, Coq's handling of reflexive inductive types (those defined in terms of functions returning the same type) gives a bit more flexibility than in traditional primitive recursion, but the term is still applied commonly.  In Chapter 5, we saw how <i>co-recursive</i> definitions are checked against a syntactic guardedness condition that guarantees productivity.

<div class="paragraph"> </div>

   Many natural recursion patterns satisfy neither condition.  For instance, there is our simple running example in this chapter, merge sort.  We will study three different approaches to more flexible recursion, and the latter two of the approaches will even support definitions that may fail to terminate on certain inputs, without any up-front characterization of which inputs those may be.

<div class="paragraph"> </div>

   Before proceeding, it is important to note that the problem here is not as fundamental as it may appear.  The final example of Chapter 5 demonstrated what is called a <i>deep embedding</i> of the syntax and semantics of a programming language.  That is, we gave a mathematical definition of a language of programs and their meanings.  This language clearly admitted non-termination, and we could think of writing all our sophisticated recursive functions with such explicit syntax types.  However, in doing so, we forfeit our chance to take advantage of Coq's very good built-in support for reasoning about Gallina programs.  We would rather use a <i>shallow embedding</i>, where we model informal constructs by encoding them as normal Gallina programs.  Each of the three techniques of this chapter follows that style. 
<div class="paragraph"> </div>

<a name="lab34"></a><h1 class="section">Well-Founded Recursion</h1>

<div class="paragraph"> </div>

 The essence of terminating recursion is that there are no infinite chains of nested recursive calls.  This intuition is commonly mapped to the mathematical idea of a <i>well-founded relation</i>, and the associated standard technique in Coq is <i>well-founded recursion</i>.  The syntactic-subterm relation that Coq applies by default is well-founded, but many cases demand alternate well-founded relations.  To demonstrate, let us see where we get stuck on attempting a standard merge sort implementation. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">mergeSort</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">le</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>.<br/>

<br/>
</div>

<div class="doc">
We have a set equipped with some "less-than-or-equal-to" test. 
<div class="paragraph"> </div>

 A standard function inserts an element into a sorted list, preserving sortedness. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">insert</span> (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">ls</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt; <span class="id" title="var">x</span> :: <span class="id" title="var">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">ls'</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">le</span> <span class="id" title="var">x</span> <span class="id" title="var">h</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="var">x</span> :: <span class="id" title="var">ls</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">h</span> :: <span class="id" title="var">insert</span> <span class="id" title="var">x</span> <span class="id" title="var">ls'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
We will also need a function to merge two sorted lists.  (We use a less efficient implementation than usual, because the more efficient implementation already forces us to think about well-founded recursion, while here we are only interested in setting up the example of merge sort.) 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">merge</span> (<span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt; <span class="id" title="var">ls2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">ls'</span> =&gt; <span class="id" title="var">insert</span> <span class="id" title="var">h</span> (<span class="id" title="var">merge</span> <span class="id" title="var">ls'</span> <span class="id" title="var">ls2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The last helper function for classic merge sort is the one that follows, to split a list arbitrarily into two pieces of approximately equal length. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <span class="id" title="tactic">split</span> (<span class="id" title="var">ls</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> * <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt; (<span class="id" title="var">nil</span>, <span class="id" title="var">nil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">h</span> :: <span class="id" title="var">nil</span> =&gt; (<span class="id" title="var">h</span> :: <span class="id" title="var">nil</span>, <span class="id" title="var">nil</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">h1</span> :: <span class="id" title="var">h2</span> :: <span class="id" title="var">ls'</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> (<span class="id" title="var">ls1</span>, <span class="id" title="var">ls2</span>) := <span class="id" title="tactic">split</span> <span class="id" title="var">ls'</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">h1</span> :: <span class="id" title="var">ls1</span>, <span class="id" title="var">h2</span> :: <span class="id" title="var">ls2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Now, let us try to write the final sorting function, using a natural number "<span class="inlinecode">&lt;=</span>" test <span class="inlinecode"><span class="id" title="abbreviation">leb</span></span> from the standard library.
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <span class="id" title="definition">mergeSort</span> (<span class="id" title="variable">ls</span> : <span class="id" title="inductive">list</span> <span class="id" title="variable">A</span>) : <span class="id" title="inductive">list</span> <span class="id" title="variable">A</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="abbreviation">leb</span> (<span class="id" title="definition">length</span> <span class="id" title="variable">ls</span>) 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="variable">ls</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="keyword">let</span> <span class="id" title="variable">lss</span> := <span class="id" title="tactic">split</span> <span class="id" title="variable">ls</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">merge</span> (<span class="id" title="definition">mergeSort</span> (<span class="id" title="definition">fst</span> <span class="id" title="variable">lss</span>)) (<span class="id" title="definition">mergeSort</span> (<span class="id" title="definition">snd</span> <span class="id" title="variable">lss</span>)).
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
Recursive call to mergeSort has principal argument equal to
"fst (split ls)" instead of a subterm of "ls".
</pre>

<div class="paragraph"> </div>

The definition is rejected for not following the simple primitive recursion criterion.  In particular, it is not apparent that recursive calls to <span class="inlinecode"><span class="id" title="definition">mergeSort</span></span> are syntactic subterms of the original argument <span class="inlinecode"><span class="id" title="variable">ls</span></span>; indeed, they are not, yet we know this is a well-founded recursive definition.

<div class="paragraph"> </div>

To produce an acceptable definition, we need to choose a well-founded relation and prove that <span class="inlinecode"><span class="id" title="definition">mergeSort</span></span> respects it.  A good starting point is an examination of how well-foundedness is formalized in the Coq standard library. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Print</span> <span class="id" title="var">well_founded</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="definition">well_founded</span> = <br/>
<span class="id" title="keyword">fun</span> (<span class="id" title="variable">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="variable">R</span> : <span class="id" title="variable">A</span> -&gt; <span class="id" title="variable">A</span> -&gt; <span class="id" title="keyword">Prop</span>) =&gt; <span class="id" title="keyword">forall</span> <span class="id" title="variable">a</span> : <span class="id" title="variable">A</span>, <span class="id" title="inductive">Acc</span> <span class="id" title="variable">R</span> <span class="id" title="variable">a</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The bulk of the definitional work devolves to the <i>accessibility</i> relation <span class="inlinecode"><span class="id" title="inductive">Acc</span></span>, whose definition we may also examine. 
</div>
<div class="code">

<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Print</span> <span class="id" title="var">Acc</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="keyword">Inductive</span> <span class="id" title="inductive">Acc</span> (<span class="id" title="variable">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="variable">R</span> : <span class="id" title="variable">A</span> -&gt; <span class="id" title="variable">A</span> -&gt; <span class="id" title="keyword">Prop</span>) (<span class="id" title="variable">x</span> : <span class="id" title="variable">A</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="constructor">Acc_intro</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="variable">y</span> : <span class="id" title="variable">A</span>, <span class="id" title="variable">R</span> <span class="id" title="variable">y</span> <span class="id" title="variable">x</span> -&gt; <span class="id" title="inductive">Acc</span> <span class="id" title="variable">R</span> <span class="id" title="variable">y</span>) -&gt; <span class="id" title="inductive">Acc</span> <span class="id" title="variable">R</span> <span class="id" title="variable">x</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

In prose, an element <span class="inlinecode"><span class="id" title="variable">x</span></span> is accessible for a relation <span class="inlinecode"><span class="id" title="variable">R</span></span> if every element "less than" <span class="inlinecode"><span class="id" title="variable">x</span></span> according to <span class="inlinecode"><span class="id" title="variable">R</span></span> is also accessible.  Since <span class="inlinecode"><span class="id" title="inductive">Acc</span></span> is defined inductively, we know that any accessibility proof involves a finite chain of invocations, in a certain sense that we can make formal.  Building on Chapter 5's examples, let us define a co-inductive relation that is closer to the usual informal notion of "absence of infinite decreasing chains." 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">CoInductive</span> <span class="id" title="var">infiniteDecreasingChain</span> <span class="id" title="var">A</span> (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>) : <span class="id" title="var">stream</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">ChainCons</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">s</span>, <span class="id" title="var">infiniteDecreasingChain</span> <span class="id" title="var">R</span> (<span class="id" title="var">Cons</span> <span class="id" title="var">y</span> <span class="id" title="var">s</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="var">infiniteDecreasingChain</span> <span class="id" title="var">R</span> (<span class="id" title="var">Cons</span> <span class="id" title="var">x</span> (<span class="id" title="var">Cons</span> <span class="id" title="var">y</span> <span class="id" title="var">s</span>)).<br/>

<br/>
</div>

<div class="doc">
We can now prove that any accessible element cannot be the beginning of any infinite decreasing chain. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">noBadChains'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>) <span class="id" title="var">x</span>, <span class="id" title="var">Acc</span> <span class="id" title="var">R</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">s</span>, ~<span class="id" title="var">infiniteDecreasingChain</span> <span class="id" title="var">R</span> (<span class="id" title="var">Cons</span> <span class="id" title="var">x</span> <span class="id" title="var">s</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1; <span class="id" title="var">crush</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="var">infiniteDecreasingChain</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] =&gt; <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">eauto</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
From here, the absence of infinite decreasing chains in well-founded sets is immediate. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <span class="id" title="var">noBadChains</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> (<span class="id" title="var">R</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>), <span class="id" title="var">well_founded</span> <span class="id" title="var">R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">s</span>, ~<span class="id" title="var">infiniteDecreasingChain</span> <span class="id" title="var">R</span> <span class="id" title="var">s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">s</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">noBadChains'</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Absence of infinite decreasing chains implies absence of infinitely nested recursive calls, for any recursive definition that respects the well-founded relation.  The <span class="inlinecode"><span class="id" title="keyword">Fix</span></span> combinator from the standard library formalizes that intuition: 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Fix</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="keyword">Fix</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> (<span class="id" title="variable">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="variable">R</span> : <span class="id" title="variable">A</span> -&gt; <span class="id" title="variable">A</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">well_founded</span> <span class="id" title="variable">R</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="variable">P</span> : <span class="id" title="variable">A</span> -&gt; <span class="id" title="keyword">Type</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="variable">x</span> : <span class="id" title="variable">A</span>, (<span class="id" title="keyword">forall</span> <span class="id" title="variable">y</span> : <span class="id" title="variable">A</span>, <span class="id" title="variable">R</span> <span class="id" title="variable">y</span> <span class="id" title="variable">x</span> -&gt; <span class="id" title="variable">P</span> <span class="id" title="variable">y</span>) -&gt; <span class="id" title="variable">P</span> <span class="id" title="variable">x</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="variable">x</span> : <span class="id" title="variable">A</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">x</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

A call to <span class="inlinecode"><span class="id" title="keyword">Fix</span></span> must present a relation <span class="inlinecode"><span class="id" title="variable">R</span></span> and a proof of its well-foundedness.  The next argument, <span class="inlinecode"><span class="id" title="variable">P</span></span>, is the possibly dependent range type of the function we build; the domain <span class="inlinecode"><span class="id" title="variable">A</span></span> of <span class="inlinecode"><span class="id" title="variable">R</span></span> is the function's domain.  The following argument has this type:
<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="variable">x</span> : <span class="id" title="variable">A</span>, (<span class="id" title="keyword">forall</span> <span class="id" title="variable">y</span> : <span class="id" title="variable">A</span>, <span class="id" title="variable">R</span> <span class="id" title="variable">y</span> <span class="id" title="variable">x</span> -&gt; <span class="id" title="variable">P</span> <span class="id" title="variable">y</span>) -&gt; <span class="id" title="variable">P</span> <span class="id" title="variable">x</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

This is an encoding of the function body.  The input <span class="inlinecode"><span class="id" title="variable">x</span></span> stands for the function argument, and the next input stands for the function we are defining.  Recursive calls are encoded as calls to the second argument, whose type tells us it expects a value <span class="inlinecode"><span class="id" title="variable">y</span></span> and a proof that <span class="inlinecode"><span class="id" title="variable">y</span></span> is "less than" <span class="inlinecode"><span class="id" title="variable">x</span></span>, according to <span class="inlinecode"><span class="id" title="variable">R</span></span>.  In this way, we enforce the well-foundedness restriction on recursive calls.

<div class="paragraph"> </div>

The rest of <span class="inlinecode"><span class="id" title="keyword">Fix</span></span>'s type tells us that it returns a function of exactly the type we expect, so we are now ready to use it to implement <span class="inlinecode"><span class="id" title="definition">mergeSort</span></span>.  Careful readers may have noticed that <span class="inlinecode"><span class="id" title="keyword">Fix</span></span> has a dependent type of the sort we met in the previous chapter.

<div class="paragraph"> </div>

Before writing <span class="inlinecode"><span class="id" title="definition">mergeSort</span></span>, we need to settle on a well-founded relation.  The right one for this example is based on lengths of lists. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">lengthOrder</span> (<span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">length</span> <span class="id" title="var">ls1</span> &lt; <span class="id" title="var">length</span> <span class="id" title="var">ls2</span>.<br/>

<br/>
</div>

<div class="doc">
We must prove that the relation is truly well-founded.  To save some space in the rest of this chapter, we skip right to nice, automated proof scripts, though we postpone introducing the principles behind such scripts to Part III of the book.  Curious readers may still replace semicolons with periods and newlines to step through these scripts interactively. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Constructors</span> <span class="id" title="var">Acc</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">lengthOrder_wf'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">len</span>, <span class="id" title="keyword">forall</span> <span class="id" title="var">ls</span>, <span class="id" title="var">length</span> <span class="id" title="var">ls</span> &lt;= <span class="id" title="var">len</span> -&gt; <span class="id" title="var">Acc</span> <span class="id" title="var">lengthOrder</span> <span class="id" title="var">ls</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">lengthOrder</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">len</span>; <span class="id" title="var">crush</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <span class="id" title="var">lengthOrder_wf</span> : <span class="id" title="var">well_founded</span> <span class="id" title="var">lengthOrder</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">red</span>; <span class="id" title="tactic">intro</span>; <span class="id" title="tactic">eapply</span> <span class="id" title="var">lengthOrder_wf'</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Notice that we end these proofs with <span class="inlinecode"><span class="id" title="keyword">Defined</span></span>, not <span class="inlinecode"><span class="id" title="keyword">Qed</span></span>.  Recall that <span class="inlinecode"><span class="id" title="keyword">Defined</span></span> marks the theorems as <i>transparent</i>, so that the details of their proofs may be used during program execution.  Why could such details possibly matter for computation?  It turns out that <span class="inlinecode"><span class="id" title="keyword">Fix</span></span> satisfies the primitive recursion restriction by declaring itself as <i>recursive in the structure of <span class="inlinecode"><span class="id" title="inductive">Acc</span></span> proofs</i>.  This is possible because <span class="inlinecode"><span class="id" title="inductive">Acc</span></span> proofs follow a predictable inductive structure.  We must do work, as in the last theorem's proof, to establish that all elements of a type belong to <span class="inlinecode"><span class="id" title="inductive">Acc</span></span>, but the automatic unwinding of those proofs during recursion is straightforward.  If we ended the proof with <span class="inlinecode"><span class="id" title="keyword">Qed</span></span>, the proof details would be hidden from computation, in which case the unwinding process would get stuck.

<div class="paragraph"> </div>

     To justify our two recursive <span class="inlinecode"><span class="id" title="definition">mergeSort</span></span> calls, we will also need to prove that <span class="inlinecode"><span class="id" title="tactic">split</span></span> respects the <span class="inlinecode"><span class="id" title="definition">lengthOrder</span></span> relation.  These proofs, too, must be kept transparent, to avoid stuckness of <span class="inlinecode"><span class="id" title="keyword">Fix</span></span> evaluation.  We use the syntax <span class="inlinecode">@<span class="id" title="inductive">foo</span></span> to reference identifier <span class="inlinecode"><span class="id" title="inductive">foo</span></span> with its implicit argument behavior turned off.  (The proof details below use Ltac features not introduced yet, and they are safe to skip for now.) 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">split_wf</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">len</span> <span class="id" title="var">ls</span>, 2 &lt;= <span class="id" title="var">length</span> <span class="id" title="var">ls</span> &lt;= <span class="id" title="var">len</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="keyword">let</span> (<span class="id" title="var">ls1</span>, <span class="id" title="var">ls2</span>) := <span class="id" title="tactic">split</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lengthOrder</span> <span class="id" title="var">ls1</span> <span class="id" title="var">ls</span> /\ <span class="id" title="var">lengthOrder</span> <span class="id" title="var">ls2</span> <span class="id" title="var">ls</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">lengthOrder</span>; <span class="id" title="tactic">induction</span> <span class="id" title="var">len</span>; <span class="id" title="var">crush</span>; <span class="id" title="tactic">do</span> 2 (<span class="id" title="tactic">destruct</span> <span class="id" title="var">ls</span>; <span class="id" title="var">crush</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">le_lt_dec</span> 2 (<span class="id" title="var">length</span> <span class="id" title="var">ls</span>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">_</span> : <span class="id" title="var">length</span> ?<span class="id" title="var">E</span> &lt; 2 |- <span class="id" title="var">_</span> ] =&gt; <span class="id" title="tactic">destruct</span> <span class="id" title="var">E</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">_</span> : <span class="id" title="var">S</span> (<span class="id" title="var">length</span> ?<span class="id" title="var">E</span>) &lt; 2 |- <span class="id" title="var">_</span> ] =&gt; <span class="id" title="tactic">destruct</span> <span class="id" title="var">E</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">IH</span> : <span class="id" title="var">_</span> |- <span class="id" title="keyword">context</span>[<span class="id" title="tactic">split</span> ?<span class="id" title="var">L</span>] ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">specialize</span> (<span class="id" title="var">IH</span> <span class="id" title="var">L</span>); <span class="id" title="tactic">destruct</span> (<span class="id" title="tactic">split</span> <span class="id" title="var">L</span>); <span class="id" title="tactic">destruct</span> <span class="id" title="var">IH</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="var">crush</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">split_wf</span> := <span class="id" title="tactic">intros</span> <span class="id" title="var">ls</span> ?; <span class="id" title="tactic">intros</span>; <span class="id" title="tactic">generalize</span> (@<span class="id" title="var">split_wf</span> (<span class="id" title="var">length</span> <span class="id" title="var">ls</span>) <span class="id" title="var">ls</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="tactic">split</span> <span class="id" title="var">ls</span>); <span class="id" title="tactic">destruct</span> 1; <span class="id" title="var">crush</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">split_wf1</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">ls</span>, 2 &lt;= <span class="id" title="var">length</span> <span class="id" title="var">ls</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="var">lengthOrder</span> (<span class="id" title="var">fst</span> (<span class="id" title="tactic">split</span> <span class="id" title="var">ls</span>)) <span class="id" title="var">ls</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">split_wf</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">split_wf2</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">ls</span>, 2 &lt;= <span class="id" title="var">length</span> <span class="id" title="var">ls</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="var">lengthOrder</span> (<span class="id" title="var">snd</span> (<span class="id" title="tactic">split</span> <span class="id" title="var">ls</span>)) <span class="id" title="var">ls</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">split_wf</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">split_wf1</span> <span class="id" title="var">split_wf2</span>.<br/>

<br/>
</div>

<div class="doc">
To write the function definition itself, we use the <span class="inlinecode"><span class="id" title="tactic">refine</span></span> tactic as a convenient way to write a program that needs to manipulate proofs, without writing out those proofs manually.  We also use a replacement <span class="inlinecode"><span class="id" title="definition">le_lt_dec</span></span> for <span class="inlinecode"><span class="id" title="abbreviation">leb</span></span> that has a more interesting dependent type.  (Note that we would not be able to complete the definition without this change, since <span class="inlinecode"><span class="id" title="tactic">refine</span></span> will generate subgoals for the <span class="inlinecode"><span class="id" title="keyword">if</span></span> branches based only on the <i>type</i> of the test expression, not its <i>value</i>.) 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">mergeSort</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">Fix</span> <span class="id" title="var">lengthOrder_wf</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> (<span class="id" title="var">ls</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">mergeSort</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">ls'</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>, <span class="id" title="var">lengthOrder</span> <span class="id" title="var">ls'</span> <span class="id" title="var">ls</span> -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">le_lt_dec</span> 2 (<span class="id" title="var">length</span> <span class="id" title="var">ls</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="keyword">let</span> <span class="id" title="var">lss</span> := <span class="id" title="tactic">split</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> (<span class="id" title="var">mergeSort</span> (<span class="id" title="var">fst</span> <span class="id" title="var">lss</span>) <span class="id" title="var">_</span>) (<span class="id" title="var">mergeSort</span> (<span class="id" title="var">snd</span> <span class="id" title="var">lss</span>) <span class="id" title="var">_</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">ls</span>)); <span class="id" title="tactic">subst</span> <span class="id" title="var">lss</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">mergeSort</span>.<br/>

<br/>
</div>

<div class="doc">
The important thing is that it is now easy to evaluate calls to <span class="inlinecode"><span class="id" title="definition">mergeSort</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="var">mergeSort</span> <span class="id" title="var">leb</span> (1 :: 2 :: 36 :: 8 :: 19 :: <span class="id" title="var">nil</span>).<br/>
</div>

<div class="doc">
<span class="inlinecode">=</span> <span class="inlinecode">1</span> <span class="inlinecode">::</span> <span class="inlinecode">2</span> <span class="inlinecode">::</span> <span class="inlinecode">8</span> <span class="inlinecode">::</span> <span class="inlinecode">19</span> <span class="inlinecode">::</span> <span class="inlinecode">36</span> <span class="inlinecode">::</span> <span class="inlinecode"><span class="id" title="constructor">nil</span></span> 
<div class="paragraph"> </div>

 Since the subject of this chapter is merely how to define functions with unusual recursion structure, we will not prove any further correctness theorems about <span class="inlinecode"><span class="id" title="definition">mergeSort</span></span>. Instead, we stop at proving that <span class="inlinecode"><span class="id" title="definition">mergeSort</span></span> has the expected computational behavior, for all inputs, not merely the one we just tested. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mergeSort_eq</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> (<span class="id" title="var">le</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>) <span class="id" title="var">ls</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">mergeSort</span> <span class="id" title="var">le</span> <span class="id" title="var">ls</span> = <span class="id" title="keyword">if</span> <span class="id" title="var">le_lt_dec</span> 2 (<span class="id" title="var">length</span> <span class="id" title="var">ls</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="keyword">let</span> <span class="id" title="var">lss</span> := <span class="id" title="tactic">split</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">merge</span> <span class="id" title="var">le</span> (<span class="id" title="var">mergeSort</span> <span class="id" title="var">le</span> (<span class="id" title="var">fst</span> <span class="id" title="var">lss</span>)) (<span class="id" title="var">mergeSort</span> <span class="id" title="var">le</span> (<span class="id" title="var">snd</span> <span class="id" title="var">lss</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">ls</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">apply</span> (<span class="id" title="var">Fix_eq</span> (@<span class="id" title="var">lengthOrder_wf</span> <span class="id" title="var">A</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span>)); <span class="id" title="tactic">intros</span>.<br/>

<br/>
</div>

<div class="doc">
The library theorem <span class="inlinecode"><span class="id" title="lemma">Fix_eq</span></span> imposes one more strange subgoal upon us.  We must prove that the function body is unable to distinguish between "self" arguments that map equal inputs to equal outputs.  One might think this should be true of any Gallina code, but in fact this general <i>function extensionality</i> property is neither provable nor disprovable within Coq.  The type of <span class="inlinecode"><span class="id" title="lemma">Fix_eq</span></span> makes clear what we must show manually: 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Check</span> <span class="id" title="var">Fix_eq</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="lemma">Fix_eq</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> (<span class="id" title="variable">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="variable">R</span> : <span class="id" title="variable">A</span> -&gt; <span class="id" title="variable">A</span> -&gt; <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">Rwf</span> : <span class="id" title="definition">well_founded</span> <span class="id" title="variable">R</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="variable">P</span> : <span class="id" title="variable">A</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="variable">F</span> : <span class="id" title="keyword">forall</span> <span class="id" title="variable">x</span> : <span class="id" title="variable">A</span>, (<span class="id" title="keyword">forall</span> <span class="id" title="variable">y</span> : <span class="id" title="variable">A</span>, <span class="id" title="variable">R</span> <span class="id" title="variable">y</span> <span class="id" title="variable">x</span> -&gt; <span class="id" title="variable">P</span> <span class="id" title="variable">y</span>) -&gt; <span class="id" title="variable">P</span> <span class="id" title="variable">x</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="variable">x</span> : <span class="id" title="variable">A</span>) (<span class="id" title="variable">f</span> <span class="id" title="variable">g</span> : <span class="id" title="keyword">forall</span> <span class="id" title="variable">y</span> : <span class="id" title="variable">A</span>, <span class="id" title="variable">R</span> <span class="id" title="variable">y</span> <span class="id" title="variable">x</span> -&gt; <span class="id" title="variable">P</span> <span class="id" title="variable">y</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="variable">y</span> : <span class="id" title="variable">A</span>) (<span class="id" title="variable">p</span> : <span class="id" title="variable">R</span> <span class="id" title="variable">y</span> <span class="id" title="variable">x</span>), <span class="id" title="variable">f</span> <span class="id" title="variable">y</span> <span class="id" title="variable">p</span> = <span class="id" title="variable">g</span> <span class="id" title="variable">y</span> <span class="id" title="variable">p</span>) -&gt; <span class="id" title="variable">F</span> <span class="id" title="variable">x</span> <span class="id" title="variable">f</span> = <span class="id" title="variable">F</span> <span class="id" title="variable">x</span> <span class="id" title="variable">g</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="variable">x</span> : <span class="id" title="variable">A</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Fix</span> <span class="id" title="var">Rwf</span> <span class="id" title="variable">P</span> <span class="id" title="variable">F</span> <span class="id" title="variable">x</span> = <span class="id" title="variable">F</span> <span class="id" title="variable">x</span> (<span class="id" title="keyword">fun</span> (<span class="id" title="variable">y</span> : <span class="id" title="variable">A</span>) (<span class="id" title="var">_</span> : <span class="id" title="variable">R</span> <span class="id" title="variable">y</span> <span class="id" title="variable">x</span>) =&gt; <span class="id" title="keyword">Fix</span> <span class="id" title="var">Rwf</span> <span class="id" title="variable">P</span> <span class="id" title="variable">F</span> <span class="id" title="variable">y</span>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

  Most such obligations are dischargeable with straightforward proof automation, and this example is no exception. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">context</span>[<span class="id" title="keyword">match</span> ?<span class="id" title="var">E</span> <span class="id" title="keyword">with</span> <span class="id" title="tactic">left</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">_</span> | <span class="id" title="tactic">right</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">_</span> <span class="id" title="keyword">end</span>] ] =&gt; <span class="id" title="tactic">destruct</span> <span class="id" title="var">E</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">f_equal</span>; <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
As a final test of our definition's suitability, we can extract to OCaml. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Extraction</span> <span class="id" title="var">mergeSort</span>.<br/>

<br/>
</div>

<div class="doc">
<pre>
let rec mergeSort le x =
  match le_lt_dec (S (S O)) (length x) with
  | Left -&gt;
    let lss = split x in
    merge le (mergeSort le (fst lss)) (mergeSort le (snd lss))
  | Right -&gt; x
</pre>

<div class="paragraph"> </div>

  We see almost precisely the same definition we would have written manually in OCaml!  It might be a good exercise for the reader to use the commands we saw in the previous chapter to clean up some remaining differences from idiomatic OCaml.

<div class="paragraph"> </div>

  One more piece of the full picture is missing.  To go on and prove correctness of <span class="inlinecode"><span class="id" title="definition">mergeSort</span></span>, we would need more than a way of unfolding its definition.  We also need an appropriate induction principle matched to the well-founded relation.  Such a principle is available in the standard library, though we will say no more about its details here. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">well_founded_induction</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="lemma">well_founded_induction</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> (<span class="id" title="variable">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="variable">R</span> : <span class="id" title="variable">A</span> -&gt; <span class="id" title="variable">A</span> -&gt; <span class="id" title="keyword">Prop</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">well_founded</span> <span class="id" title="variable">R</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="variable">P</span> : <span class="id" title="variable">A</span> -&gt; <span class="id" title="keyword">Set</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="variable">x</span> : <span class="id" title="variable">A</span>, (<span class="id" title="keyword">forall</span> <span class="id" title="variable">y</span> : <span class="id" title="variable">A</span>, <span class="id" title="variable">R</span> <span class="id" title="variable">y</span> <span class="id" title="variable">x</span> -&gt; <span class="id" title="variable">P</span> <span class="id" title="variable">y</span>) -&gt; <span class="id" title="variable">P</span> <span class="id" title="variable">x</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="variable">a</span> : <span class="id" title="variable">A</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">a</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

  Some more recent Coq features provide more convenient syntax for defining recursive functions.  Interested readers can consult the Coq manual about the commands <span class="inlinecode"><span class="id" title="keyword">Function</span></span> and <span class="inlinecode"><span class="id" title="library">Program</span></span> <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>. 
<div class="paragraph"> </div>

<a name="lab35"></a><h1 class="section">A Non-Termination Monad Inspired by Domain Theory</h1>

<div class="paragraph"> </div>

 The key insights of domain theory inspire the next approach to modeling non-termination.  Domain theory is based on <i>information orders</i> that relate values representing computation results, according to how much information these values convey.  For instance, a simple domain might include values "the program does not terminate" and "the program terminates with the answer 5."  The former is considered to be an <i>approximation</i> of the latter, while the latter is <i>not</i> an approximation of "the program terminates with the answer 6."  The details of domain theory will not be important in what follows; we merely borrow the notion of an approximation ordering on computation results.

<div class="paragraph"> </div>

   Consider this definition of a type of computations. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">computation</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>.<br/>
</div>

<div class="doc">
The type <span class="inlinecode"><span class="id" title="variable">A</span></span> describes the result a computation will yield, if it terminates.

<div class="paragraph"> </div>

     We give a rich dependent type to computations themselves: 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">computation</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">f</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">option</span> <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">forall</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">v</span> : <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> <span class="id" title="var">n</span> = <span class="id" title="var">Some</span> <span class="id" title="var">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="keyword">forall</span> (<span class="id" title="var">n'</span> : <span class="id" title="var">nat</span>), <span class="id" title="var">n'</span> &gt;= <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="var">f</span> <span class="id" title="var">n'</span> = <span class="id" title="var">Some</span> <span class="id" title="var">v</span>}.<br/>

<br/>
</div>

<div class="doc">
A computation is fundamentally a function <span class="inlinecode"><span class="id" title="variable">f</span></span> from an <i>approximation level</i> <span class="inlinecode"><span class="id" title="variable">n</span></span> to an optional result.  Intuitively, higher <span class="inlinecode"><span class="id" title="variable">n</span></span> values enable termination in more cases than lower values.  A call to <span class="inlinecode"><span class="id" title="variable">f</span></span> may return <span class="inlinecode"><span class="id" title="constructor">None</span></span> to indicate that <span class="inlinecode"><span class="id" title="variable">n</span></span> was not high enough to run the computation to completion; higher <span class="inlinecode"><span class="id" title="variable">n</span></span> values may yield <span class="inlinecode"><span class="id" title="constructor">Some</span></span>.  Further, the proof obligation within the subset type asserts that <span class="inlinecode"><span class="id" title="variable">f</span></span> is <i>monotone</i> in an appropriate sense: when some <span class="inlinecode"><span class="id" title="variable">n</span></span> is sufficient to produce termination, so are all higher <span class="inlinecode"><span class="id" title="variable">n</span></span> values, and they all yield the same program result <span class="inlinecode"><span class="id" title="variable">v</span></span>.

<div class="paragraph"> </div>

  It is easy to define a relation characterizing when a computation runs to a particular result at a particular approximation level. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">runTo</span> (<span class="id" title="var">m</span> : <span class="id" title="var">computation</span>) (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">v</span> : <span class="id" title="var">A</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">proj1_sig</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> = <span class="id" title="var">Some</span> <span class="id" title="var">v</span>.<br/>

<br/>
</div>

<div class="doc">
On top of <span class="inlinecode"><span class="id" title="definition">runTo</span></span>, we also define <span class="inlinecode"><span class="id" title="definition">run</span></span>, which is the most abstract notion of when a computation runs to a value. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">run</span> (<span class="id" title="var">m</span> : <span class="id" title="var">computation</span>) (<span class="id" title="var">v</span> : <span class="id" title="var">A</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <span class="id" title="var">n</span>, <span class="id" title="var">runTo</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> <span class="id" title="var">v</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">computation</span>.<br/>

<br/>
</div>

<div class="doc">
The book source code contains at this point some tactics, lemma proofs, and hint commands, to be used in proving facts about computations.  Since their details are orthogonal to the message of this chapter, I have omitted them in the rendered version. 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
Now, as a simple first example of a computation, we can define <span class="inlinecode"><span class="id" title="definition">Bottom</span></span>, which corresponds to an infinite loop.  For any approximation level, it fails to terminate (returns <span class="inlinecode"><span class="id" title="constructor">None</span></span>).  Note the use of <span class="inlinecode"><span class="id" title="tactic">abstract</span></span> to create a new opaque lemma for the proof found by the <tt>run</tt> tactic.  In contrast to the previous section, opaque proofs are fine here, since the proof components of computations do not influence evaluation behavior.  It is generally preferable to make proofs opaque when possible, as this enforces a kind of modularity in the code to follow, preventing it from depending on any details of the proof. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">Bottom</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">Bottom</span> : <span class="id" title="var">computation</span> <span class="id" title="var">A</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> : <span class="id" title="var">nat</span> =&gt; @<span class="id" title="var">None</span> <span class="id" title="var">A</span>); <span class="id" title="tactic">abstract</span> <span class="id" title="var">run</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <span class="id" title="var">run_Bottom</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">v</span>, ~<span class="id" title="var">run</span> <span class="id" title="var">Bottom</span> <span class="id" title="var">v</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">run</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Bottom</span>.<br/>

<br/>
</div>

<div class="doc">
A slightly more complicated example is <span class="inlinecode"><span class="id" title="definition">Return</span></span>, which gives the same terminating answer at every approximation level. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">Return</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">v</span> : <span class="id" title="var">A</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">Return</span> : <span class="id" title="var">computation</span> <span class="id" title="var">A</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">exists</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">Some</span> <span class="id" title="var">v</span>); <span class="id" title="tactic">abstract</span> <span class="id" title="var">run</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <span class="id" title="var">run_Return</span> : <span class="id" title="var">run</span> <span class="id" title="var">Return</span> <span class="id" title="var">v</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">run</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Return</span>.<br/>

<br/>
</div>

<div class="doc">
The name <span class="inlinecode"><span class="id" title="definition">Return</span></span> was meant to be suggestive of the standard operations of monads.  The other standard operation is <span class="inlinecode"><span class="id" title="keyword">Bind</span></span>, which lets us run one computation and, if it terminates, pass its result off to another computation.  We implement bind using the notation <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode">(<span class="id" title="variable">x</span>,</span> <span class="inlinecode"><span class="id" title="variable">y</span>)</span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="variable">e1</span></span> <span class="inlinecode"><span class="id" title="keyword">in</span></span> <span class="inlinecode"><span class="id" title="variable">e2</span></span>, for pulling apart the value <span class="inlinecode"><span class="id" title="variable">e1</span></span> which may be thought of as a pair.  The second component of a <span class="inlinecode"><span class="id" title="definition">computation</span></span> is a proof, which we do not need to mention directly in the definition of <span class="inlinecode"><span class="id" title="keyword">Bind</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="keyword">Bind</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variables</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">m1</span> : <span class="id" title="var">computation</span> <span class="id" title="var">A</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">m2</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">computation</span> <span class="id" title="var">B</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="keyword">Bind</span> : <span class="id" title="var">computation</span> <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> (<span class="id" title="var">f1</span>, <span class="id" title="var">_</span>) := <span class="id" title="var">m1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">f1</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">None</span> =&gt; <span class="id" title="var">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Some</span> <span class="id" title="var">v</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> (<span class="id" title="var">f2</span>, <span class="id" title="var">_</span>) := <span class="id" title="var">m2</span> <span class="id" title="var">v</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f2</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="tactic">abstract</span> <span class="id" title="var">run</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <span class="id" title="var">run_Bind</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">v1</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">v2</span> : <span class="id" title="var">B</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">run</span> <span class="id" title="var">m1</span> <span class="id" title="var">v1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="var">run</span> (<span class="id" title="var">m2</span> <span class="id" title="var">v1</span>) <span class="id" title="var">v2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="var">run</span> <span class="id" title="keyword">Bind</span> <span class="id" title="var">v2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">run</span>; <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">x</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">y</span> : <span class="id" title="var">nat</span> |- <span class="id" title="var">_</span> ] =&gt; <span class="id" title="tactic">exists</span> (<span class="id" title="var">max</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="var">run</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="keyword">Bind</span>.<br/>

<br/>
</div>

<div class="doc">
A simple notation lets us write <span class="inlinecode"><span class="id" title="keyword">Bind</span></span> calls the way they appear in Haskell. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;x &lt;- m1 ; m2" :=<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">Bind</span> <span class="id" title="var">m1</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">m2</span>)) (<span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70).<br/>

<br/>
</div>

<div class="doc">
We can verify that we have indeed defined a monad, by proving the standard monad laws.  Part of the exercise is choosing an appropriate notion of equality between computations.  We use "equality at all approximation levels." 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">meq</span> <span class="id" title="var">A</span> (<span class="id" title="var">m1</span> <span class="id" title="var">m2</span> : <span class="id" title="var">computation</span> <span class="id" title="var">A</span>) := <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>, <span class="id" title="var">proj1_sig</span> <span class="id" title="var">m1</span> <span class="id" title="var">n</span> = <span class="id" title="var">proj1_sig</span> <span class="id" title="var">m2</span> <span class="id" title="var">n</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">left_identity</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">computation</span> <span class="id" title="var">B</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">meq</span> (<span class="id" title="keyword">Bind</span> (<span class="id" title="var">Return</span> <span class="id" title="var">a</span>) <span class="id" title="var">f</span>) (<span class="id" title="var">f</span> <span class="id" title="var">a</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">run</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">right_identity</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> (<span class="id" title="var">m</span> : <span class="id" title="var">computation</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">meq</span> (<span class="id" title="keyword">Bind</span> <span class="id" title="var">m</span> (@<span class="id" title="var">Return</span> <span class="id" title="var">_</span>)) <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">run</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="keyword">associativity</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> (<span class="id" title="var">m</span> : <span class="id" title="var">computation</span> <span class="id" title="var">A</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">computation</span> <span class="id" title="var">B</span>) (<span class="id" title="var">g</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">computation</span> <span class="id" title="var">C</span>),<br/>
&nbsp;&nbsp;<span class="id" title="var">meq</span> (<span class="id" title="keyword">Bind</span> (<span class="id" title="keyword">Bind</span> <span class="id" title="var">m</span> <span class="id" title="var">f</span>) <span class="id" title="var">g</span>) (<span class="id" title="keyword">Bind</span> <span class="id" title="var">m</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="keyword">Bind</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) <span class="id" title="var">g</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="var">run</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Now we come to the piece most directly inspired by domain theory.  We want to support general recursive function definitions, but domain theory tells us that not all definitions are reasonable; some fail to be <i>continuous</i> and thus represent unrealizable computations.  To formalize an analogous notion of continuity for our non-termination monad, we write down the approximation relation on computation results that we have had in mind all along. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">lattice</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">leq</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">option</span> <span class="id" title="var">A</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">forall</span> <span class="id" title="var">v</span>, <span class="id" title="var">x</span> = <span class="id" title="var">Some</span> <span class="id" title="var">v</span> -&gt; <span class="id" title="var">y</span> = <span class="id" title="var">Some</span> <span class="id" title="var">v</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">lattice</span>.<br/>

<br/>
</div>

<div class="doc">
We now have the tools we need to define a new <span class="inlinecode"><span class="id" title="keyword">Fix</span></span> combinator that, unlike the one we saw in the prior section, does not require a termination proof, and in fact admits recursive definition of functions that fail to terminate on some or all inputs. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="keyword">Fix</span>.<br/>

<br/>
</div>

<div class="doc">
First, we have the function domain and range types. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variables</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>.<br/>

<br/>
</div>

<div class="doc">
Next comes the function body, which is written as though it can be parameterized over itself, for recursive calls. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">f</span> : (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">computation</span> <span class="id" title="var">B</span>) -&gt; (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">computation</span> <span class="id" title="var">B</span>).<br/>

<br/>
</div>

<div class="doc">
Finally, we impose an obligation to prove that the body <span class="inlinecode"><span class="id" title="variable">f</span></span> is continuous.  That is, when <span class="inlinecode"><span class="id" title="variable">f</span></span> terminates according to one recursive version of itself, it also terminates with the same result at the same approximation level when passed a recursive version that refines the original, according to <span class="inlinecode"><span class="id" title="definition">leq</span></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">f_continuous</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">v</span> <span class="id" title="var">v1</span> <span class="id" title="var">x</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">runTo</span> (<span class="id" title="var">f</span> <span class="id" title="var">v1</span> <span class="id" title="var">x</span>) <span class="id" title="var">n</span> <span class="id" title="var">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="keyword">forall</span> (<span class="id" title="var">v2</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">computation</span> <span class="id" title="var">B</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">leq</span> (<span class="id" title="var">proj1_sig</span> (<span class="id" title="var">v1</span> <span class="id" title="var">x</span>) <span class="id" title="var">n</span>) (<span class="id" title="var">proj1_sig</span> (<span class="id" title="var">v2</span> <span class="id" title="var">x</span>) <span class="id" title="var">n</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="var">runTo</span> (<span class="id" title="var">f</span> <span class="id" title="var">v2</span> <span class="id" title="var">x</span>) <span class="id" title="var">n</span> <span class="id" title="var">v</span>.<br/>

<br/>
</div>

<div class="doc">
The computational part of the <span class="inlinecode"><span class="id" title="keyword">Fix</span></span> combinator is easy to define.  At approximation level 0, we diverge; at higher levels, we run the body with a functional argument drawn from the next lower level. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">Fix'</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) : <span class="id" title="var">computation</span> <span class="id" title="var">B</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="var">Bottom</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="var">f</span> (<span class="id" title="var">Fix'</span> <span class="id" title="var">n'</span>) <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Now it is straightforward to package <span class="inlinecode"><span class="id" title="definition">Fix'</span></span> as a computation combinator <span class="inlinecode"><span class="id" title="keyword">Fix</span></span>. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Extern</span> 1 (<span class="id" title="var">_</span> &gt;= <span class="id" title="var">_</span>) =&gt; <span class="id" title="tactic">omega</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Unfold</span> <span class="id" title="var">leq</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Fix'_ok</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">steps</span> <span class="id" title="var">n</span> <span class="id" title="var">x</span> <span class="id" title="var">v</span>, <span class="id" title="var">proj1_sig</span> (<span class="id" title="var">Fix'</span> <span class="id" title="var">n</span> <span class="id" title="var">x</span>) <span class="id" title="var">steps</span> = <span class="id" title="var">Some</span> <span class="id" title="var">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">n'</span>, <span class="id" title="var">n'</span> &gt;= <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="var">proj1_sig</span> (<span class="id" title="var">Fix'</span> <span class="id" title="var">n'</span> <span class="id" title="var">x</span>) <span class="id" title="var">steps</span> = <span class="id" title="var">Some</span> <span class="id" title="var">v</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">runTo</span> <span class="id" title="keyword">in</span> *; <span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>; <span class="id" title="var">crush</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">H</span> : <span class="id" title="var">_</span> &gt;= <span class="id" title="var">_</span> |- <span class="id" title="var">_</span> ] =&gt; <span class="id" title="tactic">inversion</span> <span class="id" title="var">H</span>; <span class="id" title="var">crush</span>; <span class="id" title="tactic">eauto</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">Fix'_ok</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Extern</span> 1 (<span class="id" title="var">proj1_sig</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> = <span class="id" title="var">_</span>) =&gt; <span class="id" title="tactic">simpl</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="var">proj1_sig</span> ?<span class="id" title="var">E</span> <span class="id" title="var">_</span> = <span class="id" title="var">_</span> ] =&gt; <span class="id" title="tactic">eapply</span> (<span class="id" title="var">proj2_sig</span> <span class="id" title="var">E</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="keyword">Fix</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">computation</span> <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">exists</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> =&gt; <span class="id" title="var">proj1_sig</span> (<span class="id" title="var">Fix'</span> <span class="id" title="var">n</span> <span class="id" title="var">x</span>) <span class="id" title="var">n</span>); <span class="id" title="tactic">abstract</span> <span class="id" title="var">run</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Finally, we can prove that <span class="inlinecode"><span class="id" title="keyword">Fix</span></span> obeys the expected computation rule. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <span class="id" title="var">run_Fix</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">v</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">run</span> (<span class="id" title="var">f</span> <span class="id" title="keyword">Fix</span> <span class="id" title="var">x</span>) <span class="id" title="var">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="var">run</span> (<span class="id" title="keyword">Fix</span> <span class="id" title="var">x</span>) <span class="id" title="var">v</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">run</span>; <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ <span class="id" title="var">n</span> : <span class="id" title="var">nat</span> |- <span class="id" title="var">_</span> ] =&gt; <span class="id" title="tactic">exists</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>); <span class="id" title="tactic">eauto</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="keyword">Fix</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
After all that work, it is now fairly painless to define a version of <span class="inlinecode"><span class="id" title="definition">mergeSort</span></span> that requires no proof of termination.  We appeal to a program-specific tactic whose definition is hidden here but present in the book source. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">mergeSort'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span>, (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>) -&gt; <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">computation</span> (<span class="id" title="var">list</span> <span class="id" title="var">A</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> <span class="id" title="var">le</span> =&gt; <span class="id" title="keyword">Fix</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> (<span class="id" title="var">mergeSort</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">computation</span> (<span class="id" title="var">list</span> <span class="id" title="var">A</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">ls</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">le_lt_dec</span> 2 (<span class="id" title="var">length</span> <span class="id" title="var">ls</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="keyword">let</span> <span class="id" title="var">lss</span> := <span class="id" title="tactic">split</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ls1</span> &lt;- <span class="id" title="var">mergeSort</span> (<span class="id" title="var">fst</span> <span class="id" title="var">lss</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ls2</span> &lt;- <span class="id" title="var">mergeSort</span> (<span class="id" title="var">snd</span> <span class="id" title="var">lss</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Return</span> (<span class="id" title="var">merge</span> <span class="id" title="var">le</span> <span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">Return</span> <span class="id" title="var">ls</span>) <span class="id" title="var">_</span>); <span class="id" title="tactic">abstract</span> <span class="id" title="var">mergeSort'</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Furthermore, "running" <span class="inlinecode"><span class="id" title="definition">mergeSort'</span></span> on concrete inputs is as easy as choosing a sufficiently high approximation level and letting Coq's computation rules do the rest.  Contrast this with the proof work that goes into deriving an evaluation fact for a deeply embedded language, with one explicit proof rule application per execution step. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">test_mergeSort'</span> : <span class="id" title="var">run</span> (<span class="id" title="var">mergeSort'</span> <span class="id" title="var">leb</span> (1 :: 2 :: 36 :: 8 :: 19 :: <span class="id" title="var">nil</span>))<br/>
&nbsp;&nbsp;(1 :: 2 :: 8 :: 19 :: 36 :: <span class="id" title="var">nil</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> 4; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
There is another benefit of our new <span class="inlinecode"><span class="id" title="keyword">Fix</span></span> compared with the one we used in the previous section: we can now write recursive functions that sometimes fail to terminate, without losing easy reasoning principles for the terminating cases.  Consider this simple example, which appeals to another tactic whose definition we elide here. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">looper</span> : <span class="id" title="var">bool</span> -&gt; <span class="id" title="var">computation</span> <span class="id" title="var">unit</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">Fix</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">looper</span> (<span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">b</span> <span class="id" title="keyword">then</span> <span class="id" title="var">Return</span> <span class="id" title="var">tt</span> <span class="id" title="keyword">else</span> <span class="id" title="var">looper</span> <span class="id" title="var">b</span>) <span class="id" title="var">_</span>); <span class="id" title="tactic">abstract</span> <span class="id" title="var">looper</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">test_looper</span> : <span class="id" title="var">run</span> (<span class="id" title="var">looper</span> <span class="id" title="var">true</span>) <span class="id" title="var">tt</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> 1; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
As before, proving outputs for specific inputs is as easy as demonstrating a high enough approximation level.

<div class="paragraph"> </div>

   There are other theorems that are important to prove about combinators like <span class="inlinecode"><span class="id" title="definition">Return</span></span>, <span class="inlinecode"><span class="id" title="keyword">Bind</span></span>, and <span class="inlinecode"><span class="id" title="keyword">Fix</span></span>.  In general, for a computation <span class="inlinecode"><span class="id" title="variable">c</span></span>, we sometimes have a hypothesis proving <span class="inlinecode"><span class="id" title="definition">run</span></span> <span class="inlinecode"><span class="id" title="variable">c</span></span> <span class="inlinecode"><span class="id" title="variable">v</span></span> for some <span class="inlinecode"><span class="id" title="variable">v</span></span>, and we want to perform inversion to deduce what <span class="inlinecode"><span class="id" title="variable">v</span></span> must be.  Each combinator should ideally have a theorem of that kind, for <span class="inlinecode"><span class="id" title="variable">c</span></span> built directly from that combinator.  We have omitted such theorems here, but they are not hard to prove.  In general, the domain theory-inspired approach avoids the type-theoretic "gotchas" that tend to show up in approaches that try to mix normal Coq computation with explicit syntax types.  The next section of this chapter demonstrates two alternate approaches of that sort.  In the final section of the chapter, we review the pros and cons of the different choices, coming to the conclusion that none of them is obviously better than any one of the others for all situations. 
<div class="paragraph"> </div>

<a name="lab36"></a><h1 class="section">Co-Inductive Non-Termination Monads</h1>

<div class="paragraph"> </div>

 There are two key downsides to both of the previous approaches: both require unusual syntax based on explicit calls to fixpoint combinators, and both generate immediate proof obligations about the bodies of recursive definitions.  In Chapter 5, we have already seen how co-inductive types support recursive definitions that exhibit certain well-behaved varieties of non-termination.  It turns out that we can leverage that co-induction support for encoding of general recursive definitions, by adding layers of co-inductive syntax.  In effect, we mix elements of shallow and deep embeddings.

<div class="paragraph"> </div>

   Our first example of this kind, proposed by Capretta, defines a silly-looking type of thunks; that is, computations that may be forced to yield results, if they terminate. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">CoInductive</span> <span class="id" title="var">thunk</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">Answer</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">thunk</span> <span class="id" title="var">A</span><br/>
| <span class="id" title="var">Think</span> : <span class="id" title="var">thunk</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">thunk</span> <span class="id" title="var">A</span>.<br/>

<br/>
</div>

<div class="doc">
A computation is either an immediate <span class="inlinecode"><span class="id" title="constructor">Answer</span></span> or another computation wrapped inside <span class="inlinecode"><span class="id" title="constructor">Think</span></span>.  Since <span class="inlinecode"><span class="id" title="inductive">thunk</span></span> is co-inductive, every <span class="inlinecode"><span class="id" title="inductive">thunk</span></span> type is inhabited by an infinite nesting of <span class="inlinecode"><span class="id" title="constructor">Think</span></span>s, standing for non-termination.  Terminating results are <span class="inlinecode"><span class="id" title="constructor">Answer</span></span> wrapped inside some finite number of <span class="inlinecode"><span class="id" title="constructor">Think</span></span>s.

<div class="paragraph"> </div>

   Why bother to write such a strange definition?  The definition of <span class="inlinecode"><span class="id" title="inductive">thunk</span></span> is motivated by the ability it gives us to define a "bind" operation, similar to the one we defined in the previous section. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">CoFixpoint</span> <span class="id" title="var">TBind</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> (<span class="id" title="var">m1</span> : <span class="id" title="var">thunk</span> <span class="id" title="var">A</span>) (<span class="id" title="var">m2</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">thunk</span> <span class="id" title="var">B</span>) : <span class="id" title="var">thunk</span> <span class="id" title="var">B</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">m1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Answer</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">m2</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Think</span> <span class="id" title="var">m1'</span> =&gt; <span class="id" title="var">Think</span> (<span class="id" title="var">TBind</span> <span class="id" title="var">m1'</span> <span class="id" title="var">m2</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Note that the definition would violate the co-recursion guardedness restriction if we left out the seemingly superfluous <span class="inlinecode"><span class="id" title="constructor">Think</span></span> on the righthand side of the second <span class="inlinecode"><span class="id" title="keyword">match</span></span> branch.

<div class="paragraph"> </div>

   We can prove that <span class="inlinecode"><span class="id" title="constructor">Answer</span></span> and <span class="inlinecode"><span class="id" title="definition">TBind</span></span> form a monad for <span class="inlinecode"><span class="id" title="inductive">thunk</span></span>.  The proof is omitted here but present in the book source.  As usual for this sort of proof, a key element is choosing an appropriate notion of equality for <span class="inlinecode"><span class="id" title="inductive">thunk</span></span>s. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
In the proofs to follow, we will need a function similar to one we saw in Chapter 5, to pull apart and reassemble a <span class="inlinecode"><span class="id" title="inductive">thunk</span></span> in a way that provokes reduction of co-recursive calls. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">frob</span> <span class="id" title="var">A</span> (<span class="id" title="var">m</span> : <span class="id" title="var">thunk</span> <span class="id" title="var">A</span>) : <span class="id" title="var">thunk</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Answer</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">Answer</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Think</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">Think</span> <span class="id" title="var">m'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">frob_eq</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> (<span class="id" title="var">m</span> : <span class="id" title="var">thunk</span> <span class="id" title="var">A</span>), <span class="id" title="var">frob</span> <span class="id" title="var">m</span> = <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">m</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
As a simple example, here is how we might define a tail-recursive factorial function. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">CoFixpoint</span> <span class="id" title="var">fact</span> (<span class="id" title="var">n</span> <span class="id" title="var">acc</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">thunk</span> <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="var">Answer</span> <span class="id" title="var">acc</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="var">Think</span> (<span class="id" title="var">fact</span> <span class="id" title="var">n'</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span> * <span class="id" title="var">acc</span>))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
To test our definition, we need an evaluation relation that characterizes results of evaluating <span class="inlinecode"><span class="id" title="inductive">thunk</span></span>s. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="tactic">eval</span> <span class="id" title="var">A</span> : <span class="id" title="var">thunk</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
| <span class="id" title="var">EvalAnswer</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="tactic">eval</span> (<span class="id" title="var">Answer</span> <span class="id" title="var">x</span>) <span class="id" title="var">x</span><br/>
| <span class="id" title="var">EvalThink</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">m</span> <span class="id" title="var">x</span>, <span class="id" title="tactic">eval</span> <span class="id" title="var">m</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="tactic">eval</span> (<span class="id" title="var">Think</span> <span class="id" title="var">m</span>) <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Hint Rewrite</span> <span class="id" title="var">frob_eq</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">eval_frob</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> (<span class="id" title="var">c</span> : <span class="id" title="var">thunk</span> <span class="id" title="var">A</span>) <span class="id" title="var">x</span>,<br/>
&nbsp;&nbsp;<span class="id" title="tactic">eval</span> (<span class="id" title="var">frob</span> <span class="id" title="var">c</span>) <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;-&gt; <span class="id" title="tactic">eval</span> <span class="id" title="var">c</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eval_fact</span> : <span class="id" title="tactic">eval</span> (<span class="id" title="var">fact</span> 5 1) 120.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<span class="id" title="tactic">apply</span> <span class="id" title="var">eval_frob</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">constructor</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We need to apply constructors of <span class="inlinecode"><span class="id" title="tactic">eval</span></span> explicitly, but the process is easy to automate completely for concrete input programs.

<div class="paragraph"> </div>

   Now consider another very similar definition, this time of a Fibonacci number function. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;x &lt;- m1 ; m2" :=<br/>
&nbsp;&nbsp;(<span class="id" title="var">TBind</span> <span class="id" title="var">m1</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">m2</span>)) (<span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70).<br/>

<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="keyword">CoFixpoint</span> <span class="id" title="definition">fib</span> (<span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>) : <span class="id" title="inductive">thunk</span> <span class="id" title="inductive">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="variable">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="constructor">Answer</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| 1 =&gt; <span class="id" title="constructor">Answer</span> 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="variable">n1</span> &lt;- <span class="id" title="definition">fib</span> (<span class="id" title="definition">pred</span> <span class="id" title="variable">n</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="variable">n2</span> &lt;- <span class="id" title="definition">fib</span> (<span class="id" title="definition">pred</span> (<span class="id" title="definition">pred</span> <span class="id" title="variable">n</span>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="constructor">Answer</span> (<span class="id" title="variable">n1</span> + <span class="id" title="variable">n2</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Coq complains that the guardedness condition is violated.  The two recursive calls are immediate arguments to <span class="inlinecode"><span class="id" title="definition">TBind</span></span>, but <span class="inlinecode"><span class="id" title="definition">TBind</span></span> is not a constructor of <span class="inlinecode"><span class="id" title="inductive">thunk</span></span>.  Rather, it is a defined function.  This example shows a very serious limitation of <span class="inlinecode"><span class="id" title="inductive">thunk</span></span> for traditional functional programming: it is not, in general, possible to make recursive calls and then make further recursive calls, depending on the first call's result.  The <span class="inlinecode"><span class="id" title="definition">fact</span></span> example succeeded because it was already tail recursive, meaning no further computation is needed after a recursive call.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

I know no easy fix for this problem of <span class="inlinecode"><span class="id" title="inductive">thunk</span></span>, but we can define an alternate co-inductive monad that avoids the problem, based on a proposal by Megacz.  We ran into trouble because <span class="inlinecode"><span class="id" title="definition">TBind</span></span> was not a constructor of <span class="inlinecode"><span class="id" title="inductive">thunk</span></span>, so let us define a new type family where "bind" is a constructor. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">CoInductive</span> <span class="id" title="var">comp</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">Ret</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">comp</span> <span class="id" title="var">A</span><br/>
| <span class="id" title="var">Bnd</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">B</span>, <span class="id" title="var">comp</span> <span class="id" title="var">B</span> -&gt; (<span class="id" title="var">B</span> -&gt; <span class="id" title="var">comp</span> <span class="id" title="var">A</span>) -&gt; <span class="id" title="var">comp</span> <span class="id" title="var">A</span>.<br/>

<br/>
</div>

<div class="doc">
This example shows off Coq's support for <i>recursively non-uniform parameters</i>, as in the case of the parameter <span class="inlinecode"><span class="id" title="variable">A</span></span> declared above, where each constructor's type ends in <span class="inlinecode"><span class="id" title="inductive">comp</span></span> <span class="inlinecode"><span class="id" title="variable">A</span></span>, but there is a recursive use of <span class="inlinecode"><span class="id" title="inductive">comp</span></span> with a different parameter <span class="inlinecode"><span class="id" title="variable">B</span></span>.  Beside that technical wrinkle, we see the simplest possible definition of a monad, via a type whose two constructors are precisely the monad operators.

<div class="paragraph"> </div>

   It is easy to define the semantics of terminating <span class="inlinecode"><span class="id" title="inductive">comp</span></span> computations. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">exec</span> <span class="id" title="var">A</span> : <span class="id" title="var">comp</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
| <span class="id" title="var">ExecRet</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">exec</span> (<span class="id" title="var">Ret</span> <span class="id" title="var">x</span>) <span class="id" title="var">x</span><br/>
| <span class="id" title="var">ExecBnd</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">B</span> (<span class="id" title="var">c</span> : <span class="id" title="var">comp</span> <span class="id" title="var">B</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">comp</span> <span class="id" title="var">A</span>) <span class="id" title="var">x1</span> <span class="id" title="var">x2</span>, <span class="id" title="var">exec</span> (<span class="id" title="var">A</span> := <span class="id" title="var">B</span>) <span class="id" title="var">c</span> <span class="id" title="var">x1</span><br/>
&nbsp;&nbsp;-&gt; <span class="id" title="var">exec</span> (<span class="id" title="var">f</span> <span class="id" title="var">x1</span>) <span class="id" title="var">x2</span><br/>
&nbsp;&nbsp;-&gt; <span class="id" title="var">exec</span> (<span class="id" title="var">Bnd</span> <span class="id" title="var">c</span> <span class="id" title="var">f</span>) <span class="id" title="var">x2</span>.<br/>

<br/>
</div>

<div class="doc">
We can also prove that <span class="inlinecode"><span class="id" title="constructor">Ret</span></span> and <span class="inlinecode"><span class="id" title="constructor">Bnd</span></span> form a monad according to a notion of <span class="inlinecode"><span class="id" title="inductive">comp</span></span> equality based on <span class="inlinecode"><span class="id" title="inductive">exec</span></span>, but we omit details here; they are in the book source at this point. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Not only can we define the Fibonacci function with the new monad, but even our running example of merge sort becomes definable.  By shadowing our previous notation for "bind," we can write almost exactly the same code as in our previous <span class="inlinecode"><span class="id" title="definition">mergeSort'</span></span> definition, but with less syntactic clutter. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;x &lt;- m1 ; m2" := (<span class="id" title="var">Bnd</span> <span class="id" title="var">m1</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">m2</span>)).<br/>

<br/>
<span class="id" title="keyword">CoFixpoint</span> <span class="id" title="var">mergeSort''</span> <span class="id" title="var">A</span> (<span class="id" title="var">le</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">bool</span>) (<span class="id" title="var">ls</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">comp</span> (<span class="id" title="var">list</span> <span class="id" title="var">A</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">le_lt_dec</span> 2 (<span class="id" title="var">length</span> <span class="id" title="var">ls</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">then</span> <span class="id" title="keyword">let</span> <span class="id" title="var">lss</span> := <span class="id" title="tactic">split</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ls1</span> &lt;- <span class="id" title="var">mergeSort''</span> <span class="id" title="var">le</span> (<span class="id" title="var">fst</span> <span class="id" title="var">lss</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ls2</span> &lt;- <span class="id" title="var">mergeSort''</span> <span class="id" title="var">le</span> (<span class="id" title="var">snd</span> <span class="id" title="var">lss</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Ret</span> (<span class="id" title="var">merge</span> <span class="id" title="var">le</span> <span class="id" title="var">ls1</span> <span class="id" title="var">ls2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="var">Ret</span> <span class="id" title="var">ls</span>.<br/>

<br/>
</div>

<div class="doc">
To execute this function, we go through the usual exercise of writing a function to catalyze evaluation of co-recursive calls. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">frob'</span> <span class="id" title="var">A</span> (<span class="id" title="var">c</span> : <span class="id" title="var">comp</span> <span class="id" title="var">A</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">c</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Ret</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">Ret</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Bnd</span> <span class="id" title="var">_</span> <span class="id" title="var">c'</span> <span class="id" title="var">f</span> =&gt; <span class="id" title="var">Bnd</span> <span class="id" title="var">c'</span> <span class="id" title="var">f</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">exec_frob</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> (<span class="id" title="var">c</span> : <span class="id" title="var">comp</span> <span class="id" title="var">A</span>) <span class="id" title="var">x</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">exec</span> (<span class="id" title="var">frob'</span> <span class="id" title="var">c</span>) <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;-&gt; <span class="id" title="var">exec</span> <span class="id" title="var">c</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">c</span>; <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Now the same sort of proof script that we applied for testing <span class="inlinecode"><span class="id" title="inductive">thunk</span></span>s will get the job done. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">test_mergeSort''</span> : <span class="id" title="var">exec</span> (<span class="id" title="var">mergeSort''</span> <span class="id" title="var">leb</span> (1 :: 2 :: 36 :: 8 :: 19 :: <span class="id" title="var">nil</span>))<br/>
&nbsp;&nbsp;(1 :: 2 :: 8 :: 19 :: 36 :: <span class="id" title="var">nil</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> (<span class="id" title="tactic">apply</span> <span class="id" title="var">exec_frob</span>; <span class="id" title="tactic">simpl</span>; <span class="id" title="tactic">econstructor</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Have we finally reached the ideal solution for encoding general recursive definitions, with minimal hassle in syntax and proof obligations?  Unfortunately, we have not, as <span class="inlinecode"><span class="id" title="inductive">comp</span></span> has a serious expressivity weakness.  Consider the following definition of a curried addition function: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">curriedAdd</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) := <span class="id" title="var">Ret</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">Ret</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>)).<br/>

<br/>
</div>

<div class="doc">
This definition works fine, but we run into trouble when we try to apply it in a trivial way.
<br/>
<span class="inlinecode"><span class="id" title="keyword">Definition</span> <span class="id" title="definition">testCurriedAdd</span> := <span class="id" title="constructor">Bnd</span> (<span class="id" title="definition">curriedAdd</span> 2) (<span class="id" title="keyword">fun</span> <span class="id" title="variable">f</span> =&gt; <span class="id" title="variable">f</span> 3).
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
Error: Universe inconsistency.
</pre>

<div class="paragraph"> </div>

The problem has to do with rules for inductive definitions that we will study in more detail in Chapter 12.  Briefly, recall that the type of the constructor <span class="inlinecode"><span class="id" title="constructor">Bnd</span></span> quantifies over a type <span class="inlinecode"><span class="id" title="variable">B</span></span>.  To make <span class="inlinecode"><span class="id" title="definition">testCurriedAdd</span></span> work, we would need to instantiate <span class="inlinecode"><span class="id" title="variable">B</span></span> as <span class="inlinecode"><span class="id" title="inductive">nat</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="inductive">comp</span></span> <span class="inlinecode"><span class="id" title="inductive">nat</span></span>.  However, Coq enforces a  that (roughly) no quantifier in an inductive or co-inductive type's definition may ever be instantiated with a term that contains the type being defined.  Chapter 12 presents the exact mechanism by which this restriction is enforced, but for now our conclusion is that <span class="inlinecode"><span class="id" title="inductive">comp</span></span> is fatally flawed as a way of encoding interesting higher-order functional programs that use general recursion. 
<div class="paragraph"> </div>

<a name="lab37"></a><h1 class="section">Comparing the Alternatives</h1>

<div class="paragraph"> </div>

 We have seen four different approaches to encoding general recursive definitions in Coq.  Among them there is no clear champion that dominates the others in every important way.  Instead, we close the chapter by comparing the techniques along a number of dimensions.  Every technique allows recursive definitions with termination arguments that go beyond Coq's built-in termination checking, so we must turn to subtler points to highlight differences.

<div class="paragraph"> </div>

   One useful property is automatic integration with normal Coq programming.  That is, we would like the type of a function to be the same, whether or not that function is defined using an interesting recursion pattern.  Only the first of the four techniques, well-founded recursion, meets this criterion.  It is also the only one of the four to meet the related criterion that evaluation of function calls can take place entirely inside Coq's built-in computation machinery.  The monad inspired by domain theory occupies some middle ground in this dimension, since generally standard computation is enough to evaluate a term once a high enough approximation level is provided.

<div class="paragraph"> </div>

   Another useful property is that a function and its termination argument may be developed separately.  We may even want to define functions that fail to terminate on some or all inputs.  The well-founded recursion technique does not have this property, but the other three do.

<div class="paragraph"> </div>

   One minor plus is the ability to write recursive definitions in natural syntax, rather than with calls to higher-order combinators.  This downside of the first two techniques is actually rather easy to get around using Coq's notation mechanism, though we leave the details as an exercise for the reader.  (For this and other details of notations, see Chapter 12 of the Coq 8.4 manual.)

<div class="paragraph"> </div>

   The first two techniques impose proof obligations that are more basic than termination arguments, where well-founded recursion requires a proof of extensionality and domain-theoretic recursion requires a proof of continuity.  A function may not be defined, and thus may not be computed with, until these obligations are proved.  The co-inductive techniques avoid this problem, as recursive definitions may be made without any proof obligations.

<div class="paragraph"> </div>

   We can also consider support for common idioms in functional programming.  For instance, the <span class="inlinecode"><span class="id" title="inductive">thunk</span></span> monad effectively only supports recursion that is tail recursion, while the others allow arbitrary recursion schemes.

<div class="paragraph"> </div>

   On the other hand, the <span class="inlinecode"><span class="id" title="inductive">comp</span></span> monad does not support the effective mixing of higher-order functions and general recursion, while all the other techniques do.  For instance, we can finish the failed <span class="inlinecode"><span class="id" title="definition">curriedAdd</span></span> example in the domain-theoretic monad. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">curriedAdd'</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) := <span class="id" title="var">Return</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">Return</span> (<span class="id" title="var">n</span> + <span class="id" title="var">m</span>)).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">testCurriedAdd</span> := <span class="id" title="keyword">Bind</span> (<span class="id" title="var">curriedAdd'</span> 2) (<span class="id" title="keyword">fun</span> <span class="id" title="var">f</span> =&gt; <span class="id" title="var">f</span> 3).<br/>

<br/>
</div>

<div class="doc">
The same techniques also apply to more interesting higher-order functions like list map, and, as in all four techniques, we can mix primitive and general recursion, preferring the former when possible to avoid proof obligations. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">map</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">computation</span> <span class="id" title="var">B</span>) (<span class="id" title="var">ls</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">computation</span> (<span class="id" title="var">list</span> <span class="id" title="var">B</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt; <span class="id" title="var">Return</span> <span class="id" title="var">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> :: <span class="id" title="var">ls'</span> =&gt; <span class="id" title="keyword">Bind</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x'</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Bind</span> (<span class="id" title="var">map</span> <span class="id" title="var">f</span> <span class="id" title="var">ls'</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">ls''</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Return</span> (<span class="id" title="var">x'</span> :: <span class="id" title="var">ls''</span>)))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">test_map</span> : <span class="id" title="var">run</span> (<span class="id" title="var">map</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">Return</span> (<span class="id" title="var">S</span> <span class="id" title="var">x</span>)) (1 :: 2 :: 3 :: <span class="id" title="var">nil</span>))<br/>
&nbsp;&nbsp;(2 :: 3 :: 4 :: <span class="id" title="var">nil</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> 1; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
One further disadvantage of <span class="inlinecode"><span class="id" title="inductive">comp</span></span> is that we cannot prove an inversion lemma for executions of <span class="inlinecode"><span class="id" title="keyword">Bind</span></span> without appealing to an <i>axiom</i>, a logical complication that we discuss at more length in Chapter 12.  The other three techniques allow proof of all the important theorems within the normal logic of Coq.

<div class="paragraph"> </div>

Perhaps one theme of our comparison is that one must trade off between, on one hand, functional programming expressiveness and compatibility with normal Coq types and computation; and, on the other hand, the level of proof obligations one is willing to handle at function definition time. 
</div>
<div class="code">
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>