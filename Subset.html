<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Subset</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Subset</h1>

<div class="code">

<br/>

<br/>

<br/>
</div>

<div class="doc">
 
<div class="paragraph"> </div>

 So far, we have seen many examples of what we might call "classical program verification."  We write programs, write their specifications, and then prove that the programs satisfy their specifications.  The programs that we have written in Coq have been normal functional programs that we could just as well have written in Haskell or ML.  In this chapter, we start investigating uses of <i>dependent types</i> to integrate programming, specification, and proving into a single phase.  The techniques we will learn make it possible to reduce the cost of program verification dramatically. 
<div class="paragraph"> </div>

<a name="lab112"></a><h1 class="section">Introducing Subset Types</h1>

<div class="paragraph"> </div>

 Let us consider several ways of implementing the natural number predecessor function.  We start by displaying the definition from the standard library: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">pred</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="definition">pred</span> = <span class="id" title="keyword">fun</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span> =&gt; <span class="id" title="keyword">match</span> <span class="id" title="variable">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="variable">S</span> <span class="id" title="variable">u</span> =&gt; <span class="id" title="variable">u</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="inductive">nat</span> -&gt; <span class="id" title="inductive">nat</span><br/>
&nbsp;
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

We can use a new command, <span class="inlinecode"><span class="id" title="keyword">Extraction</span></span>, to produce an OCaml version of this function. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Extraction</span> <span class="id" title="var">pred</span>.<br/>

<br/>
</div>

<div class="doc">
<pre>
(** val pred : nat -&gt; nat *</pre>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">let</span> <span class="id" title="var">pred</span> = <span class="id" title="var">function</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span> -&gt; <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">u</span> -&gt; <span class="id" title="var">u</span><br/>
&gt;&gt;<br/>
*)<br/>
<br/>
</div>

<div class="doc">
Returning 0 as the predecessor of 0 can come across as somewhat of a hack.  In some situations, we might like to be sure that we never try to take the predecessor of 0.  We can enforce this by giving <span class="inlinecode"><span class="id" title="definition">pred</span></span> a stronger, dependent type. 
</div>
<div class="code">
<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">zgtz</span> : 0 &gt; 0 -&gt; <span class="id" title="var">False</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pred_strong1</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">n</span> &gt; 0 -&gt; <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">pf</span> : 0 &gt; 0 =&gt; <span class="id" title="keyword">match</span> <span class="id" title="var">zgtz</span> <span class="id" title="var">pf</span> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">n'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
We expand the type of <span class="inlinecode"><span class="id" title="definition">pred</span></span> to include a <i>proof</i> that its argument <span class="inlinecode"><span class="id" title="variable">n</span></span> is greater than 0.  When <span class="inlinecode"><span class="id" title="variable">n</span></span> is 0, we use the proof to derive a contradiction, which we can use to build a value of any type via a vacuous pattern match.  When <span class="inlinecode"><span class="id" title="variable">n</span></span> is a successor, we have no need for the proof and just return the answer.  The proof argument can be said to have a <i>dependent</i> type, because its type depends on the <i>value</i> of the argument <span class="inlinecode"><span class="id" title="variable">n</span></span>.

<div class="paragraph"> </div>

   Coq's <span class="inlinecode"><span class="id" title="keyword">Eval</span></span> command can execute particular invocations of <span class="inlinecode"><span class="id" title="definition">pred_strong1</span></span> just as easily as it can execute more traditional functional programs.  Note that Coq has decided that argument <span class="inlinecode"><span class="id" title="variable">n</span></span> of <span class="inlinecode"><span class="id" title="definition">pred_strong1</span></span> can be made <i>implicit</i>, since it can be deduced from the type of the second argument, so we need not write <span class="inlinecode"><span class="id" title="variable">n</span></span> in function calls. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">two_gt0</span> : 2 &gt; 0.<br/>
&nbsp;&nbsp;<span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="var">pred_strong1</span> <span class="id" title="var">two_gt0</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="inductive">nat</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

One aspect in particular of the definition of <span class="inlinecode"><span class="id" title="definition">pred_strong1</span></span> may be surprising.  We took advantage of <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>'s syntactic sugar for defining function arguments in the case of <span class="inlinecode"><span class="id" title="variable">n</span></span>, but we bound the proofs later with explicit <span class="inlinecode"><span class="id" title="keyword">fun</span></span> expressions.  Let us see what happens if we write this function in the way that at first seems most natural.

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Definition</span> <span class="id" title="definition">pred_strong1'</span> (<span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>) (<span class="id" title="variable">pf</span> : <span class="id" title="variable">n</span> &gt; 0) : <span class="id" title="inductive">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="variable">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="constructor">O</span> =&gt; <span class="id" title="keyword">match</span> <span class="id" title="lemma">zgtz</span> <span class="id" title="variable">pf</span> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="variable">S</span> <span class="id" title="variable">n'</span> =&gt; <span class="id" title="variable">n'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
Error: In environment
n : nat
pf : n &gt; 0
The term "pf" has type "n &gt; 0" while it is expected to have type 
"0 &gt; 0"
</pre>

<div class="paragraph"> </div>

The term <span class="inlinecode"><span class="id" title="lemma">zgtz</span></span> <span class="inlinecode"><span class="id" title="variable">pf</span></span> fails to type-check.  Somehow the type checker has failed to take into account information that follows from which <span class="inlinecode"><span class="id" title="keyword">match</span></span> branch that term appears in.  The problem is that, by default, <span class="inlinecode"><span class="id" title="keyword">match</span></span> does not let us use such implied information.  To get refined typing, we must always rely on <span class="inlinecode"><span class="id" title="keyword">match</span></span> annotations, either written explicitly or inferred.

<div class="paragraph"> </div>

In this case, we must use a <span class="inlinecode"><span class="id" title="keyword">return</span></span> annotation to declare the relationship between the <i>value</i> of the <span class="inlinecode"><span class="id" title="keyword">match</span></span> discriminee and the <i>type</i> of the result.  There is no annotation that lets us declare a relationship between the discriminee and the type of a variable that is already in scope; hence, we delay the binding of <span class="inlinecode"><span class="id" title="variable">pf</span></span>, so that we can use the <span class="inlinecode"><span class="id" title="keyword">return</span></span> annotation to express the needed relationship.

<div class="paragraph"> </div>

We are lucky that Coq's heuristics infer the <span class="inlinecode"><span class="id" title="keyword">return</span></span> clause (specifically, <span class="inlinecode"><span class="id" title="keyword">return</span></span> <span class="inlinecode"><span class="id" title="variable">n</span></span> <span class="inlinecode">&gt;</span> <span class="inlinecode">0</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="inductive">nat</span></span>) for us in the definition of <span class="inlinecode"><span class="id" title="definition">pred_strong1</span></span>, leading to the following elaborated code: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pred_strong1'</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">n</span> &gt; 0 -&gt; <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">return</span> <span class="id" title="var">n</span> &gt; 0 -&gt; <span class="id" title="var">nat</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">pf</span> : 0 &gt; 0 =&gt; <span class="id" title="keyword">match</span> <span class="id" title="var">zgtz</span> <span class="id" title="var">pf</span> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">n'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
By making explicit the functional relationship between value <span class="inlinecode"><span class="id" title="variable">n</span></span> and the result type of the <span class="inlinecode"><span class="id" title="keyword">match</span></span>, we guide Coq toward proper type checking.  The clause for this example follows by simple copying of the original annotation on the definition.  In general, however, the <span class="inlinecode"><span class="id" title="keyword">match</span></span> annotation inference problem is undecidable.  The known undecidable problem of <i>higher-order unification</i>  reduces to the <span class="inlinecode"><span class="id" title="keyword">match</span></span> type inference problem.  Over time, Coq is enhanced with more and more heuristics to get around this problem, but there must always exist <span class="inlinecode"><span class="id" title="keyword">match</span></span>es whose types Coq cannot infer without annotations.

<div class="paragraph"> </div>

Let us now take a look at the OCaml code Coq generates for <span class="inlinecode"><span class="id" title="definition">pred_strong1</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Extraction</span> <span class="id" title="var">pred_strong1</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<pre>
(** val pred_strong1 : nat -&gt; nat *</pre>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">let</span> <span class="id" title="var">pred_strong1</span> = <span class="id" title="var">function</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span> -&gt; <span class="id" title="tactic">assert</span> <span class="id" title="var">false</span> <br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> -&gt; <span class="id" title="var">n'</span><br/>
&gt;&gt;<br/>
*)<br/>
<br/>
</div>

<div class="doc">
The proof argument has disappeared!  We get exactly the OCaml code we would have written manually.  This is our first demonstration of the main technically interesting feature of Coq program extraction: proofs are erased systematically.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

We can reimplement our dependently typed <span class="inlinecode"><span class="id" title="definition">pred</span></span> based on <i>subset types</i>, defined in the standard library with the type family <span class="inlinecode"><span class="id" title="inductive">sig</span></span>. 
</div>
<div class="code">
<br/>
<br/>
<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">bar</span> := <span class="id" title="var">ex</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">sig</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="keyword">Inductive</span> <span class="id" title="inductive">sig</span> (<span class="id" title="variable">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="variable">P</span> : <span class="id" title="variable">A</span> -&gt; <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="constructor">exist</span> : <span class="id" title="keyword">forall</span> <span class="id" title="variable">x</span> : <span class="id" title="variable">A</span>, <span class="id" title="variable">P</span> <span class="id" title="variable">x</span> -&gt; <span class="id" title="inductive">sig</span> <span class="id" title="variable">P</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The family <span class="inlinecode"><span class="id" title="inductive">sig</span></span> is a Curry-Howard twin of <span class="inlinecode"><span class="id" title="inductive">ex</span></span>, except that <span class="inlinecode"><span class="id" title="inductive">sig</span></span> is in <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, while <span class="inlinecode"><span class="id" title="inductive">ex</span></span> is in <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.  That means that <span class="inlinecode"><span class="id" title="inductive">sig</span></span> values can survive extraction, while <span class="inlinecode"><span class="id" title="inductive">ex</span></span> proofs will always be erased.  The actual details of extraction of <span class="inlinecode"><span class="id" title="inductive">sig</span></span>s are more subtle, as we will see shortly.

<div class="paragraph"> </div>

We rewrite <span class="inlinecode"><span class="id" title="definition">pred_strong1</span></span>, using some syntactic sugar for subset types. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Locate</span> "{ _ : _ | _ }".<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="keyword">Notation</span><br/>
&nbsp;&nbsp;"{ x : A  |  P }" := <span class="id" title="inductive">sig</span> (<span class="id" title="keyword">fun</span> <span class="id" title="variable">x</span> : <span class="id" title="variable">A</span> =&gt; <span class="id" title="variable">P</span>)
<div class="paragraph"> </div>

</span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pred_strong2</span> (<span class="id" title="var">s</span> : {<span class="id" title="var">n</span> : <span class="id" title="var">nat</span> | <span class="id" title="var">n</span> &gt; 0}) : <span class="id" title="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">s</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">exist</span> <span class="id" title="var">O</span> <span class="id" title="var">pf</span> =&gt; <span class="id" title="keyword">match</span> <span class="id" title="var">zgtz</span> <span class="id" title="var">pf</span> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">exist</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) <span class="id" title="var">_</span> =&gt; <span class="id" title="var">n'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
To build a value of a subset type, we use the <span class="inlinecode"><span class="id" title="constructor">exist</span></span> constructor, and the details of how to do that follow from the output of our earlier <span class="inlinecode"><span class="id" title="keyword">Print</span></span> <span class="inlinecode"><span class="id" title="inductive">sig</span></span> command, where we elided the extra information that parameter <span class="inlinecode"><span class="id" title="variable">A</span></span> is implicit.  We need an extra <span class="inlinecode"><span class="id" title="var">_</span></span> here and not in the definition of <span class="inlinecode"><span class="id" title="definition">pred_strong2</span></span> because <i>parameters</i> of inductive types (like the predicate <span class="inlinecode"><span class="id" title="variable">P</span></span> for <span class="inlinecode"><span class="id" title="inductive">sig</span></span>) are not mentioned in pattern matching, but <i>are</i> mentioned in construction of terms (if they are not marked as implicit arguments). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="var">pred_strong2</span> (<span class="id" title="var">exist</span> <span class="id" title="var">_</span> 2 <span class="id" title="var">two_gt0</span>).<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="inductive">nat</span>
<div class="paragraph"> </div>

</span>     
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Extraction</span> <span class="id" title="var">pred_strong2</span>.<br/>

<br/>
</div>

<div class="doc">
<pre>
(** val pred_strong2 : nat -&gt; nat *</pre>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">let</span> <span class="id" title="var">pred_strong2</span> = <span class="id" title="var">function</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span> -&gt; <span class="id" title="tactic">assert</span> <span class="id" title="var">false</span> <br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> -&gt; <span class="id" title="var">n'</span><br/>
&gt;&gt;<br/>
<br/>
<span class="id" title="var">We</span> <span class="id" title="var">arrive</span> <span class="id" title="tactic">at</span> <span class="id" title="var">the</span> <span class="id" title="var">same</span> <span class="id" title="var">OCaml</span> <span class="id" title="var">code</span> <span class="id" title="keyword">as</span> <span class="id" title="var">was</span> <span class="id" title="var">extracted</span> <span class="id" title="var">from</span> [<span class="id" title="var">pred_strong1</span>], <span class="id" title="var">which</span> <span class="id" title="var">may</span> <span class="id" title="var">seem</span> <span class="id" title="var">surprising</span> <span class="id" title="tactic">at</span> <span class="id" title="tactic">first</span>. <span class="id" title="var">The</span> <span class="id" title="var">reason</span> <span class="id" title="var">is</span> <span class="id" title="var">that</span> <span class="id" title="var">a</span> <span class="id" title="var">value</span> <span class="id" title="var">of</span> [<span class="id" title="var">sig</span>] <span class="id" title="var">is</span> <span class="id" title="var">a</span> <span class="id" title="var">pair</span> <span class="id" title="var">of</span> <span class="id" title="var">two</span> <span class="id" title="var">pieces</span>, <span class="id" title="var">a</span> <span class="id" title="var">value</span> <span class="id" title="var">and</span> <span class="id" title="var">a</span> <span class="id" title="var">proof</span> <span class="id" title="var">about</span> <span class="id" title="var">it</span>. <span class="id" title="keyword">Extraction</span> <span class="id" title="var">erases</span> <span class="id" title="var">the</span> <span class="id" title="var">proof</span>, <span class="id" title="var">which</span> <span class="id" title="var">reduces</span> <span class="id" title="var">the</span> <span class="id" title="tactic">constructor</span> [<span class="id" title="var">exist</span>] <span class="id" title="var">of</span> [<span class="id" title="var">sig</span>] <span class="id" title="var">to</span> <span class="id" title="var">taking</span> <span class="id" title="var">just</span> <span class="id" title="var">a</span> <span class="id" title="var">single</span> <span class="id" title="var">argument</span>. <span class="id" title="var">An</span> <span class="id" title="var">optimization</span> <span class="id" title="var">eliminates</span> <span class="id" title="var">uses</span> <span class="id" title="var">of</span> <span class="id" title="var">datatypes</span> <span class="id" title="keyword">with</span> <span class="id" title="var">single</span> <span class="id" title="var">constructors</span> <span class="id" title="var">taking</span> <span class="id" title="var">single</span> <span class="id" title="var">arguments</span>, <span class="id" title="var">and</span> <span class="id" title="var">we</span> <span class="id" title="var">arrive</span> <span class="id" title="var">back</span> <span class="id" title="keyword">where</span> <span class="id" title="var">we</span> <span class="id" title="var">started</span>.<br/>

<br/>
<span class="id" title="var">We</span> <span class="id" title="var">can</span> <span class="id" title="var">continue</span> <span class="id" title="var">on</span> <span class="id" title="keyword">in</span> <span class="id" title="var">the</span> <span class="id" title="var">process</span> <span class="id" title="var">of</span> <span class="id" title="var">refining</span> [<span class="id" title="var">pred</span>]'<span class="id" title="var">s</span> <span class="id" title="var">type</span>. <span class="id" title="keyword">Let</span> <span class="id" title="var">us</span> <span class="id" title="tactic">change</span> <span class="id" title="var">its</span> <span class="id" title="var">result</span> <span class="id" title="var">type</span> <span class="id" title="var">to</span> <span class="id" title="var">capture</span> <span class="id" title="var">that</span> <span class="id" title="var">the</span> <span class="id" title="var">output</span> <span class="id" title="var">is</span> <span class="id" title="var">really</span> <span class="id" title="var">the</span> <span class="id" title="var">predecessor</span> <span class="id" title="var">of</span> <span class="id" title="var">the</span> <span class="id" title="var">input</span>. *)<br/>
<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pred_strong3</span> (<span class="id" title="var">s</span> : {<span class="id" title="var">n</span> : <span class="id" title="var">nat</span> | <span class="id" title="var">n</span> &gt; 0}) : {<span class="id" title="var">m</span> : <span class="id" title="var">nat</span> | <span class="id" title="var">proj1_sig</span> <span class="id" title="var">s</span> = <span class="id" title="var">S</span> <span class="id" title="var">m</span>} :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">s</span> <span class="id" title="keyword">return</span> {<span class="id" title="var">m</span> : <span class="id" title="var">nat</span> | <span class="id" title="var">proj1_sig</span> <span class="id" title="var">s</span> = <span class="id" title="var">S</span> <span class="id" title="var">m</span>} <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">exist</span> 0 <span class="id" title="var">pf</span> =&gt; <span class="id" title="keyword">match</span> <span class="id" title="var">zgtz</span> <span class="id" title="var">pf</span> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">exist</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) <span class="id" title="var">pf</span> =&gt; <span class="id" title="var">exist</span> <span class="id" title="var">_</span> <span class="id" title="var">n'</span> (<span class="id" title="var">eq_refl</span> <span class="id" title="var">_</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="var">pred_strong3</span> (<span class="id" title="var">exist</span> <span class="id" title="var">_</span> 2 <span class="id" title="var">two_gt0</span>).<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id" title="constructor">exist</span> (<span class="id" title="keyword">fun</span> <span class="id" title="variable">m</span> : <span class="id" title="inductive">nat</span> =&gt; 2 = <span class="id" title="variable">S</span> <span class="id" title="variable">m</span>) 1 (<span class="id" title="constructor">eq_refl</span> 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: {<span class="id" title="variable">m</span> : <span class="id" title="inductive">nat</span> | <span class="id" title="definition">proj1_sig</span> (<span class="id" title="constructor">exist</span> (<span class="id" title="definition">lt</span> 0) 2 <span class="id" title="lemma">two_gt0</span>) = <span class="id" title="variable">S</span> <span class="id" title="variable">m</span>}
<div class="paragraph"> </div>

</span>     
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
A value in a subset type can be thought of as a <i>dependent pair</i> (or <i>sigma type</i>) of a base value and a proof about it.  The function <span class="inlinecode"><span class="id" title="definition">proj1_sig</span></span> extracts the first component of the pair.  It turns out that we need to include an explicit <span class="inlinecode"><span class="id" title="keyword">return</span></span> clause here, since Coq's heuristics are not smart enough to propagate the result type that we wrote earlier.

<div class="paragraph"> </div>

By now, the reader is probably ready to believe that the new <span class="inlinecode"><span class="id" title="definition">pred_strong</span></span> leads to the same OCaml code as we have seen several times so far, and Coq does not disappoint. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Extraction</span> <span class="id" title="var">pred_strong3</span>.<br/>

<br/>
</div>

<div class="doc">
<pre>
(** val pred_strong3 : nat -&gt; nat *</pre>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">let</span> <span class="id" title="var">pred_strong3</span> = <span class="id" title="var">function</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">O</span> -&gt; <span class="id" title="tactic">assert</span> <span class="id" title="var">false</span> <br/>
&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> -&gt; <span class="id" title="var">n'</span><br/>
&gt;&gt;<br/>
<br/>
<span class="id" title="var">We</span> <span class="id" title="var">have</span> <span class="id" title="var">managed</span> <span class="id" title="var">to</span> <span class="id" title="var">reach</span> <span class="id" title="var">a</span> <span class="id" title="var">type</span> <span class="id" title="var">that</span> <span class="id" title="var">is</span>, <span class="id" title="keyword">in</span> <span class="id" title="var">a</span> <span class="id" title="var">formal</span> <span class="id" title="var">sense</span>, <span class="id" title="var">the</span> <span class="id" title="var">most</span> <span class="id" title="var">expressive</span> <span class="id" title="var">possible</span> <span class="id" title="keyword">for</span> [<span class="id" title="var">pred</span>]. <span class="id" title="var">Any</span> <span class="id" title="var">other</span> <span class="id" title="var">implementation</span> <span class="id" title="var">of</span> <span class="id" title="var">the</span> <span class="id" title="var">same</span> <span class="id" title="var">type</span> <span class="id" title="var">must</span> <span class="id" title="var">have</span> <span class="id" title="var">the</span> <span class="id" title="var">same</span> <span class="id" title="var">input</span>-<span class="id" title="var">output</span> <span class="id" title="var">behavior</span>. <span class="id" title="var">However</span>, <span class="id" title="var">there</span> <span class="id" title="var">is</span> <span class="id" title="var">still</span> <span class="id" title="var">room</span> <span class="id" title="keyword">for</span> <span class="id" title="var">improvement</span> <span class="id" title="keyword">in</span> <span class="id" title="var">making</span> <span class="id" title="var">this</span> <span class="id" title="var">kind</span> <span class="id" title="var">of</span> <span class="id" title="var">code</span> <span class="id" title="var">easier</span> <span class="id" title="var">to</span> <span class="id" title="var">write</span>. <span class="id" title="var">Here</span> <span class="id" title="var">is</span> <span class="id" title="var">a</span> <span class="id" title="var">version</span> <span class="id" title="var">that</span> <span class="id" title="var">takes</span> <span class="id" title="var">advantage</span> <span class="id" title="var">of</span> <span class="id" title="var">tactic</span>-<span class="id" title="var">based</span> <span class="id" title="var">theorem</span> <span class="id" title="var">proving</span>. <span class="id" title="var">We</span> <span class="id" title="var">switch</span> <span class="id" title="var">back</span> <span class="id" title="var">to</span> <span class="id" title="var">passing</span> <span class="id" title="var">a</span> <span class="id" title="var">separate</span> <span class="id" title="var">proof</span> <span class="id" title="var">argument</span> <span class="id" title="var">instead</span> <span class="id" title="var">of</span> <span class="id" title="keyword">using</span> <span class="id" title="var">a</span> <span class="id" title="var">subset</span> <span class="id" title="var">type</span> <span class="id" title="keyword">for</span> <span class="id" title="var">the</span> <span class="id" title="var">function's</span> <span class="id" title="var">input</span>, <span class="id" title="var">because</span> <span class="id" title="var">this</span> <span class="id" title="var">leads</span> <span class="id" title="var">to</span> <span class="id" title="var">cleaner</span> <span class="id" title="var">code</span>. (<span class="id" title="var">Recall</span> <span class="id" title="var">that</span> [<span class="id" title="var">False_rec</span>] <span class="id" title="var">is</span> <span class="id" title="var">the</span> [<span class="id" title="keyword">Set</span>]-<span class="id" title="keyword">level</span> <span class="id" title="tactic">induction</span> <span class="id" title="var">principle</span> <span class="id" title="keyword">for</span> [<span class="id" title="var">False</span>], <span class="id" title="var">which</span> <span class="id" title="var">can</span> <span class="id" title="var">be</span> <span class="id" title="var">used</span> <span class="id" title="var">to</span> <span class="id" title="var">produce</span> <span class="id" title="var">a</span> <span class="id" title="var">value</span> <span class="id" title="keyword">in</span> <span class="id" title="var">any</span> [<span class="id" title="keyword">Set</span>] <span class="id" title="var">given</span> <span class="id" title="var">a</span> <span class="id" title="var">proof</span> <span class="id" title="var">of</span> [<span class="id" title="var">False</span>].) *)<br/>
<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pred_strong4</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &gt; 0 -&gt; {<span class="id" title="var">m</span> : <span class="id" title="var">nat</span> | <span class="id" title="var">n</span> = <span class="id" title="var">S</span> <span class="id" title="var">m</span>}.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">False_rec</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">exist</span> <span class="id" title="var">_</span> <span class="id" title="var">n'</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>).<br/>

<br/>
</div>

<div class="doc">
We build <span class="inlinecode"><span class="id" title="definition">pred_strong4</span></span> using tactic-based proving, beginning with a <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> command that ends in a period before a definition is given.  Such a command enters the interactive proving mode, with the type given for the new identifier as our proof goal.  It may seem strange to change perspective so implicitly between programming and proving, but recall that programs and proofs are two sides of the same coin in Coq, thanks to the Curry-Howard correspondence.

<div class="paragraph"> </div>

     We do most of the work with the <span class="inlinecode"><span class="id" title="tactic">refine</span></span> tactic, to which we pass a partial "proof" of the type we are trying to prove.  There may be some pieces left to fill in, indicated by underscores.  Any underscore that Coq cannot reconstruct with type inference is added as a proof subgoal.  In this case, we have two subgoals:

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">2 <span class="id" title="keyword">subgoals</span><br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;<span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span><br/>
&nbsp;&nbsp;<span class="id" title="var">_</span> : 0 &gt; 0<br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="inductive">False</span><br/>
<br/>
<span class="id" title="keyword">subgoal</span> 2 <span class="id" title="var">is</span><br/>
<br/>
&nbsp;<span class="id" title="variable">S</span> <span class="id" title="variable">n'</span> = <span class="id" title="variable">S</span> <span class="id" title="variable">n'</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

We can see that the first subgoal comes from the second underscore passed to <span class="inlinecode"><span class="id" title="definition">False_rec</span></span>, and the second subgoal comes from the second underscore passed to <span class="inlinecode"><span class="id" title="constructor">exist</span></span>.  In the first case, we see that, though we bound the proof variable with an underscore, it is still available in our proof context.  It is hard to refer to underscore-named variables in manual proofs, but automation makes short work of them.  Both subgoals are easy to discharge that way, so let us back up and ask to prove all subgoals automatically. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Undo</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">False_rec</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">exist</span> <span class="id" title="var">_</span> <span class="id" title="var">n'</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
We end the "proof" with <span class="inlinecode"><span class="id" title="keyword">Defined</span></span> instead of <span class="inlinecode"><span class="id" title="keyword">Qed</span></span>, so that the definition we constructed remains visible.  This contrasts to the case of ending a proof with <span class="inlinecode"><span class="id" title="keyword">Qed</span></span>, where the details of the proof are hidden afterward.  (More formally, <span class="inlinecode"><span class="id" title="keyword">Defined</span></span> marks an identifier as <i>transparent</i>, allowing it to be unfolded; while <span class="inlinecode"><span class="id" title="keyword">Qed</span></span> marks an identifier as <i>opaque</i>, preventing unfolding.)  Let us see what our proof script constructed. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">pred_strong4</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="definition">pred_strong4</span> = <br/>
<span class="id" title="keyword">fun</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span> =&gt;<br/>
<span class="id" title="keyword">match</span> <span class="id" title="variable">n</span> <span class="id" title="keyword">as</span> <span class="id" title="variable">n0</span> <span class="id" title="keyword">return</span> (<span class="id" title="variable">n0</span> &gt; 0 -&gt; {<span class="id" title="variable">m</span> : <span class="id" title="inductive">nat</span> | <span class="id" title="variable">n0</span> = <span class="id" title="variable">S</span> <span class="id" title="variable">m</span>}) <span class="id" title="keyword">with</span><br/>
| 0 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> : 0 &gt; 0 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">False_rec</span> {<span class="id" title="variable">m</span> : <span class="id" title="inductive">nat</span> | 0 = <span class="id" title="variable">S</span> <span class="id" title="variable">m</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Bool.diff_false_true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Bool.absurd_eq_true</span> <span class="id" title="constructor">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Bool.diff_false_true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Bool.absurd_eq_true</span> <span class="id" title="constructor">false</span> (<span class="id" title="var">pred_strong4_subproof</span> <span class="id" title="variable">n</span> <span class="id" title="var">_</span>)))))<br/>
| <span class="id" title="variable">S</span> <span class="id" title="variable">n'</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> : <span class="id" title="variable">S</span> <span class="id" title="variable">n'</span> &gt; 0 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="constructor">exist</span> (<span class="id" title="keyword">fun</span> <span class="id" title="variable">m</span> : <span class="id" title="inductive">nat</span> =&gt; <span class="id" title="variable">S</span> <span class="id" title="variable">n'</span> = <span class="id" title="variable">S</span> <span class="id" title="variable">m</span>) <span class="id" title="variable">n'</span> (<span class="id" title="constructor">eq_refl</span> (<span class="id" title="variable">S</span> <span class="id" title="variable">n'</span>))<br/>
<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="variable">n</span> &gt; 0 -&gt; {<span class="id" title="variable">m</span> : <span class="id" title="inductive">nat</span> | <span class="id" title="variable">n</span> = <span class="id" title="variable">S</span> <span class="id" title="variable">m</span>}
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

We see the code we entered, with some proofs filled in.  The first proof obligation, the second argument to <span class="inlinecode"><span class="id" title="definition">False_rec</span></span>, is filled in with a nasty-looking proof term that we can be glad we did not enter by hand.  The second proof obligation is a simple reflexivity proof. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="var">pred_strong4</span> <span class="id" title="var">two_gt0</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id" title="constructor">exist</span> (<span class="id" title="keyword">fun</span> <span class="id" title="variable">m</span> : <span class="id" title="inductive">nat</span> =&gt; 2 = <span class="id" title="variable">S</span> <span class="id" title="variable">m</span>) 1 (<span class="id" title="constructor">eq_refl</span> 2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: {<span class="id" title="variable">m</span> : <span class="id" title="inductive">nat</span> | 2 = <span class="id" title="variable">S</span> <span class="id" title="variable">m</span>}
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

  A tactic modifier called <span class="inlinecode"><span class="id" title="tactic">abstract</span></span> can be helpful for producing shorter terms, by automatically abstracting subgoals into named lemmas. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pred_strong4'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &gt; 0 -&gt; {<span class="id" title="var">m</span> : <span class="id" title="var">nat</span> | <span class="id" title="var">n</span> = <span class="id" title="var">S</span> <span class="id" title="var">m</span>}.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">False_rec</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">exist</span> <span class="id" title="var">_</span> <span class="id" title="var">n'</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="tactic">abstract</span> <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">pred_strong4'</span>.<br/>

<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="definition">pred_strong4'</span> = <br/>
<span class="id" title="keyword">fun</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span> =&gt;<br/>
<span class="id" title="keyword">match</span> <span class="id" title="variable">n</span> <span class="id" title="keyword">as</span> <span class="id" title="variable">n0</span> <span class="id" title="keyword">return</span> (<span class="id" title="variable">n0</span> &gt; 0 -&gt; {<span class="id" title="variable">m</span> : <span class="id" title="inductive">nat</span> | <span class="id" title="variable">n0</span> = <span class="id" title="variable">S</span> <span class="id" title="variable">m</span>}) <span class="id" title="keyword">with</span><br/>
| 0 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">_H</span> : 0 &gt; 0 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">False_rec</span> {<span class="id" title="variable">m</span> : <span class="id" title="inductive">nat</span> | 0 = <span class="id" title="variable">S</span> <span class="id" title="variable">m</span>} (<span class="id" title="var">pred_strong4'_subproof</span> <span class="id" title="variable">n</span> <span class="id" title="var">_H</span>)<br/>
| <span class="id" title="variable">S</span> <span class="id" title="variable">n'</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">_H</span> : <span class="id" title="variable">S</span> <span class="id" title="variable">n'</span> &gt; 0 =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="constructor">exist</span> (<span class="id" title="keyword">fun</span> <span class="id" title="variable">m</span> : <span class="id" title="inductive">nat</span> =&gt; <span class="id" title="variable">S</span> <span class="id" title="variable">n'</span> = <span class="id" title="variable">S</span> <span class="id" title="variable">m</span>) <span class="id" title="variable">n'</span> (<span class="id" title="var">pred_strong4'_subproof0</span> <span class="id" title="variable">n</span> <span class="id" title="var">_H</span>)<br/>
<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="variable">n</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="variable">n</span> &gt; 0 -&gt; {<span class="id" title="variable">m</span> : <span class="id" title="inductive">nat</span> | <span class="id" title="variable">n</span> = <span class="id" title="variable">S</span> <span class="id" title="variable">m</span>}
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

We are almost done with the ideal implementation of dependent predecessor.  We can use Coq's syntax extension facility to arrive at code with almost no complexity beyond a Haskell or ML program with a complete specification in a comment.  In this book, we will not dwell on the details of syntax extensions; the Coq manual gives a straightforward introduction to them. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;!" := (<span class="id" title="var">False_rec</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
<span class="id" title="keyword">Notation</span> &quot;[ e ]" := (<span class="id" title="var">exist</span> <span class="id" title="var">_</span> <span class="id" title="var">e</span> <span class="id" title="var">_</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pred_strong5</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">n</span> &gt; 0 -&gt; {<span class="id" title="var">m</span> : <span class="id" title="var">nat</span> | <span class="id" title="var">n</span> = <span class="id" title="var">S</span> <span class="id" title="var">m</span>}.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; !<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; [<span class="id" title="var">n'</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
By default, notations are also used in pretty-printing terms, including results of evaluation. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="var">pred_strong5</span> <span class="id" title="var">two_gt0</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= [1]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: {<span class="id" title="variable">m</span> : <span class="id" title="inductive">nat</span> | 2 = <span class="id" title="variable">S</span> <span class="id" title="variable">m</span>}
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

  One other alternative is worth demonstrating.  Recent Coq versions include a facility called <span class="inlinecode"><span class="id" title="library">Program</span></span> that streamlines this style of definition.  Here is a complete implementation using <span class="inlinecode"><span class="id" title="library">Program</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Obligation</span> <span class="id" title="keyword">Tactic</span> := <span class="id" title="var">crush</span>.<br/>

<br/>
<span class="id" title="keyword">Program Definition</span> <span class="id" title="var">pred_strong6</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">_</span> : <span class="id" title="var">n</span> &gt; 0) : {<span class="id" title="var">m</span> : <span class="id" title="var">nat</span> | <span class="id" title="var">n</span> = <span class="id" title="var">S</span> <span class="id" title="var">m</span>} :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; <span class="id" title="var">n'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Printing the resulting definition of <span class="inlinecode"><span class="id" title="definition">pred_strong6</span></span> yields a term very similar to what we built with <span class="inlinecode"><span class="id" title="tactic">refine</span></span>.  <span class="inlinecode"><span class="id" title="library">Program</span></span> can save time in writing programs that use subset types.  Nonetheless, <span class="inlinecode"><span class="id" title="tactic">refine</span></span> is often just as effective, and <span class="inlinecode"><span class="id" title="tactic">refine</span></span> gives more control over the form the final term takes, which can be useful when you want to prove additional theorems about your definition.  <span class="inlinecode"><span class="id" title="library">Program</span></span> will sometimes insert type casts that can complicate theorem proving. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="var">pred_strong6</span> <span class="id" title="var">two_gt0</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= [1]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: {<span class="id" title="variable">m</span> : <span class="id" title="inductive">nat</span> | 2 = <span class="id" title="variable">S</span> <span class="id" title="variable">m</span>}
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

In this case, we see that the new definition yields the same computational behavior as before. 
<div class="paragraph"> </div>

<a name="lab113"></a><h1 class="section">Decidable Proposition Types</h1>

<div class="paragraph"> </div>

 There is another type in the standard library that captures the idea of program values that indicate which of two propositions is true. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">sumbool</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="keyword">Inductive</span> <span class="id" title="inductive">sumbool</span> (<span class="id" title="variable">A</span> : <span class="id" title="keyword">Prop</span>) (<span class="id" title="variable">B</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">left</span> : <span class="id" title="variable">A</span> -&gt; {<span class="id" title="variable">A</span>} + {<span class="id" title="variable">B</span>} | <span class="id" title="tactic">right</span> : <span class="id" title="variable">B</span> -&gt; {<span class="id" title="variable">A</span>} + {<span class="id" title="variable">B</span>}
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Here, the constructors of <span class="inlinecode"><span class="id" title="inductive">sumbool</span></span> have types written in terms of a registered notation for <span class="inlinecode"><span class="id" title="inductive">sumbool</span></span>, such that the result type of each constructor desugars to <span class="inlinecode"><span class="id" title="inductive">sumbool</span></span> <span class="inlinecode"><span class="id" title="variable">A</span></span> <span class="inlinecode"><span class="id" title="variable">B</span></span>.  We can define some notations of our own to make working with <span class="inlinecode"><span class="id" title="inductive">sumbool</span></span> more convenient. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;'Yes'" := (<span class="id" title="tactic">left</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
<span class="id" title="keyword">Notation</span> &quot;'No'" := (<span class="id" title="tactic">right</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
<span class="id" title="keyword">Notation</span> &quot;'Reduce' x" := (<span class="id" title="keyword">if</span> <span class="id" title="var">x</span> <span class="id" title="keyword">then</span> <span class="id" title="var">Yes</span> <span class="id" title="keyword">else</span> <span class="id" title="var">No</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50).<br/>

<br/>
</div>

<div class="doc">
The <tt>Reduce</tt> notation is notable because it demonstrates how <span class="inlinecode"><span class="id" title="keyword">if</span></span> is overloaded in Coq.  The <span class="inlinecode"><span class="id" title="keyword">if</span></span> form actually works when the test expression has any two-constructor inductive type.  Moreover, in the <span class="inlinecode"><span class="id" title="keyword">then</span></span> and <span class="inlinecode"><span class="id" title="keyword">else</span></span> branches, the appropriate constructor arguments are bound.  This is important when working with <span class="inlinecode"><span class="id" title="inductive">sumbool</span></span>s, when we want to have the proof stored in the test expression available when proving the proof obligations generated in the appropriate branch.

<div class="paragraph"> </div>

Now we can write <span class="inlinecode"><span class="id" title="definition">eq_nat_dec</span></span>, which compares two natural numbers, returning either a proof of their equality or a proof of their inequality. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">eq_nat_dec</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>, {<span class="id" title="var">n</span> = <span class="id" title="var">m</span>} + {<span class="id" title="var">n</span> &lt;&gt; <span class="id" title="var">m</span>}.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fix</span> <span class="id" title="var">f</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : {<span class="id" title="var">n</span> = <span class="id" title="var">m</span>} + {<span class="id" title="var">n</span> &lt;&gt; <span class="id" title="var">m</span>} :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span>, <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span>, <span class="id" title="var">O</span> =&gt; <span class="id" title="var">Yes</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span>, <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">Reduce</span> (<span class="id" title="var">f</span> <span class="id" title="var">n'</span> <span class="id" title="var">m'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span>, <span class="id" title="var">_</span> =&gt; <span class="id" title="var">No</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="tactic">congruence</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="var">eq_nat_dec</span> 2 2.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id" title="var">Yes</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: {2 = 2} + {2 &lt;&gt; 2}
<div class="paragraph"> </div>

</span>     
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="var">eq_nat_dec</span> 2 3.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id" title="var">No</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: {2 = 3} + {2 &lt;&gt; 3}
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Note that the <tt>Yes</tt> and <tt>No</tt> notations are hiding proofs establishing the correctness of the outputs.

<div class="paragraph"> </div>

   Our definition extracts to reasonable OCaml code. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Extraction</span> <span class="id" title="var">eq_nat_dec</span>.<br/>

<br/>
</div>

<div class="doc">
<pre>
(** val eq_nat_dec : nat -&gt; nat -&gt; sumbool *</pre>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">let</span> <span class="id" title="var">rec</span> <span class="id" title="var">eq_nat_dec</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> =<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> -&gt; (<span class="id" title="keyword">match</span> <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> -&gt; <span class="id" title="var">Left</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n0</span> -&gt; <span class="id" title="var">Right</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> -&gt; (<span class="id" title="keyword">match</span> <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> -&gt; <span class="id" title="var">Right</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">m'</span> -&gt; <span class="id" title="var">eq_nat_dec</span> <span class="id" title="var">n'</span> <span class="id" title="var">m'</span>)<br/>
&gt;&gt;<br/>
<br/>
#&lt;<span class="id" title="var">pre</span>&gt;<br/>
</div>

<div class="doc">
val eq_nat_dec : nat -&gt; nat -&gt; sumbool 
</div>
<div class="code">
<br/>
<span class="id" title="keyword">let</span> <span class="id" title="var">rec</span> <span class="id" title="var">eq_nat_dec</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> =<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> -&gt; (<span class="id" title="keyword">match</span> <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> -&gt; <span class="id" title="var">Left</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n0</span> -&gt; <span class="id" title="var">Right</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> -&gt; (<span class="id" title="keyword">match</span> <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> -&gt; <span class="id" title="var">Right</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">m'</span> -&gt; <span class="id" title="var">eq_nat_dec</span> <span class="id" title="var">n'</span> <span class="id" title="var">m'</span>)<br/>
&lt;/<span class="id" title="var">pre</span>&gt;#<br/>
<br/>
<span class="id" title="var">Proving</span> <span class="id" title="var">this</span> <span class="id" title="var">kind</span> <span class="id" title="var">of</span> <span class="id" title="var">decidable</span> <span class="id" title="var">equality</span> <span class="id" title="var">result</span> <span class="id" title="var">is</span> <span class="id" title="var">so</span> <span class="id" title="var">common</span> <span class="id" title="var">that</span> <span class="id" title="var">Coq</span> <span class="id" title="var">comes</span> <span class="id" title="keyword">with</span> <span class="id" title="var">a</span> <span class="id" title="var">tactic</span> <span class="id" title="keyword">for</span> <span class="id" title="var">automating</span> <span class="id" title="var">it</span>.%\<span class="id" title="var">index</span>{<span class="id" title="var">tactics</span>!<span class="id" title="var">decide</span> <span class="id" title="var">equality</span>}% *)<br/>
<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">eq_nat_dec'</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : {<span class="id" title="var">n</span> = <span class="id" title="var">m</span>} + {<span class="id" title="var">n</span> &lt;&gt; <span class="id" title="var">m</span>}.<br/>
&nbsp;&nbsp;<span class="id" title="var">decide</span> <span class="id" title="var">equality</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Curious readers can verify that the <span class="inlinecode"><span class="id" title="var">decide</span></span> <span class="inlinecode"><span class="id" title="var">equality</span></span> version extracts to the same OCaml code as our more manual version does.  That OCaml code had one undesirable property, which is that it uses <tt>Left</tt> and <tt>Right</tt> constructors instead of the Boolean values built into OCaml.  We can fix this, by using Coq's facility for mapping Coq inductive types to OCaml variant types. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Extract</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">sumbool</span> =&gt; "bool" ["true" "false"].<br/>
<span class="id" title="keyword">Extraction</span> <span class="id" title="var">eq_nat_dec'</span>.<br/>

<br/>
</div>

<div class="doc">
<pre>
(** val eq_nat_dec' : nat -&gt; nat -&gt; bool *</pre>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">let</span> <span class="id" title="var">rec</span> <span class="id" title="var">eq_nat_dec'</span> <span class="id" title="var">n</span> <span class="id" title="var">m0</span> =<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> -&gt; (<span class="id" title="keyword">match</span> <span class="id" title="var">m0</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> -&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n0</span> -&gt; <span class="id" title="var">false</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n0</span> -&gt; (<span class="id" title="keyword">match</span> <span class="id" title="var">m0</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> -&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n1</span> -&gt; <span class="id" title="var">eq_nat_dec'</span> <span class="id" title="var">n0</span> <span class="id" title="var">n1</span>)<br/>
&gt;&gt;<br/>
*)<br/>
<br/>
</div>

<div class="doc">


<div class="paragraph"> </div>

We can build "smart" versions of the usual Boolean operators and put them to good use in certified programming.  For instance, here is a <span class="inlinecode"><span class="id" title="inductive">sumbool</span></span> version of Boolean "or." 
</div>
<div class="code">
<br/>
<br/>
<br/>
<br/>
<span class="id" title="keyword">Notation</span> "x || y" := (<span class="id" title="keyword">if</span> <span class="id" title="var">x</span> <span class="id" title="keyword">then</span> <span class="id" title="var">Yes</span> <span class="id" title="keyword">else</span> <span class="id" title="var">Reduce</span> <span class="id" title="var">y</span>).<br/>

<br/>
</div>

<div class="doc">
Let us use it for building a function that decides list membership.  We need to assume the existence of an equality decision procedure for the type of list elements. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">In_dec</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Set</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">A_eq_dec</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>, {<span class="id" title="var">x</span> = <span class="id" title="var">y</span>} + {<span class="id" title="var">x</span> &lt;&gt; <span class="id" title="var">y</span>}.<br/>

<br/>
</div>

<div class="doc">
The final function is easy to write using the techniques we have developed so far. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">In_dec</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">ls</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>), {<span class="id" title="var">In</span> <span class="id" title="var">x</span> <span class="id" title="var">ls</span>} + {~ <span class="id" title="var">In</span> <span class="id" title="var">x</span> <span class="id" title="var">ls</span>}.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fix</span> <span class="id" title="var">f</span> (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">ls</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : {<span class="id" title="var">In</span> <span class="id" title="var">x</span> <span class="id" title="var">ls</span>} + {~ <span class="id" title="var">In</span> <span class="id" title="var">x</span> <span class="id" title="var">ls</span>} :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt; <span class="id" title="var">No</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x'</span> :: <span class="id" title="var">ls'</span> =&gt; <span class="id" title="var">A_eq_dec</span> <span class="id" title="var">x</span> <span class="id" title="var">x'</span> || <span class="id" title="var">f</span> <span class="id" title="var">x</span> <span class="id" title="var">ls'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="var">crush</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">In_dec</span>.<br/>

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="var">In_dec</span> <span class="id" title="var">eq_nat_dec</span> 2 (1 :: 2 :: <span class="id" title="var">nil</span>).<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id" title="var">Yes</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: {<span class="id" title="definition">In</span> 2 (1 :: 2 :: <span class="id" title="constructor">nil</span>)} + { ~ <span class="id" title="definition">In</span> 2 (1 :: 2 :: <span class="id" title="constructor">nil</span>)}
<div class="paragraph"> </div>

</span>     
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="var">In_dec</span> <span class="id" title="var">eq_nat_dec</span> 3 (1 :: 2 :: <span class="id" title="var">nil</span>).<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id" title="var">No</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: {<span class="id" title="definition">In</span> 3 (1 :: 2 :: <span class="id" title="constructor">nil</span>)} + { ~ <span class="id" title="definition">In</span> 3 (1 :: 2 :: <span class="id" title="constructor">nil</span>)}
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The <span class="inlinecode"><span class="id" title="definition">In_dec</span></span> function has a reasonable extraction to OCaml. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Extraction</span> <span class="id" title="var">In_dec</span>.<br/>

<br/>
</div>

<div class="doc">
<pre>
(** val in_dec : ('a1 -&gt; 'a1 -&gt; bool) -&gt; 'a1 -&gt; 'a1 list -&gt; bool *</pre>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">let</span> <span class="id" title="var">rec</span> <span class="id" title="var">in_dec</span> <span class="id" title="var">a_eq_dec</span> <span class="id" title="var">x</span> = <span class="id" title="var">function</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">Nil</span> -&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">Cons</span> (<span class="id" title="var">x'</span>, <span class="id" title="var">ls'</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">match</span> <span class="id" title="var">a_eq_dec</span> <span class="id" title="var">x</span> <span class="id" title="var">x'</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> -&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> -&gt; <span class="id" title="var">in_dec</span> <span class="id" title="var">a_eq_dec</span> <span class="id" title="var">x</span> <span class="id" title="var">ls'</span>)<br/>
&gt;&gt;<br/>
<br/>
<span class="id" title="var">This</span> <span class="id" title="var">is</span> <span class="id" title="var">more</span> <span class="id" title="var">or</span> <span class="id" title="var">the</span> <span class="id" title="var">less</span> <span class="id" title="var">code</span> <span class="id" title="keyword">for</span> <span class="id" title="var">the</span> <span class="id" title="var">corresponding</span> <span class="id" title="var">function</span> <span class="id" title="var">from</span> <span class="id" title="var">the</span> <span class="id" title="var">OCaml</span> <span class="id" title="var">standard</span> <span class="id" title="var">library</span>. *)<br/>
<br/>
<br/>
</div>

<div class="doc">
<a name="lab114"></a><h1 class="section">Partial Subset Types</h1>

<div class="paragraph"> </div>

 Our final implementation of dependent predecessor used a very specific argument type to ensure that execution could always complete normally.  Sometimes we want to allow execution to fail, and we want a more principled way of signaling failure than returning a default value, as <span class="inlinecode"><span class="id" title="definition">pred</span></span> does for <span class="inlinecode">0</span>.  One approach is to define this type family <span class="inlinecode"><span class="id" title="inductive">maybe</span></span>, which is a version of <span class="inlinecode"><span class="id" title="inductive">sig</span></span> that allows obligation-free failure. 
</div>
<div class="code">
<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">maybe</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Set</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">Unknown</span> : <span class="id" title="var">maybe</span> <span class="id" title="var">P</span><br/>
| <span class="id" title="var">Found</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">maybe</span> <span class="id" title="var">P</span>.<br/>

<br/>
</div>

<div class="doc">
We can define some new notations, analogous to those we defined for subset types. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;{{ x | P }}" := (<span class="id" title="var">maybe</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">P</span>)).<br/>
<span class="id" title="keyword">Notation</span> &quot;??" := (<span class="id" title="var">Unknown</span> <span class="id" title="var">_</span>).<br/>
<span class="id" title="keyword">Notation</span> &quot;[| x |]" := (<span class="id" title="var">Found</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span> <span class="id" title="var">_</span>).<br/>

<br/>
</div>

<div class="doc">
Now our next version of <span class="inlinecode"><span class="id" title="definition">pred</span></span> is trivial to write. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pred_strong7</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, {{<span class="id" title="var">m</span> | <span class="id" title="var">n</span> = <span class="id" title="var">S</span> <span class="id" title="var">m</span>}}.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">return</span> {{<span class="id" title="var">m</span> | <span class="id" title="var">n</span> = <span class="id" title="var">S</span> <span class="id" title="var">m</span>}} <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; ??<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; [|<span class="id" title="var">n'</span>|]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="var">pred_strong7</span> 2.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= [|1|]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: {{<span class="id" title="variable">m</span> | 2 = <span class="id" title="variable">S</span> <span class="id" title="variable">m</span>}}
<div class="paragraph"> </div>

</span>     
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="var">pred_strong7</span> 0.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= ??<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: {{<span class="id" title="variable">m</span> | 0 = <span class="id" title="variable">S</span> <span class="id" title="variable">m</span>}}
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

     Because we used <span class="inlinecode"><span class="id" title="inductive">maybe</span></span>, one valid implementation of the type we gave <span class="inlinecode"><span class="id" title="definition">pred_strong7</span></span> would return <span class="inlinecode">??</span> in every case.  We can strengthen the type to rule out such vacuous implementations, and the type family <span class="inlinecode"><span class="id" title="inductive">sumor</span></span> from the standard library provides the easiest starting point.  For type <span class="inlinecode"><span class="id" title="variable">A</span></span> and proposition <span class="inlinecode"><span class="id" title="variable">B</span></span>, <span class="inlinecode"><span class="id" title="variable">A</span></span> <span class="inlinecode">+</span> <span class="inlinecode">{<span class="id" title="variable">B</span>}</span> desugars to <span class="inlinecode"><span class="id" title="inductive">sumor</span></span> <span class="inlinecode"><span class="id" title="variable">A</span></span> <span class="inlinecode"><span class="id" title="variable">B</span></span>, whose values are either values of <span class="inlinecode"><span class="id" title="variable">A</span></span> or proofs of <span class="inlinecode"><span class="id" title="variable">B</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">sumor</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="keyword">Inductive</span> <span class="id" title="inductive">sumor</span> (<span class="id" title="variable">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="variable">B</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="constructor">inleft</span> : <span class="id" title="variable">A</span> -&gt; <span class="id" title="variable">A</span> + {<span class="id" title="variable">B</span>} | <span class="id" title="constructor">inright</span> : <span class="id" title="variable">B</span> -&gt; <span class="id" title="variable">A</span> + {<span class="id" title="variable">B</span>}
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

We add notations for easy use of the <span class="inlinecode"><span class="id" title="inductive">sumor</span></span> constructors.  The second notation is specialized to <span class="inlinecode"><span class="id" title="inductive">sumor</span></span>s whose <span class="inlinecode"><span class="id" title="variable">A</span></span> parameters are instantiated with regular subset types, since this is how we will use <span class="inlinecode"><span class="id" title="inductive">sumor</span></span> below. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;!!" := (<span class="id" title="var">inright</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
<span class="id" title="keyword">Notation</span> &quot;[|| x ||]" := (<span class="id" title="var">inleft</span> <span class="id" title="var">_</span> [<span class="id" title="var">x</span>]).<br/>

<br/>
</div>

<div class="doc">
Now we are ready to give the final version of possibly failing predecessor.  The <span class="inlinecode"><span class="id" title="inductive">sumor</span></span>-based type that we use is maximally expressive; any implementation of the type has the same input-output behavior. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pred_strong8</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, {<span class="id" title="var">m</span> : <span class="id" title="var">nat</span> | <span class="id" title="var">n</span> = <span class="id" title="var">S</span> <span class="id" title="var">m</span>} + {<span class="id" title="var">n</span> = 0}.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">O</span> =&gt; !!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> <span class="id" title="var">n'</span> =&gt; [||<span class="id" title="var">n'</span>||]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="tactic">trivial</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="var">pred_strong8</span> 2.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= [||1||]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: {<span class="id" title="variable">m</span> : <span class="id" title="inductive">nat</span> | 2 = <span class="id" title="variable">S</span> <span class="id" title="variable">m</span>} + {2 = 0}
<div class="paragraph"> </div>

</span>     
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="keyword">in</span> <span class="id" title="var">pred_strong8</span> 0.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= !!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: {<span class="id" title="variable">m</span> : <span class="id" title="inductive">nat</span> | 0 = <span class="id" title="variable">S</span> <span class="id" title="variable">m</span>} + {0 = 0}
<div class="paragraph"> </div>

</span>     
<div class="paragraph"> </div>

 As with our other maximally expressive <span class="inlinecode"><span class="id" title="definition">pred</span></span> function, we arrive at quite simple output values, thanks to notations. 
<div class="paragraph"> </div>

<a name="lab115"></a><h1 class="section">Monadic Notations</h1>

<div class="paragraph"> </div>

 We can treat <span class="inlinecode"><span class="id" title="inductive">maybe</span></span> like a monad, in the same way that the Haskell <tt>Maybe</tt> type is interpreted as a failure monad.  Our <span class="inlinecode"><span class="id" title="inductive">maybe</span></span> has the wrong type to be a literal monad, but a "bind"-like notation will still be helpful.   
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;x &lt;- e1 ; e2" := (<span class="id" title="keyword">match</span> <span class="id" title="var">e1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Unknown</span> =&gt; ??<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Found</span> <span class="id" title="var">x</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">e2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>)<br/>
(<span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 60).<br/>

<br/>
</div>

<div class="doc">
The meaning of <span class="inlinecode"><span class="id" title="variable">x</span></span> <span class="inlinecode">&lt;-</span> <span class="inlinecode"><span class="id" title="variable">e1</span>;</span> <span class="inlinecode"><span class="id" title="variable">e2</span></span> is: First run <span class="inlinecode"><span class="id" title="variable">e1</span></span>.  If it fails to find an answer, then announce failure for our derived computation, too.  If <span class="inlinecode"><span class="id" title="variable">e1</span></span> <i>does</i> find an answer, pass that answer on to <span class="inlinecode"><span class="id" title="variable">e2</span></span> to find the final result.  The variable <span class="inlinecode"><span class="id" title="variable">x</span></span> can be considered bound in <span class="inlinecode"><span class="id" title="variable">e2</span></span>.

<div class="paragraph"> </div>

   This notation is very helpful for composing richly typed procedures.  For instance, here is a very simple implementation of a function to take the predecessors of two naturals at once. 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">doublePred</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span> : <span class="id" title="var">nat</span>, {{<span class="id" title="var">p</span> | <span class="id" title="var">n1</span> = <span class="id" title="var">S</span> (<span class="id" title="var">fst</span> <span class="id" title="var">p</span>) /\ <span class="id" title="var">n2</span> = <span class="id" title="var">S</span> (<span class="id" title="var">snd</span> <span class="id" title="var">p</span>)}}.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">m1</span> &lt;- <span class="id" title="var">pred_strong7</span> <span class="id" title="var">n1</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">m2</span> &lt;- <span class="id" title="var">pred_strong7</span> <span class="id" title="var">n2</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[|(<span class="id" title="var">m1</span>, <span class="id" title="var">m2</span>)|]); <span class="id" title="tactic">tauto</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
We can build a <span class="inlinecode"><span class="id" title="inductive">sumor</span></span> version of the "bind" notation and use it to write a similarly straightforward version of this function.   
<div class="paragraph"> </div>

  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;x &lt;-- e1 ; e2" := (<span class="id" title="keyword">match</span> <span class="id" title="var">e1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">inright</span> <span class="id" title="var">_</span> =&gt; !!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">inleft</span> (<span class="id" title="var">exist</span> <span class="id" title="var">x</span> <span class="id" title="var">_</span>) =&gt; <span class="id" title="var">e2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>)<br/>
(<span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 60).<br/>

<br/>
</div>

<div class="doc">
 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">doublePred'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span> : <span class="id" title="var">nat</span>,<br/>
&nbsp;&nbsp;{<span class="id" title="var">p</span> : <span class="id" title="var">nat</span> * <span class="id" title="var">nat</span> | <span class="id" title="var">n1</span> = <span class="id" title="var">S</span> (<span class="id" title="var">fst</span> <span class="id" title="var">p</span>) /\ <span class="id" title="var">n2</span> = <span class="id" title="var">S</span> (<span class="id" title="var">snd</span> <span class="id" title="var">p</span>)}<br/>
&nbsp;&nbsp;+ {<span class="id" title="var">n1</span> = 0 \/ <span class="id" title="var">n2</span> = 0}.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">n1</span> <span class="id" title="var">n2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">m1</span> &lt;-- <span class="id" title="var">pred_strong8</span> <span class="id" title="var">n1</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">m2</span> &lt;-- <span class="id" title="var">pred_strong8</span> <span class="id" title="var">n2</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[||(<span class="id" title="var">m1</span>, <span class="id" title="var">m2</span>)||]); <span class="id" title="tactic">tauto</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
This example demonstrates how judicious selection of notations can hide complexities in the rich types of programs. 
<div class="paragraph"> </div>

<a name="lab116"></a><h1 class="section">A Type-Checking Example</h1>

<div class="paragraph"> </div>

 We can apply these specification types to build a certified type checker for a simple expression language. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">exp</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">Nat</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">exp</span><br/>
| <span class="id" title="var">Plus</span> : <span class="id" title="var">exp</span> -&gt; <span class="id" title="var">exp</span> -&gt; <span class="id" title="var">exp</span><br/>
| <span class="id" title="var">Bool</span> : <span class="id" title="var">bool</span> -&gt; <span class="id" title="var">exp</span><br/>
| <span class="id" title="var">And</span> : <span class="id" title="var">exp</span> -&gt; <span class="id" title="var">exp</span> -&gt; <span class="id" title="var">exp</span>.<br/>

<br/>
</div>

<div class="doc">
We define a simple language of types and its typing rules, in the style introduced in Chapter 4. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">type</span> : <span class="id" title="keyword">Set</span> := <span class="id" title="var">TNat</span> | <span class="id" title="var">TBool</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">hasType</span> : <span class="id" title="var">exp</span> -&gt; <span class="id" title="var">type</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
| <span class="id" title="var">HtNat</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">hasType</span> (<span class="id" title="var">Nat</span> <span class="id" title="var">n</span>) <span class="id" title="var">TNat</span><br/>
| <span class="id" title="var">HtPlus</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">hasType</span> <span class="id" title="var">e1</span> <span class="id" title="var">TNat</span><br/>
&nbsp;&nbsp;-&gt; <span class="id" title="var">hasType</span> <span class="id" title="var">e2</span> <span class="id" title="var">TNat</span><br/>
&nbsp;&nbsp;-&gt; <span class="id" title="var">hasType</span> (<span class="id" title="var">Plus</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span>) <span class="id" title="var">TNat</span><br/>
| <span class="id" title="var">HtBool</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">hasType</span> (<span class="id" title="var">Bool</span> <span class="id" title="var">b</span>) <span class="id" title="var">TBool</span><br/>
| <span class="id" title="var">HtAnd</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">hasType</span> <span class="id" title="var">e1</span> <span class="id" title="var">TBool</span><br/>
&nbsp;&nbsp;-&gt; <span class="id" title="var">hasType</span> <span class="id" title="var">e2</span> <span class="id" title="var">TBool</span><br/>
&nbsp;&nbsp;-&gt; <span class="id" title="var">hasType</span> (<span class="id" title="var">And</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span>) <span class="id" title="var">TBool</span>.<br/>

<br/>
</div>

<div class="doc">
It will be helpful to have a function for comparing two types.  We build one using <span class="inlinecode"><span class="id" title="var">decide</span></span> <span class="inlinecode"><span class="id" title="var">equality</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">eq_type_dec</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">t1</span> <span class="id" title="var">t2</span> : <span class="id" title="var">type</span>, {<span class="id" title="var">t1</span> = <span class="id" title="var">t2</span>} + {<span class="id" title="var">t1</span> &lt;&gt; <span class="id" title="var">t2</span>}.<br/>
&nbsp;&nbsp;<span class="id" title="var">decide</span> <span class="id" title="var">equality</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Another notation complements the monadic notation for <span class="inlinecode"><span class="id" title="inductive">maybe</span></span> that we defined earlier.  Sometimes we want to include "assertions" in our procedures.  That is, we want to run a decision procedure and fail if it fails; otherwise, we want to continue, with the proof that it produced made available to us.  This infix notation captures that idea, for a procedure that returns an arbitrary two-constructor type. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;e1 ;; e2" := (<span class="id" title="keyword">if</span> <span class="id" title="var">e1</span> <span class="id" title="keyword">then</span> <span class="id" title="var">e2</span> <span class="id" title="keyword">else</span> ??)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 60).<br/>

<br/>
</div>

<div class="doc">
With that notation defined, we can implement a <span class="inlinecode"><span class="id" title="definition">typeCheck</span></span> function, whose code is only more complex than what we would write in ML because it needs to include some extra type annotations.  Every <span class="inlinecode">[|<span class="id" title="variable">e</span>|]</span> expression adds a <span class="inlinecode"><span class="id" title="inductive">hasType</span></span> proof obligation, and <span class="inlinecode"><span class="id" title="var">crush</span></span> makes short work of them when we add <span class="inlinecode"><span class="id" title="inductive">hasType</span></span>'s constructors as hints. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">typeCheck</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">e</span> : <span class="id" title="var">exp</span>, {{<span class="id" title="var">t</span> | <span class="id" title="var">hasType</span> <span class="id" title="var">e</span> <span class="id" title="var">t</span>}}.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Constructors</span> <span class="id" title="var">hasType</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fix</span> <span class="id" title="var">F</span> (<span class="id" title="var">e</span> : <span class="id" title="var">exp</span>) : {{<span class="id" title="var">t</span> | <span class="id" title="var">hasType</span> <span class="id" title="var">e</span> <span class="id" title="var">t</span>}} :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">e</span> <span class="id" title="keyword">return</span> {{<span class="id" title="var">t</span> | <span class="id" title="var">hasType</span> <span class="id" title="var">e</span> <span class="id" title="var">t</span>}} <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Nat</span> <span class="id" title="var">_</span> =&gt; [|<span class="id" title="var">TNat</span>|]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Plus</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">t1</span> &lt;- <span class="id" title="var">F</span> <span class="id" title="var">e1</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">t2</span> &lt;- <span class="id" title="var">F</span> <span class="id" title="var">e2</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">eq_type_dec</span> <span class="id" title="var">t1</span> <span class="id" title="var">TNat</span>;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">eq_type_dec</span> <span class="id" title="var">t2</span> <span class="id" title="var">TNat</span>;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|<span class="id" title="var">TNat</span>|]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Bool</span> <span class="id" title="var">_</span> =&gt; [|<span class="id" title="var">TBool</span>|]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">And</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">t1</span> &lt;- <span class="id" title="var">F</span> <span class="id" title="var">e1</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">t2</span> &lt;- <span class="id" title="var">F</span> <span class="id" title="var">e2</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">eq_type_dec</span> <span class="id" title="var">t1</span> <span class="id" title="var">TBool</span>;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">eq_type_dec</span> <span class="id" title="var">t2</span> <span class="id" title="var">TBool</span>;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[|<span class="id" title="var">TBool</span>|]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Despite manipulating proofs, our type checker is easy to run. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">typeCheck</span> (<span class="id" title="var">Nat</span> 0).<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= [|<span class="id" title="constructor">TNat</span>|]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: {{<span class="id" title="variable">t</span> | <span class="id" title="inductive">hasType</span> (<span class="id" title="constructor">Nat</span> 0) <span class="id" title="variable">t</span>}}
<div class="paragraph"> </div>

</span>     
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">typeCheck</span> (<span class="id" title="var">Plus</span> (<span class="id" title="var">Nat</span> 1) (<span class="id" title="var">Nat</span> 2)).<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= [|<span class="id" title="constructor">TNat</span>|]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: {{<span class="id" title="variable">t</span> | <span class="id" title="inductive">hasType</span> (<span class="id" title="constructor">Plus</span> (<span class="id" title="constructor">Nat</span> 1) (<span class="id" title="constructor">Nat</span> 2)) <span class="id" title="variable">t</span>}}
<div class="paragraph"> </div>

</span>     
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">typeCheck</span> (<span class="id" title="var">Plus</span> (<span class="id" title="var">Nat</span> 1) (<span class="id" title="var">Bool</span> <span class="id" title="var">false</span>)).<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= ??<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: {{<span class="id" title="variable">t</span> | <span class="id" title="inductive">hasType</span> (<span class="id" title="constructor">Plus</span> (<span class="id" title="constructor">Nat</span> 1) (<span class="id" title="constructor">Bool</span> <span class="id" title="constructor">false</span>)) <span class="id" title="variable">t</span>}}
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The type checker also extracts to some reasonable OCaml code. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Extraction</span> <span class="id" title="var">typeCheck</span>.<br/>

<br/>
</div>

<div class="doc">
<pre>
(** val typeCheck : exp -&gt; type0 maybe *</pre>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">let</span> <span class="id" title="var">rec</span> <span class="id" title="var">typeCheck</span> = <span class="id" title="var">function</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">Nat</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">Found</span> <span class="id" title="var">TNat</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">Plus</span> (<span class="id" title="var">e1</span>, <span class="id" title="var">e2</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">match</span> <span class="id" title="var">typeCheck</span> <span class="id" title="var">e1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Unknown</span> -&gt; <span class="id" title="var">Unknown</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Found</span> <span class="id" title="var">t1</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">match</span> <span class="id" title="var">typeCheck</span> <span class="id" title="var">e2</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Unknown</span> -&gt; <span class="id" title="var">Unknown</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Found</span> <span class="id" title="var">t2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">match</span> <span class="id" title="var">eq_type_dec</span> <span class="id" title="var">t1</span> <span class="id" title="var">TNat</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">match</span> <span class="id" title="var">eq_type_dec</span> <span class="id" title="var">t2</span> <span class="id" title="var">TNat</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> -&gt; <span class="id" title="var">Found</span> <span class="id" title="var">TNat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> -&gt; <span class="id" title="var">Unknown</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> -&gt; <span class="id" title="var">Unknown</span>)))<br/>
&nbsp;&nbsp;| <span class="id" title="var">Bool</span> <span class="id" title="var">b</span> -&gt; <span class="id" title="var">Found</span> <span class="id" title="var">TBool</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">And</span> (<span class="id" title="var">e1</span>, <span class="id" title="var">e2</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">match</span> <span class="id" title="var">typeCheck</span> <span class="id" title="var">e1</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Unknown</span> -&gt; <span class="id" title="var">Unknown</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Found</span> <span class="id" title="var">t1</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">match</span> <span class="id" title="var">typeCheck</span> <span class="id" title="var">e2</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Unknown</span> -&gt; <span class="id" title="var">Unknown</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Found</span> <span class="id" title="var">t2</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">match</span> <span class="id" title="var">eq_type_dec</span> <span class="id" title="var">t1</span> <span class="id" title="var">TBool</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">match</span> <span class="id" title="var">eq_type_dec</span> <span class="id" title="var">t2</span> <span class="id" title="var">TBool</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> -&gt; <span class="id" title="var">Found</span> <span class="id" title="var">TBool</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> -&gt; <span class="id" title="var">Unknown</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> -&gt; <span class="id" title="var">Unknown</span>)))<br/>
&gt;&gt;<br/>
*)<br/>
<br/>
</div>

<div class="doc">


<div class="paragraph"> </div>

We can adapt this implementation to use <span class="inlinecode"><span class="id" title="inductive">sumor</span></span>, so that we know our type-checker only fails on ill-typed inputs.  First, we define an analogue to the "assertion" notation. 
</div>
<div class="code">
<br/>
<br/>
<span class="id" title="keyword">Notation</span> "e1 ;;; e2" := (<span class="id" title="keyword">if</span> <span class="id" title="var">e1</span> <span class="id" title="keyword">then</span> <span class="id" title="var">e2</span> <span class="id" title="keyword">else</span> !!)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 60).<br/>

<br/>
</div>

<div class="doc">
Next, we prove a helpful lemma, which states that a given expression can have at most one type. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">hasType_det</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">e</span> <span class="id" title="var">t1</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">hasType</span> <span class="id" title="var">e</span> <span class="id" title="var">t1</span><br/>
&nbsp;&nbsp;-&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">t2</span>, <span class="id" title="var">hasType</span> <span class="id" title="var">e</span> <span class="id" title="var">t2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="var">t1</span> = <span class="id" title="var">t2</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> 1; <span class="id" title="tactic">inversion</span> 1; <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Now we can define the type-checker.  Its type expresses that it only fails on untypable expressions. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">typeCheck'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">e</span> : <span class="id" title="var">exp</span>, {<span class="id" title="var">t</span> : <span class="id" title="var">type</span> | <span class="id" title="var">hasType</span> <span class="id" title="var">e</span> <span class="id" title="var">t</span>} + {<span class="id" title="keyword">forall</span> <span class="id" title="var">t</span>, ~ <span class="id" title="var">hasType</span> <span class="id" title="var">e</span> <span class="id" title="var">t</span>}.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Constructors</span> <span class="id" title="var">hasType</span>.<br/>

<br/>
</div>

<div class="doc">
We register all of the typing rules as hints. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">hasType_det</span>.<br/>

<br/>
</div>

<div class="doc">
The lemma <span class="inlinecode"><span class="id" title="lemma">hasType_det</span></span> will also be useful for proving proof obligations with contradictory contexts.  Since its statement includes <span class="inlinecode"><span class="id" title="keyword">forall</span></span>-bound variables that do not appear in its conclusion, only <span class="inlinecode"><span class="id" title="tactic">eauto</span></span> will apply this hint. 
<div class="paragraph"> </div>

 Finally, the implementation of <span class="inlinecode"><span class="id" title="definition">typeCheck</span></span> can be transcribed literally, simply switching notations as needed. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fix</span> <span class="id" title="var">F</span> (<span class="id" title="var">e</span> : <span class="id" title="var">exp</span>) : {<span class="id" title="var">t</span> : <span class="id" title="var">type</span> | <span class="id" title="var">hasType</span> <span class="id" title="var">e</span> <span class="id" title="var">t</span>} + {<span class="id" title="keyword">forall</span> <span class="id" title="var">t</span>, ~ <span class="id" title="var">hasType</span> <span class="id" title="var">e</span> <span class="id" title="var">t</span>} :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">e</span> <span class="id" title="keyword">return</span> {<span class="id" title="var">t</span> : <span class="id" title="var">type</span> | <span class="id" title="var">hasType</span> <span class="id" title="var">e</span> <span class="id" title="var">t</span>} + {<span class="id" title="keyword">forall</span> <span class="id" title="var">t</span>, ~ <span class="id" title="var">hasType</span> <span class="id" title="var">e</span> <span class="id" title="var">t</span>} <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Nat</span> <span class="id" title="var">_</span> =&gt; [||<span class="id" title="var">TNat</span>||]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Plus</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">t1</span> &lt;-- <span class="id" title="var">F</span> <span class="id" title="var">e1</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">t2</span> &lt;-- <span class="id" title="var">F</span> <span class="id" title="var">e2</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">eq_type_dec</span> <span class="id" title="var">t1</span> <span class="id" title="var">TNat</span>;;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">eq_type_dec</span> <span class="id" title="var">t2</span> <span class="id" title="var">TNat</span>;;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[||<span class="id" title="var">TNat</span>||]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Bool</span> <span class="id" title="var">_</span> =&gt; [||<span class="id" title="var">TBool</span>||]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">And</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">t1</span> &lt;-- <span class="id" title="var">F</span> <span class="id" title="var">e1</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">t2</span> &lt;-- <span class="id" title="var">F</span> <span class="id" title="var">e2</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">eq_type_dec</span> <span class="id" title="var">t1</span> <span class="id" title="var">TBool</span>;;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">eq_type_dec</span> <span class="id" title="var">t2</span> <span class="id" title="var">TBool</span>;;;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[||<span class="id" title="var">TBool</span>||]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="tactic">clear</span> <span class="id" title="var">F</span>; <span class="id" title="var">crush'</span> <span class="id" title="var">tt</span> <span class="id" title="var">hasType</span>; <span class="id" title="tactic">eauto</span>.<br/>

<br/>
</div>

<div class="doc">
We clear <span class="inlinecode"><span class="id" title="variable">F</span></span>, the local name for the recursive function, to avoid strange proofs that refer to recursive calls that we never make.  Such a step is usually warranted when defining a recursive function with <span class="inlinecode"><span class="id" title="tactic">refine</span></span>.  The <span class="inlinecode"><span class="id" title="var">crush</span></span> variant <span class="inlinecode"><span class="id" title="var">crush'</span></span> helps us by performing automatic inversion on instances of the predicates specified in its second argument.  Once we throw in <span class="inlinecode"><span class="id" title="tactic">eauto</span></span> to apply <span class="inlinecode"><span class="id" title="lemma">hasType_det</span></span> for us, we have discharged all the subgoals. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The short implementation here hides just how time-saving automation is.  Every use of one of the notations adds a proof obligation, giving us 12 in total.  Most of these obligations require multiple inversions and either uses of <span class="inlinecode"><span class="id" title="lemma">hasType_det</span></span> or applications of <span class="inlinecode"><span class="id" title="inductive">hasType</span></span> rules.

<div class="paragraph"> </div>

   Our new function remains easy to test: 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">typeCheck'</span> (<span class="id" title="var">Nat</span> 0).<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= [||<span class="id" title="constructor">TNat</span>||]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: {<span class="id" title="variable">t</span> : <span class="id" title="inductive">type</span> | <span class="id" title="inductive">hasType</span> (<span class="id" title="constructor">Nat</span> 0) <span class="id" title="variable">t</span>} +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{(<span class="id" title="keyword">forall</span> <span class="id" title="variable">t</span> : <span class="id" title="inductive">type</span>, ~ <span class="id" title="inductive">hasType</span> (<span class="id" title="constructor">Nat</span> 0) <span class="id" title="variable">t</span>)}
<div class="paragraph"> </div>

</span>       
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">typeCheck'</span> (<span class="id" title="var">Plus</span> (<span class="id" title="var">Nat</span> 1) (<span class="id" title="var">Nat</span> 2)).<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= [||<span class="id" title="constructor">TNat</span>||]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: {<span class="id" title="variable">t</span> : <span class="id" title="inductive">type</span> | <span class="id" title="inductive">hasType</span> (<span class="id" title="constructor">Plus</span> (<span class="id" title="constructor">Nat</span> 1) (<span class="id" title="constructor">Nat</span> 2)) <span class="id" title="variable">t</span>} +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{(<span class="id" title="keyword">forall</span> <span class="id" title="variable">t</span> : <span class="id" title="inductive">type</span>, ~ <span class="id" title="inductive">hasType</span> (<span class="id" title="constructor">Plus</span> (<span class="id" title="constructor">Nat</span> 1) (<span class="id" title="constructor">Nat</span> 2)) <span class="id" title="variable">t</span>)}
<div class="paragraph"> </div>

</span>       
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">typeCheck'</span> (<span class="id" title="var">Plus</span> (<span class="id" title="var">Nat</span> 1) (<span class="id" title="var">Bool</span> <span class="id" title="var">false</span>)).<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= !!<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: {<span class="id" title="variable">t</span> : <span class="id" title="inductive">type</span> | <span class="id" title="inductive">hasType</span> (<span class="id" title="constructor">Plus</span> (<span class="id" title="constructor">Nat</span> 1) (<span class="id" title="constructor">Bool</span> <span class="id" title="constructor">false</span>)) <span class="id" title="variable">t</span>} +<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{(<span class="id" title="keyword">forall</span> <span class="id" title="variable">t</span> : <span class="id" title="inductive">type</span>, ~ <span class="id" title="inductive">hasType</span> (<span class="id" title="constructor">Plus</span> (<span class="id" title="constructor">Nat</span> 1) (<span class="id" title="constructor">Bool</span> <span class="id" title="constructor">false</span>)) <span class="id" title="variable">t</span>)}
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The results of simplifying calls to <span class="inlinecode"><span class="id" title="definition">typeCheck'</span></span> look deceptively similar to the results for <span class="inlinecode"><span class="id" title="definition">typeCheck</span></span>, but now the types of the results provide more information. 
</div>
<div class="code">
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>