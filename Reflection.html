<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Reflection</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Reflection</h1>

<div class="code">

<br/>

<br/>
</div>

<div class="doc">
 
<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

最後の章では、証明に対する非常にヒューリスティックなアプローチが強調されていました。
この章では、代替の技術、
_proof by reflection ＿リフレクションによる証明＿
 を検討します。
Gallinaによって、決定手続き(decision procedures、決定するための手続き)
を正しさの証明とともに書いて、
これらの手続きが非常に短い証明で書けることを示します(appeal)。
項の <i>reflection</i> ＿リフレクション＿ は、
Gallinaの命題を構文が表す帰納型の値に変換する必要があるために、適用されます。
それで、Gallinaプログラムがそれらを解析し、
そのような項を元の形式に戻すことを ＿リフレクトする＿ (<i>reflecting</i> it) と呼びます。
 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab96"></a><h1 class="section">偶数であることの証明</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

特定の自然数の定数が偶数であることを証明することは、確かに自動的にできることです。
前章で学習したLtacプログラミング手法は、このような手順を簡単に実装できます。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">isEven</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="keyword">Prop</span> :=<br/>
| <span class="id" title="var">Even_O</span> : <span class="id" title="var">isEven</span> <span class="id" title="var">O</span><br/>
| <span class="id" title="var">Even_SS</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>, <span class="id" title="var">isEven</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">isEven</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)).<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">prove_even</span> := <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">constructor</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">even_256</span> : <span class="id" title="var">isEven</span> 256.<br/>
&nbsp;&nbsp;<span class="id" title="var">prove_even</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">even_256</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="lemma">even_256</span> = <br/>
<span class="id" title="constructor">Even_SS</span><br/>
&nbsp;&nbsp;(<span class="id" title="constructor">Even_SS</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="constructor">Even_SS</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="constructor">Even_SS</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

    
...等々。
この手順は常に（少なくとも無限のリソースを持つマシンでは）機能しますが、
重大な欠点があります。これは、256が偶数であるという証明を印刷(print)するときに表示されます。
最終的な証明項は、入力値に対して長さが超線形(super-linear)です。
Coqの暗黙的な引数の仕組みは、<span class="inlinecode"><span class="id" title="constructor">Even_SS</span></span>のパラメータ<span class="inlinecode"><span class="id" title="variable">n</span></span>に与えられた値を隠しているので、
ここでは証明項はここでは線形にしか見えません。
また、証明項は内部的に構文木として表現され、ノード表現を共有する機会がありますが、
この章では、ほぼ同等の2つの尺度、証明文の長さを簡単なテキストの長さとして、
または、用語の構文木のノード数として測定します。
時には明らかに大きな証明項でも、内部では十分な共有を持っているため、
予想以上のメモリを消費することはありませんが、
共有のない(sharing-free)バージョンのサイズが十分に小さいことを保証することによって、
そのような共有を推論する必要はありません。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

定数の偶数性を検証するための自明で信頼できるプログラムを書くことができるので、
超線形(Superlinear)な偶数性の証明項は残念なものに見えます。
証明チェッカーは、必要に応じて私たちのプログラムを単に呼び出すことができます。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

静的な型付けが、私たちのタクティクが常に適切に動作することを保証しないことも残念です。
同様の手法の他の呼び出しは、動的な型エラーで失敗する可能性があり、
十分に複雑なゴールを証明しようとするまで、
これらのエラーの背後にあるバグについてはわかりません。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

リフレクションによる証明の手法は、両方の不満に対処します。
入力のサイズを超えて一定のサイズ(constant size)のオーバーヘッドを
持つ上記の例のような証明を書くことができ、
私たちはGallinaで書かれた検証された決定手続き(decision procedures)でそれを行います。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

この例では、<span class="inlinecode"><span class="id" title="library">MoreSpecif</span></span> モジュール（この本のソースに含まれています）の型を使用して、
認証された偶数性のチェッカーを作成します。
 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">partial</span>.<br/>

<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="keyword">Inductive</span> <span class="id" title="inductive">partial</span> (<span class="id" title="variable">P</span> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Set</span> :=  <span class="id" title="constructor">Proved</span> : <span class="id" title="variable">P</span> -&gt; [<span class="id" title="variable">P</span>] | <span class="id" title="constructor">Uncertain</span> : [<span class="id" title="variable">P</span>]
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="inductive">partial</span></span> <span class="inlinecode"><span class="id" title="variable">P</span></span> の値は、<span class="inlinecode"><span class="id" title="variable">P</span></span>のオプショナルな証明です。 表記<span class="inlinecode">[<span class="id" title="variable">P</span>]</span>は<span class="inlinecode"><span class="id" title="inductive">partial</span></span> <span class="inlinecode"><span class="id" title="variable">P</span></span>の略です。
 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">partial_scope</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

私たちは<span class="inlinecode"><span class="id" title="inductive">partial</span></span>型の表記をいくつか取り上げます。
これらは、以前に、型の記述(specification types)で見た表記法の
いくつかと重複しているため、別々に開くことが必要な別のスコープに配置されました。

<div class="paragraph"> </div>

 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">check_even</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>, [<span class="id" title="var">isEven</span> <span class="id" title="var">n</span>].<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Constructors</span> <span class="id" title="var">isEven</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fix</span> <span class="id" title="var">F</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : [<span class="id" title="var">isEven</span> <span class="id" title="var">n</span>] :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">Yes</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 1 =&gt; <span class="id" title="var">No</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>) =&gt; <span class="id" title="var">Reduce</span> (<span class="id" title="var">F</span> <span class="id" title="var">n'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>


<div class="paragraph"> </div>

これで、依存パターンマッチング(dependent pattern-matching)を使用して、
驚くべきことを行う関数を書くことができます。
<span class="inlinecode"><span class="id" title="var">partialPut</span></span>が与えられている場合、<span class="inlinecode"><span class="id" title="definition">partialOut</span></span>は<span class="inlinecode"><span class="id" title="inductive">partial</span></span>値に証明が含まれていれば<span class="inlinecode"><span class="id" title="variable">P</span></span>の証明を返し、
それ以外の場合は <span class="inlinecode"><span class="id" title="inductive">True</span></span> の（使用しないuseless)の証明を返します。
MLとHaskellのプログラミングの観点からは、このような型を
書くことは不可能ですが、<span class="inlinecode"><span class="id" title="keyword">return</span></span>アノテーションを使用すれば自明です。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">partialOut</span> (<span class="id" title="var">P</span> : <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">x</span> : [<span class="id" title="var">P</span>]) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">x</span> <span class="id" title="keyword">return</span> (<span class="id" title="keyword">match</span> <span class="id" title="var">x</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Proved</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">P</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Uncertain</span> =&gt; <span class="id" title="var">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Proved</span> <span class="id" title="var">pf</span> =&gt; <span class="id" title="var">pf</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Uncertain</span> =&gt; <span class="id" title="var">I</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

このような関数を定義するのは奇妙に思えるかもしれませんが、
以前の<span class="inlinecode"><span class="id" title="var">prove_even</span></span>タクティクのリフレクティブのバージョンを書くのに非常に便利です：*）

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">prove_even_reflective</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="var">isEven</span> ?<span class="id" title="var">N</span>] =&gt; <span class="id" title="tactic">exact</span> (<span class="id" title="var">partialOut</span> (<span class="id" title="var">check_even</span> <span class="id" title="var">N</span>))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

どの自然数を考えているのかを決め、適切な<span class="inlinecode"><span class="id" title="definition">check_even</span></span>の呼び出しから証明を引き出すことによって、
その偶数性を「証明」します。
正確に型 <span class="inlinecode"><span class="id" title="variable">P</span></span> の証明項が与えられたとき、
<span class="inlinecode"><span class="id" title="tactic">exact</span></span> タクティクは、
命題 <span class="inlinecode"><span class="id" title="variable">P</span></span> を証明します。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">even_256'</span> : <span class="id" title="var">isEven</span> 256.<br/>
&nbsp;&nbsp;<span class="id" title="var">prove_even_reflective</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">even_256'</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="lemma">even_256'</span> = <span class="id" title="definition">partialOut</span> (<span class="id" title="definition">check_even</span> 256)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="inductive">isEven</span> 256
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

私たちは、証明のゴールの周りに一定のラッパーを見ることができます。
偶数の場合は、この形式の証明で十分です。
証明項のサイズは、チェックされている数では線形で、

<div class="paragraph"> </div>


<div class="paragraph"> </div>

その数の単項式の2つの繰り返しが含まれています。
そのうちのひとつは<span class="inlinecode"><span class="id" title="definition">partialOut</span></span>の暗黙の引数の上に隠されています。

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

奇数でこのタクティクを試してみたらどうなりますか？

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">even_255</span> : <span class="id" title="var">isEven</span> 255.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="var">prove_even_reflective</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
User error: No matching clauses for match goal
</pre>

<div class="paragraph"> </div>

ありがたいことに、タクティクは失敗します。
間違ったことをより正確に見るために、<span class="inlinecode"><span class="id" title="keyword">match</span></span>の本体を手動で実行することができます。

<div class="paragraph"> </div>

  <br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="definition">partialOut</span> (<span class="id" title="definition">check_even</span> 255)).
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<pre>
  Error: The term "partialOut (check_even 255)" has type
 "match check_even 255 with
  | Yes =&gt; isEven 255
  | No =&gt; True
  end" while it is expected to have type "isEven 255"
</pre>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

いつものように、型チェッカーはエラーメッセージを単純化するために
リダクション(式の簡約)を実行しません。
最初の項を自分自身で簡約した場合、<span class="inlinecode"><span class="id" title="definition">check_even</span></span> <span class="inlinecode">255</span>は
<tt>No</tt>に簡約され、
最初の項
は<span class="inlinecode"><span class="id" title="inductive">True</span></span>と等しく、
<span class="inlinecode"><span class="id" title="inductive">isEven</span></span> <span class="inlinecode">255</span>とユニファイしないのは確かです。

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

タクティク<span class="inlinecode"><span class="id" title="var">prove_even_reflective</span></span>は、リフレクティブです。
なぜなら、Gallina内の証明検索のプロセス（この場合は自明なもの）を実行するために、
Ltacの唯一の使用は目標を<span class="inlinecode"><span class="id" title="definition">check_even</span></span>の適切な使用に変換するためです。

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab97"></a><h1 class="section">自明なトートロジーの言語の文法の具象化(reifying)</h1>

</div>
<div class="code">

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

このような自明なトートロジーのリフレクティブな証明をしたいかもしれません：

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">true_galore</span> : (<span class="id" title="var">True</span> /\ <span class="id" title="var">True</span>) -&gt; (<span class="id" title="var">True</span> \/ (<span class="id" title="var">True</span> /\ (<span class="id" title="var">True</span> -&gt; <span class="id" title="var">True</span>))).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">tauto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">true_galore</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="lemma">true_galore</span> = <br/>
<span class="id" title="keyword">fun</span> <span class="id" title="variable">H</span> : <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> =&gt;<br/>
<span class="id" title="definition">and_ind</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> : <span class="id" title="inductive">True</span> =&gt; <span class="id" title="constructor">or_introl</span> (<span class="id" title="inductive">True</span> /\ (<span class="id" title="inductive">True</span> -&gt; <span class="id" title="inductive">True</span>)) <span class="id" title="constructor">I</span>) <span class="id" title="variable">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> -&gt; <span class="id" title="inductive">True</span> \/ <span class="id" title="inductive">True</span> /\ (<span class="id" title="inductive">True</span> -&gt; <span class="id" title="inductive">True</span>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

予想されるように、<span class="inlinecode"><span class="id" title="tactic">tauto</span></span> が作る証拠は、
自然演繹規則の明示的な応用が含まれています。
大きな式の場合、これは、入力のサイズを超える、
証明のサイズの線形量のオーバーヘッドを追加する可能性があります。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

このクラスのゴールに対してリフレクティブな手順を書くには、
「リフレクティブによる証明」の実際の「リフレクティブ」な部分に入る必要があります。
Gallinaのいかなるところでも、<span class="inlinecode"><span class="id" title="keyword">Prop</span></span> を条件分析(case-analyze)することは不可能です。
<span class="inlinecode"><span class="id" title="keyword">Prop</span></span> を  <i>reify</i> ＿具象化＿ して、解析できる型にする必要があります。
この帰納型は良い候補です：
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">taut</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">TautTrue</span> : <span class="id" title="var">taut</span><br/>
| <span class="id" title="var">TautAnd</span> : <span class="id" title="var">taut</span> -&gt; <span class="id" title="var">taut</span> -&gt; <span class="id" title="var">taut</span><br/>
| <span class="id" title="var">TautOr</span> : <span class="id" title="var">taut</span> -&gt; <span class="id" title="var">taut</span> -&gt; <span class="id" title="var">taut</span><br/>
| <span class="id" title="var">TautImp</span> : <span class="id" title="var">taut</span> -&gt; <span class="id" title="var">taut</span> -&gt; <span class="id" title="var">taut</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

この構文を <i>reflect</i> ＿リフレクト＿ して <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>に戻すための再帰関数を書きます。
このような関数は
 <i>interpretation functions</i> ＿翻訳関数＿
とも呼ばれ、前の例で、小さなプログラミング言語に意味論を与えるために使用しています。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">tautDenote</span> (<span class="id" title="var">t</span> : <span class="id" title="var">taut</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">t</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">TautTrue</span> =&gt; <span class="id" title="var">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">TautAnd</span> <span class="id" title="var">t1</span> <span class="id" title="var">t2</span> =&gt; <span class="id" title="var">tautDenote</span> <span class="id" title="var">t1</span> /\ <span class="id" title="var">tautDenote</span> <span class="id" title="var">t2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">TautOr</span> <span class="id" title="var">t1</span> <span class="id" title="var">t2</span> =&gt; <span class="id" title="var">tautDenote</span> <span class="id" title="var">t1</span> \/ <span class="id" title="var">tautDenote</span> <span class="id" title="var">t2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">TautImp</span> <span class="id" title="var">t1</span> <span class="id" title="var">t2</span> =&gt; <span class="id" title="var">tautDenote</span> <span class="id" title="var">t1</span> -&gt; <span class="id" title="var">tautDenote</span> <span class="id" title="var">t2</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="definition">tautDenote</span></span>の範囲のすべての式が真であることを証明するのは簡単です。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">tautTrue</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">t</span>, <span class="id" title="var">tautDenote</span> <span class="id" title="var">t</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">t</span>; <span class="id" title="var">crush</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

特定の式を証明するために<span class="inlinecode"><span class="id" title="lemma">tautTrue</span></span>を使用するには、
その構文を具象化する手順(reification process)を実装する必要があります。
再帰的なLtac関数がその仕事をします。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">tautReify</span> <span class="id" title="var">P</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">P</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">True</span> =&gt; <span class="id" title="var">TautTrue</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" title="var">P1</span> /\ ?<span class="id" title="var">P2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">t1</span> := <span class="id" title="var">tautReify</span> <span class="id" title="var">P1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">t2</span> := <span class="id" title="var">tautReify</span> <span class="id" title="var">P2</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="var">TautAnd</span> <span class="id" title="var">t1</span> <span class="id" title="var">t2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" title="var">P1</span> \/ ?<span class="id" title="var">P2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">t1</span> := <span class="id" title="var">tautReify</span> <span class="id" title="var">P1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">t2</span> := <span class="id" title="var">tautReify</span> <span class="id" title="var">P2</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="var">TautOr</span> <span class="id" title="var">t1</span> <span class="id" title="var">t2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" title="var">P1</span> -&gt; ?<span class="id" title="var">P2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">t1</span> := <span class="id" title="var">tautReify</span> <span class="id" title="var">P1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">t2</span> := <span class="id" title="var">tautReify</span> <span class="id" title="var">P2</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="var">TautImp</span> <span class="id" title="var">t1</span> <span class="id" title="var">t2</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="var">tautReify</span></span>が利用可能なので、
リフレクティブなタクティクを終わらせるのは簡単です。
ゴールの式を見て、それを具象化(reify)し、その具象化した式に<span class="inlinecode"><span class="id" title="lemma">tautTrue</span></span>を適用します。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">obvious</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ |- ?<span class="id" title="var">P</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">t</span> := <span class="id" title="var">tautReify</span> <span class="id" title="var">P</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">tautTrue</span> <span class="id" title="var">t</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

証明項の詳細は言及せずに、
<span class="inlinecode"><span class="id" title="lemma">obvious</span></span> がもとの例を解くことを証明することができます。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">true_galore'</span> : (<span class="id" title="var">True</span> /\ <span class="id" title="var">True</span>) -&gt; (<span class="id" title="var">True</span> \/ (<span class="id" title="var">True</span> /\ (<span class="id" title="var">True</span> -&gt; <span class="id" title="var">True</span>))).<br/>
&nbsp;&nbsp;<span class="id" title="var">obvious</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">true_galore'</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="lemma">true_galore'</span> = <br/>
<span class="id" title="lemma">tautTrue</span><br/>
&nbsp;&nbsp;(<span class="id" title="constructor">TautImp</span> (<span class="id" title="constructor">TautAnd</span> <span class="id" title="constructor">TautTrue</span> <span class="id" title="constructor">TautTrue</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="constructor">TautOr</span> <span class="id" title="constructor">TautTrue</span> (<span class="id" title="constructor">TautAnd</span> <span class="id" title="constructor">TautTrue</span> (<span class="id" title="constructor">TautImp</span> <span class="id" title="constructor">TautTrue</span> <span class="id" title="constructor">TautTrue</span>))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> -&gt; <span class="id" title="inductive">True</span> \/ <span class="id" title="inductive">True</span> /\ (<span class="id" title="inductive">True</span> -&gt; <span class="id" title="inductive">True</span>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

純粋なLtacによる実装で、リフレクティブなタクティクがどのように改善するかを考える価値があります。
式の具象化の手順は以前と同じようにアドホックなので、
そこではほとんど利益を得ることはできません。
一般に、証明は数式の変換よりも複雑になります。
ここで適用する「一般的な証明の規則 (generic proof rule)」は、
再帰的なLtac関数よりもはるかに優れた正式な基礎に当てはまります。
依存型の証明は、どの入力式でも「機能する」ことを保証します。
この利点は、すでに見てきた、証明のサイズの改善に加えられます。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

以前の例の偶数性のテストでは、
検証された決定手続きが証明できない入力ゴールを
健全に処理する(sound handling)ために関数<span class="inlinecode"><span class="id" title="definition">partialOut</span></span>を使用していたことを指摘する価値があります。
ここで、手続き <span class="inlinecode"><span class="id" title="lemma">tautTrue</span></span> 
（帰納的証明は再帰的手続きと見なすことができることを思い出してください）
は、<span class="inlinecode"><span class="id" title="inductive">taut</span></span>で表現できるどんなゴールをも証明できるので、余分なステップは必要ありません。

<div class="paragraph"> </div>

 
</div>
<div class="code">
</div>

<div class="doc">
<a name="lab98"></a><h1 class="section">モノイド式の簡略化</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

リフレクションによる証明では、ゴールの中のすべての構文をエンコードする必要はありません。
特殊な推論を適用できない場合でも、任意の断片が注入(injection)を許すために、
構文の型に「変数」を挿入することができます。
その可能性を、モノイドの等式(monoid equations)を正規化するための
タクティクを書くことによって探求します。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">monoid</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Set</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">e</span> : <span class="id" title="var">A</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Infix</span> &quot;+" := <span class="id" title="var">f</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">assoc</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>, (<span class="id" title="var">a</span> + <span class="id" title="var">b</span>) + <span class="id" title="var">c</span> = <span class="id" title="var">a</span> + (<span class="id" title="var">b</span> + <span class="id" title="var">c</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">identl</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <span class="id" title="var">e</span> + <span class="id" title="var">a</span> = <span class="id" title="var">a</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">identr</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <span class="id" title="var">a</span> + <span class="id" title="var">e</span> = <span class="id" title="var">a</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

モノイドの代数構造の任意のインスタンスを特徴付ける変数と仮説を追加します。
結合法則を満たす(associative)2項演算子とそれに対する単位元があります。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

モノイドの式についての木の型の式を定義するのは簡単です。
<span class="inlinecode"><span class="id" title="constructor">Var</span></span>コンストラクタは、私たちがモデル化できない部分式の「キャッチ・オール」ケースです。
これらの部分式は、実際のGallina変数であるべきで、また、
私たちのタクティクが理解できない関数を使うことができます。
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Inductive</span> <span class="id" title="var">mexp</span> : <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;| <span class="id" title="var">Ident</span> : <span class="id" title="var">mexp</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">Var</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">mexp</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">Op</span> : <span class="id" title="var">mexp</span> -&gt; <span class="id" title="var">mexp</span> -&gt; <span class="id" title="var">mexp</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

次に、翻訳関数(interpretation function)を書きます。
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">mdenote</span> (<span class="id" title="var">me</span> : <span class="id" title="var">mexp</span>) : <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">me</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Ident</span> =&gt; <span class="id" title="var">e</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Var</span> <span class="id" title="var">v</span> =&gt; <span class="id" title="var">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Op</span> <span class="id" title="var">me1</span> <span class="id" title="var">me2</span> =&gt; <span class="id" title="var">mdenote</span> <span class="id" title="var">me1</span> + <span class="id" title="var">mdenote</span> <span class="id" title="var">me2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

結合法則を使って(via associativity)式をリストにフラット化(flattening)することで式を
正規化するので、モノイドの値のリストのための表示関数(denotation function)があると便利です。
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">mldenote</span> (<span class="id" title="var">ls</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) : <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">ls</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt; <span class="id" title="var">e</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> :: <span class="id" title="var">ls'</span> =&gt; <span class="id" title="var">x</span> + <span class="id" title="var">mldenote</span> <span class="id" title="var">ls'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>


<div class="paragraph"> </div>

フラット化関数は、それ自体、実装するのに簡単です。

</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">flatten</span> (<span class="id" title="var">me</span> : <span class="id" title="var">mexp</span>) : <span class="id" title="var">list</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">me</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Ident</span> =&gt; <span class="id" title="var">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Var</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">x</span> :: <span class="id" title="var">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Op</span> <span class="id" title="var">me1</span> <span class="id" title="var">me2</span> =&gt; <span class="id" title="var">flatten</span> <span class="id" title="var">me1</span> ++ <span class="id" title="var">flatten</span> <span class="id" title="var">me2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
  この関数は、私たちの <span class="inlinecode">表示(<span class="id" title="section">denote</span>)</span> 関数に関して簡単な正当性証明を持っています。

</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Lemma</span> <span class="id" title="var">flatten_correct'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">ml2</span> <span class="id" title="var">ml1</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mldenote</span> <span class="id" title="var">ml1</span> + <span class="id" title="var">mldenote</span> <span class="id" title="var">ml2</span> = <span class="id" title="var">mldenote</span> (<span class="id" title="var">ml1</span> ++ <span class="id" title="var">ml2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">ml1</span>; <span class="id" title="var">crush</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <span class="id" title="var">flatten_correct</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">me</span>, <span class="id" title="var">mdenote</span> <span class="id" title="var">me</span> = <span class="id" title="var">mldenote</span> (<span class="id" title="var">flatten</span> <span class="id" title="var">me</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">flatten_correct'</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">me</span>; <span class="id" title="var">crush</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
  
<div class="paragraph"> </div>

簡約化タクティクの主な道具となる定理を証明するのは簡単です。

</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <span class="id" title="var">monoid_reflect</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">me1</span> <span class="id" title="var">me2</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">mldenote</span> (<span class="id" title="var">flatten</span> <span class="id" title="var">me1</span>) = <span class="id" title="var">mldenote</span> (<span class="id" title="var">flatten</span> <span class="id" title="var">me2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="var">mdenote</span> <span class="id" title="var">me1</span> = <span class="id" title="var">mdenote</span> <span class="id" title="var">me2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="tactic">repeat</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">flatten_correct</span>; <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
  
<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="inductive">mexp</span></span> 型への具象化を実装します。
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">reify</span> <span class="id" title="var">me</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">me</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">e</span> =&gt; <span class="id" title="var">Ident</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" title="var">me1</span> + ?<span class="id" title="var">me2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">r1</span> := <span class="id" title="var">reify</span> <span class="id" title="var">me1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">r2</span> := <span class="id" title="var">reify</span> <span class="id" title="var">me2</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="var">Op</span> <span class="id" title="var">r1</span> <span class="id" title="var">r2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="keyword">constr</span>:(<span class="id" title="var">Var</span> <span class="id" title="var">me</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

最終的な<span class="inlinecode"><span class="id" title="section">monoid</span></span>タクティクは、モノイドの項のふたつからなる等式のゴールに作用します。
それぞれを具象化(reify)し、<span class="inlinecode"><span class="id" title="lemma">monoid_reflect</span></span>を適用し、<span class="inlinecode"><span class="id" title="definition">mldenote</span></span>使って簡単化することで、
ゴールが具現化したバージョンを参照するように変更します。
<span class="inlinecode"><span class="id" title="tactic">change</span></span> タクティクは、
結論の式を定義として等しいものに置き換えることを思い出してください。
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Ltac</span> <span class="id" title="var">monoid</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- ?<span class="id" title="var">me1</span> = ?<span class="id" title="var">me2</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">r1</span> := <span class="id" title="var">reify</span> <span class="id" title="var">me1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">r2</span> := <span class="id" title="var">reify</span> <span class="id" title="var">me2</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">mdenote</span> <span class="id" title="var">r1</span> = <span class="id" title="var">mdenote</span> <span class="id" title="var">r2</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">monoid_reflect</span>; <span class="id" title="tactic">simpl</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

このような定理の短い作業をすることができます：

</div>
<div class="code">

<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <span class="id" title="var">t1</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> <span class="id" title="var">d</span>, <span class="id" title="var">a</span> + <span class="id" title="var">b</span> + <span class="id" title="var">c</span> + <span class="id" title="var">d</span> = <span class="id" title="var">a</span> + (<span class="id" title="var">b</span> + <span class="id" title="var">c</span>) + <span class="id" title="var">d</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="var">monoid</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="variable">a</span> + (<span class="id" title="variable">b</span> + (<span class="id" title="variable">c</span> + (<span class="id" title="variable">d</span> + <span class="id" title="variable">e</span>))) = <span class="id" title="variable">a</span> + (<span class="id" title="variable">b</span> + (<span class="id" title="variable">c</span> + (<span class="id" title="variable">d</span> + <span class="id" title="variable">e</span>)))<br/>
&nbsp;
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

monoidタクティクは、等式の両辺を正準化(canonicalized)しているので、
反射性(reflexivity)によって証明を完成させることができます。

</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

証明の形式(the form)を見るのは面白いです。

</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Print</span> <span class="id" title="var">t1</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="lemma">t1</span> = <br/>
<span class="id" title="keyword">fun</span> <span class="id" title="variable">a</span> <span class="id" title="variable">b</span> <span class="id" title="variable">c</span> <span class="id" title="variable">d</span> : <span class="id" title="variable">A</span> =&gt;<br/>
<span class="id" title="lemma">monoid_reflect</span> (<span class="id" title="constructor">Op</span> (<span class="id" title="constructor">Op</span> (<span class="id" title="constructor">Op</span> (<span class="id" title="constructor">Var</span> <span class="id" title="variable">a</span>) (<span class="id" title="constructor">Var</span> <span class="id" title="variable">b</span>)) (<span class="id" title="constructor">Var</span> <span class="id" title="variable">c</span>)) (<span class="id" title="constructor">Var</span> <span class="id" title="variable">d</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="constructor">Op</span> (<span class="id" title="constructor">Op</span> (<span class="id" title="constructor">Var</span> <span class="id" title="variable">a</span>) (<span class="id" title="constructor">Op</span> (<span class="id" title="constructor">Var</span> <span class="id" title="variable">b</span>) (<span class="id" title="constructor">Var</span> <span class="id" title="variable">c</span>))) (<span class="id" title="constructor">Var</span> <span class="id" title="variable">d</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="constructor">eq_refl</span> (<span class="id" title="variable">a</span> + (<span class="id" title="variable">b</span> + (<span class="id" title="variable">c</span> + (<span class="id" title="variable">d</span> + <span class="id" title="variable">e</span>)))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="variable">a</span> <span class="id" title="variable">b</span> <span class="id" title="variable">c</span> <span class="id" title="variable">d</span> : <span class="id" title="variable">A</span>, <span class="id" title="variable">a</span> + <span class="id" title="variable">b</span> + <span class="id" title="variable">c</span> + <span class="id" title="variable">d</span> = <span class="id" title="variable">a</span> + (<span class="id" title="variable">b</span> + <span class="id" title="variable">c</span>) + <span class="id" title="variable">d</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

証明項は、具現化された形式の等式のオペランドの再記述だけを含み、
共有された(shared)正準形(canonical form)への反射性の使用が続きます。
   
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">monoid</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

この基本的なアプローチの拡張は、Coqでパッケージ化された、
<span class="inlinecode"><span class="id" title="tactic">ring</span></span> と <span class="inlinecode"><span class="id" title="tactic">field</span></span> タクティク
の実装で使われています。

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab99"></a><h1 class="section">賢いトートロジー・ソルバー</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

これで、以前のトートロジー・ソルバーの例を再検討する準備が整いました。 
私たちは、真理が構文的に明らかでない式を含むようにタクティクの範囲を広げたいと考えています。
最後の例で任意のモノイド式を許可したのと同じように、
任意の式の注入(injection)を許可したいと思うでしょう。
私たちはより豊かな理論で作業しているので、
注入された異なる式の間で等値を使用できることが重要です。
例えば、Gallina関数は、ふたつの<span class="inlinecode"><span class="id" title="variable">P</span></span>が等しいかどうかを比較する方法がないため、
式を<span class="inlinecode"><span class="id" title="constructor">Imp</span></span> <span class="inlinecode">(<span class="id" title="constructor">Var</span></span> <span class="inlinecode"><span class="id" title="variable">P</span>)</span> <span class="inlinecode">(<span class="id" title="constructor">Var</span></span> <span class="inlinecode"><span class="id" title="variable">P</span>)</span>のような値に変換することによって<span class="inlinecode"><span class="id" title="variable">P</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="variable">P</span></span>を証明することはできません。

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

これらの基準を満たす素晴らしい実装に到達するために、
<span class="inlinecode"><span class="id" title="tactic">quote</span></span>
タクティクとそれに関連するライブラリを紹介します。 
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Quote</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">formula</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">Atomic</span> : <span class="id" title="var">index</span> -&gt; <span class="id" title="var">formula</span>                 <br/>
| <span class="id" title="var">Truth</span> : <span class="id" title="var">formula</span><br/>
| <span class="id" title="var">Falsehood</span> : <span class="id" title="var">formula</span><br/>
| <span class="id" title="var">And</span> : <span class="id" title="var">formula</span> -&gt; <span class="id" title="var">formula</span> -&gt; <span class="id" title="var">formula</span><br/>
| <span class="id" title="var">Or</span> : <span class="id" title="var">formula</span> -&gt; <span class="id" title="var">formula</span> -&gt; <span class="id" title="var">formula</span><br/>
| <span class="id" title="var">Imp</span> : <span class="id" title="var">formula</span> -&gt; <span class="id" title="var">formula</span> -&gt; <span class="id" title="var">formula</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="tactic">quote</span></span> タクティクは<span class="inlinecode"><span class="id" title="keyword">Prop</span></span>から<span class="inlinecode"><span class="id" title="var">Formula</span></span>への単射(injection)を実装しますが、
望むほどスマートではありません。 
特に、関数型を特別に扱いたいので、
関数型が構文的に符号化したい構造体の一部であれば混乱(confused)します。
論理的な意味を表現するために関数型を使用することに気づかないように
<span class="inlinecode"><span class="id" title="tactic">quote</span></span>することをトリックするには、
最後の章で行ったように、含意のラッパー定義を宣言する必要があります。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">imp</span> (<span class="id" title="var">P1</span> <span class="id" title="var">P2</span> : <span class="id" title="keyword">Prop</span>) := <span class="id" title="var">P1</span> -&gt; <span class="id" title="var">P2</span>.<br/>
<span class="id" title="keyword">Infix</span> &quot;--&gt;" := <span class="id" title="var">imp</span> (<span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 95).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

ここでは、表示関数(denotation function)を定義することができます。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">asgn</span> := <span class="id" title="var">varmap</span> <span class="id" title="keyword">Prop</span>. 
<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">formulaDenote</span> (<span class="id" title="var">atomics</span> : <span class="id" title="var">asgn</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">formula</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">f</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Atomic</span> <span class="id" title="var">v</span> =&gt; <span class="id" title="var">varmap_find</span> <span class="id" title="var">False</span> <span class="id" title="var">v</span> <span class="id" title="var">atomics</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Truth</span> =&gt; <span class="id" title="var">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Falsehood</span> =&gt; <span class="id" title="var">False</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">And</span> <span class="id" title="var">f1</span> <span class="id" title="var">f2</span> =&gt; <span class="id" title="var">formulaDenote</span> <span class="id" title="var">atomics</span> <span class="id" title="var">f1</span> /\ <span class="id" title="var">formulaDenote</span> <span class="id" title="var">atomics</span> <span class="id" title="var">f2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Or</span> <span class="id" title="var">f1</span> <span class="id" title="var">f2</span> =&gt; <span class="id" title="var">formulaDenote</span> <span class="id" title="var">atomics</span> <span class="id" title="var">f1</span> \/ <span class="id" title="var">formulaDenote</span> <span class="id" title="var">atomics</span> <span class="id" title="var">f2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Imp</span> <span class="id" title="var">f1</span> <span class="id" title="var">f2</span> =&gt; <span class="id" title="var">formulaDenote</span> <span class="id" title="var">atomics</span> <span class="id" title="var">f1</span> --&gt; <span class="id" title="var">formulaDenote</span> <span class="id" title="var">atomics</span> <span class="id" title="var">f2</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="inductive">varmap</span></span> のファミリーは、
<span class="inlinecode"><span class="id" title="inductive">index</span></span> の値から map を実装します。
この場合、変数から <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> への map として代入を定義します。
翻訳関数(interpretation function) <span class="inlinecode"><span class="id" title="definition">formulaDenote</span></span>は代入として動作し、
<span class="inlinecode"><span class="id" title="definition">varmap_find</span></span>関数を使って<span class="inlinecode"><span class="id" title="constructor">Atomic</span></span>の場合の代入を調べます。
<span class="inlinecode"><span class="id" title="definition">varmap_find</span></span>の最初の引数は、変数が見つからない場合のデフォルト値です。
 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">my_tauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Variable</span> <span class="id" title="var">atomics</span> : <span class="id" title="var">asgn</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">holds</span> (<span class="id" title="var">v</span> : <span class="id" title="var">index</span>) := <span class="id" title="var">varmap_find</span> <span class="id" title="var">False</span> <span class="id" title="var">v</span> <span class="id" title="var">atomics</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

特定の変数が真であるためにいくつかの省略形を定義し、
標準ライブラリの<span class="inlinecode"><span class="id" title="library">ListSet</span></span>モジュールに基づいて、
（驚くことではありませんが）リストを集合として見ることを提供する、
便利な関数を定義する準備が整いました。
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">ListSet</span>. 
<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">index_eq</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">index</span>, {<span class="id" title="var">x</span> = <span class="id" title="var">y</span>} + {<span class="id" title="var">x</span> &lt;&gt; <span class="id" title="var">y</span>}.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">decide</span> <span class="id" title="var">equality</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">add</span> (<span class="id" title="var">s</span> : <span class="id" title="tactic">set</span> <span class="id" title="var">index</span>) (<span class="id" title="var">v</span> : <span class="id" title="var">index</span>) := <span class="id" title="var">set_add</span> <span class="id" title="var">index_eq</span> <span class="id" title="var">v</span> <span class="id" title="var">s</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">In_dec</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">v</span> (<span class="id" title="var">s</span> : <span class="id" title="tactic">set</span> <span class="id" title="var">index</span>), {<span class="id" title="var">In</span> <span class="id" title="var">v</span> <span class="id" title="var">s</span>} + {~ <span class="id" title="var">In</span> <span class="id" title="var">v</span> <span class="id" title="var">s</span>}.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">specif_scope</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span>; <span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fix</span> <span class="id" title="var">F</span> (<span class="id" title="var">s</span> : <span class="id" title="tactic">set</span> <span class="id" title="var">index</span>) : {<span class="id" title="var">In</span> <span class="id" title="var">v</span> <span class="id" title="var">s</span>} + {~ <span class="id" title="var">In</span> <span class="id" title="var">v</span> <span class="id" title="var">s</span>} :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">s</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt; <span class="id" title="var">No</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">v'</span> :: <span class="id" title="var">s'</span> =&gt; <span class="id" title="var">index_eq</span> <span class="id" title="var">v'</span> <span class="id" title="var">v</span> || <span class="id" title="var">F</span> <span class="id" title="var">s'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="var">crush</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

index の集合のすべてのメンバーに対して真となる命題を表わすもの
を定義し、
この表記についてのいくつかの補題を証明します。

</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">allTrue</span> (<span class="id" title="var">s</span> : <span class="id" title="tactic">set</span> <span class="id" title="var">index</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">s</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt; <span class="id" title="var">True</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">v</span> :: <span class="id" title="var">s'</span> =&gt; <span class="id" title="var">holds</span> <span class="id" title="var">v</span> /\ <span class="id" title="var">allTrue</span> <span class="id" title="var">s'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <span class="id" title="var">allTrue_add</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">v</span> <span class="id" title="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">allTrue</span> <span class="id" title="var">s</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="var">holds</span> <span class="id" title="var">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="var">allTrue</span> (<span class="id" title="var">add</span> <span class="id" title="var">s</span> <span class="id" title="var">v</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">s</span>; <span class="id" title="var">crush</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">context</span>[<span class="id" title="keyword">if</span> ?<span class="id" title="var">E</span> <span class="id" title="keyword">then</span> <span class="id" title="var">_</span> <span class="id" title="keyword">else</span> <span class="id" title="var">_</span>] ] =&gt; <span class="id" title="tactic">destruct</span> <span class="id" title="var">E</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>; <span class="id" title="var">crush</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Theorem</span> <span class="id" title="var">allTrue_In</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">v</span> <span class="id" title="var">s</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">allTrue</span> <span class="id" title="var">s</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="var">set_In</span> <span class="id" title="var">v</span> <span class="id" title="var">s</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="var">varmap_find</span> <span class="id" title="var">False</span> <span class="id" title="var">v</span> <span class="id" title="var">atomics</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">s</span>; <span class="id" title="var">crush</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Qed</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">allTrue_add</span> <span class="id" title="var">allTrue_In</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">partial_scope</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

ここで、仮説の分解(deconstruction)を実装する関数 <span class="inlinecode"><span class="id" title="definition">forward</span></span> を書くことができ、
複合式を、<span class="inlinecode"><span class="id" title="constructor">Or</span></span>を使って導入された可能性のあるすべての場合(case)をカバーする
一連のアトミックな論理式の集合に
展開することができます。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

複数のケースの考慮を処理するために、この関数は継続引数(continuation argument
)を取ります。
これはそれぞれのケースに対して1回呼び出されます。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="definition">forward</span></span>関数は、第6章のスタイルで依存性の型を持ち、正確さを保証します。
<span class="inlinecode"><span class="id" title="definition">forward</span></span>のへの引数は、ゴールの式<span class="inlinecode"><span class="id" title="variable">f</span></span>、
真であると仮定してもよい原子式の集合<span class="inlinecode"><span class="id" title="variable">known</span></span>、
仮定の式<span class="inlinecode"><span class="id" title="variable">hyp</span></span>、
および、<span class="inlinecode"><span class="id" title="variable">hyp</span></span>によって含意される新しい真実を保持するために
<span class="inlinecode"><span class="id" title="variable">known</span></span> を拡張するときに呼び出す次への継続(success continuation) <span class="inlinecode"><span class="id" title="variable">cont</span></span> です。
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">forward</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">f</span> : <span class="id" title="var">formula</span>) (<span class="id" title="var">known</span> : <span class="id" title="tactic">set</span> <span class="id" title="var">index</span>) (<span class="id" title="var">hyp</span> : <span class="id" title="var">formula</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">cont</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">known'</span>, [<span class="id" title="var">allTrue</span> <span class="id" title="var">known'</span> -&gt; <span class="id" title="var">formulaDenote</span> <span class="id" title="var">atomics</span> <span class="id" title="var">f</span>]),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" title="var">allTrue</span> <span class="id" title="var">known</span> -&gt; <span class="id" title="var">formulaDenote</span> <span class="id" title="var">atomics</span> <span class="id" title="var">hyp</span> -&gt; <span class="id" title="var">formulaDenote</span> <span class="id" title="var">atomics</span> <span class="id" title="var">f</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fix</span> <span class="id" title="var">F</span> (<span class="id" title="var">f</span> : <span class="id" title="var">formula</span>) (<span class="id" title="var">known</span> : <span class="id" title="tactic">set</span> <span class="id" title="var">index</span>) (<span class="id" title="var">hyp</span> : <span class="id" title="var">formula</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">cont</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">known'</span>, [<span class="id" title="var">allTrue</span> <span class="id" title="var">known'</span> -&gt; <span class="id" title="var">formulaDenote</span> <span class="id" title="var">atomics</span> <span class="id" title="var">f</span>])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: [<span class="id" title="var">allTrue</span> <span class="id" title="var">known</span> -&gt; <span class="id" title="var">formulaDenote</span> <span class="id" title="var">atomics</span> <span class="id" title="var">hyp</span> -&gt; <span class="id" title="var">formulaDenote</span> <span class="id" title="var">atomics</span> <span class="id" title="var">f</span>] :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">hyp</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Atomic</span> <span class="id" title="var">v</span> =&gt; <span class="id" title="var">Reduce</span> (<span class="id" title="var">cont</span> (<span class="id" title="var">add</span> <span class="id" title="var">known</span> <span class="id" title="var">v</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Truth</span> =&gt; <span class="id" title="var">Reduce</span> (<span class="id" title="var">cont</span> <span class="id" title="var">known</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Falsehood</span> =&gt; <span class="id" title="var">Yes</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">And</span> <span class="id" title="var">h1</span> <span class="id" title="var">h2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Reduce</span> (<span class="id" title="var">F</span> (<span class="id" title="var">Imp</span> <span class="id" title="var">h2</span> <span class="id" title="var">f</span>) <span class="id" title="var">known</span> <span class="id" title="var">h1</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">known'</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Reduce</span> (<span class="id" title="var">F</span> <span class="id" title="var">f</span> <span class="id" title="var">known'</span> <span class="id" title="var">h2</span> <span class="id" title="var">cont</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Or</span> <span class="id" title="var">h1</span> <span class="id" title="var">h2</span> =&gt; <span class="id" title="var">F</span> <span class="id" title="var">f</span> <span class="id" title="var">known</span> <span class="id" title="var">h1</span> <span class="id" title="var">cont</span> &amp;&amp; <span class="id" title="var">F</span> <span class="id" title="var">f</span> <span class="id" title="var">known</span> <span class="id" title="var">h2</span> <span class="id" title="var">cont</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Imp</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">Reduce</span> (<span class="id" title="var">cont</span> <span class="id" title="var">known</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="var">crush</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="definition">backward</span></span>関数は、最終のゴールの分析を実装します。
含意を扱うために<span class="inlinecode"><span class="id" title="definition">forward</span></span>を呼び出します。
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">backward</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">known</span> : <span class="id" title="tactic">set</span> <span class="id" title="var">index</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">formula</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" title="var">allTrue</span> <span class="id" title="var">known</span> -&gt; <span class="id" title="var">formulaDenote</span> <span class="id" title="var">atomics</span> <span class="id" title="var">f</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="keyword">fix</span> <span class="id" title="var">F</span> (<span class="id" title="var">known</span> : <span class="id" title="tactic">set</span> <span class="id" title="var">index</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">formula</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: [<span class="id" title="var">allTrue</span> <span class="id" title="var">known</span> -&gt; <span class="id" title="var">formulaDenote</span> <span class="id" title="var">atomics</span> <span class="id" title="var">f</span>] :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">f</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Atomic</span> <span class="id" title="var">v</span> =&gt; <span class="id" title="var">Reduce</span> (<span class="id" title="var">In_dec</span> <span class="id" title="var">v</span> <span class="id" title="var">known</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Truth</span> =&gt; <span class="id" title="var">Yes</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Falsehood</span> =&gt; <span class="id" title="var">No</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">And</span> <span class="id" title="var">f1</span> <span class="id" title="var">f2</span> =&gt; <span class="id" title="var">F</span> <span class="id" title="var">known</span> <span class="id" title="var">f1</span> &amp;&amp; <span class="id" title="var">F</span> <span class="id" title="var">known</span> <span class="id" title="var">f2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Or</span> <span class="id" title="var">f1</span> <span class="id" title="var">f2</span> =&gt; <span class="id" title="var">F</span> <span class="id" title="var">known</span> <span class="id" title="var">f1</span> || <span class="id" title="var">F</span> <span class="id" title="var">known</span> <span class="id" title="var">f2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Imp</span> <span class="id" title="var">f1</span> <span class="id" title="var">f2</span> =&gt; <span class="id" title="var">forward</span> <span class="id" title="var">f2</span> <span class="id" title="var">known</span> <span class="id" title="var">f1</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">known'</span> =&gt; <span class="id" title="var">F</span> <span class="id" title="var">known'</span> <span class="id" title="var">f2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>); <span class="id" title="var">crush</span>; <span class="id" title="tactic">eauto</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="definition">backward</span></span>の周りの単純なラッパーは、部分的な決定のための手続きの通常のタイプを与えます。
   
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">my_tauto</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">f</span> : <span class="id" title="var">formula</span>, [<span class="id" title="var">formulaDenote</span> <span class="id" title="var">atomics</span> <span class="id" title="var">f</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span>; <span class="id" title="tactic">refine</span> (<span class="id" title="var">Reduce</span> (<span class="id" title="var">backward</span> <span class="id" title="var">nil</span> <span class="id" title="var">f</span>)); <span class="id" title="var">crush</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">my_tauto</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

最終的なタクティクの実装はかなり簡単です。
まず、<span class="inlinecode"><span class="id" title="keyword">Prop</span></span> の束縛しないすべての量化子を <span class="inlinecode"><span class="id" title="tactic">intro</span></span> します。
次に、具象化を実装する<span class="inlinecode"><span class="id" title="tactic">quote</span></span>タクティクを呼び出します。 
最後に、<span class="inlinecode"><span class="id" title="definition">partialOut</span></span>と<span class="inlinecode"><span class="id" title="definition">my_tauto</span></span> のGallina関数を使用して正確な証明を構築します。

<div class="paragraph"> </div>

  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">my_tauto</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : ?<span class="id" title="var">P</span>, <span class="id" title="var">_</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">type</span> <span class="id" title="var">of</span> <span class="id" title="var">P</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">Prop</span> =&gt; <span class="id" title="tactic">fail</span> 1      <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="tactic">intro</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>;<br/>
&nbsp;&nbsp;<span class="id" title="tactic">quote</span> <span class="id" title="var">formulaDenote</span>;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" title="var">formulaDenote</span> ?<span class="id" title="var">m</span> ?<span class="id" title="var">f</span> ] =&gt; <span class="id" title="tactic">exact</span> (<span class="id" title="var">partialOut</span> (<span class="id" title="var">my_tauto</span> <span class="id" title="var">m</span> <span class="id" title="var">f</span>))<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

いくつかの例は、タクティクがどのように機能するかを示しています。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mt1</span> : <span class="id" title="var">True</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_tauto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">mt1</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="lemma">mt1</span> = <span class="id" title="definition">partialOut</span> (<span class="id" title="definition">my_tauto</span> (<span class="id" title="constructor">Empty_vm</span> <span class="id" title="keyword">Prop</span>) <span class="id" title="constructor">Truth</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="inductive">True</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

すべての部分式は<span class="inlinecode"><span class="id" title="definition">formulaDenote</span></span>によって処理されるため、
<span class="inlinecode"><span class="id" title="definition">my_tauto</span></span>に空の<span class="inlinecode"><span class="id" title="inductive">varmap</span></span>  が適用されていることがわかります。
 
</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mt2</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">nat</span>, <span class="id" title="var">x</span> = <span class="id" title="var">y</span> --&gt; <span class="id" title="var">x</span> = <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_tauto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">mt2</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="lemma">mt2</span> = <br/>
<span class="id" title="keyword">fun</span> <span class="id" title="variable">x</span> <span class="id" title="variable">y</span> : <span class="id" title="inductive">nat</span> =&gt;<br/>
<span class="id" title="definition">partialOut</span><br/>
&nbsp;&nbsp;(<span class="id" title="definition">my_tauto</span> (<span class="id" title="constructor">Node_vm</span> (<span class="id" title="variable">x</span> = <span class="id" title="variable">y</span>) (<span class="id" title="constructor">Empty_vm</span> <span class="id" title="keyword">Prop</span>) (<span class="id" title="constructor">Empty_vm</span> <span class="id" title="keyword">Prop</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="constructor">Imp</span> (<span class="id" title="constructor">Atomic</span> <span class="id" title="constructor">End_idx</span>) (<span class="id" title="constructor">Atomic</span> <span class="id" title="constructor">End_idx</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="variable">x</span> <span class="id" title="variable">y</span> : <span class="id" title="inductive">nat</span>, <span class="id" title="variable">x</span> = <span class="id" title="variable">y</span> --&gt; <span class="id" title="variable">x</span> = <span class="id" title="variable">y</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

重要なことに、<span class="inlinecode"><span class="id" title="variable">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="variable">y</span></span>の両方のインスタンスは同じインデックス<span class="inlinecode"><span class="id" title="constructor">End_idx</span></span>で表されます。
このインデックスの値は<span class="inlinecode"><span class="id" title="inductive">varmap</span></span>に1回だけ現れなければならず、
<span class="inlinecode"><span class="id" title="inductive">varmap</span></span>は、
<span class="inlinecode"><span class="id" title="inductive">index</span></span> の値が木の根から葉までのパスを示す、
二進木(binary trees) として表現されます。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mt3</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>,<br/>
&nbsp;&nbsp;(<span class="id" title="var">x</span> &lt; <span class="id" title="var">y</span> /\ <span class="id" title="var">y</span> &gt; <span class="id" title="var">z</span>) \/ (<span class="id" title="var">y</span> &gt; <span class="id" title="var">z</span> /\ <span class="id" title="var">x</span> &lt; <span class="id" title="var">S</span> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;--&gt; <span class="id" title="var">y</span> &gt; <span class="id" title="var">z</span> /\ (<span class="id" title="var">x</span> &lt; <span class="id" title="var">y</span> \/ <span class="id" title="var">x</span> &lt; <span class="id" title="var">S</span> <span class="id" title="var">y</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">my_tauto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">mt3</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="keyword">fun</span> <span class="id" title="variable">x</span> <span class="id" title="variable">y</span> <span class="id" title="variable">z</span> : <span class="id" title="inductive">nat</span> =&gt;<br/>
<span class="id" title="definition">partialOut</span><br/>
&nbsp;&nbsp;(<span class="id" title="definition">my_tauto</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="constructor">Node_vm</span> (<span class="id" title="variable">x</span> &lt; <span class="id" title="variable">S</span> <span class="id" title="variable">y</span>) (<span class="id" title="constructor">Node_vm</span> (<span class="id" title="variable">x</span> &lt; <span class="id" title="variable">y</span>) (<span class="id" title="constructor">Empty_vm</span> <span class="id" title="keyword">Prop</span>) (<span class="id" title="constructor">Empty_vm</span> <span class="id" title="keyword">Prop</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="constructor">Node_vm</span> (<span class="id" title="variable">y</span> &gt; <span class="id" title="variable">z</span>) (<span class="id" title="constructor">Empty_vm</span> <span class="id" title="keyword">Prop</span>) (<span class="id" title="constructor">Empty_vm</span> <span class="id" title="keyword">Prop</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="constructor">Imp</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="constructor">Or</span> (<span class="id" title="constructor">And</span> (<span class="id" title="constructor">Atomic</span> (<span class="id" title="constructor">Left_idx</span> <span class="id" title="constructor">End_idx</span>)) (<span class="id" title="constructor">Atomic</span> (<span class="id" title="constructor">Right_idx</span> <span class="id" title="constructor">End_idx</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="constructor">And</span> (<span class="id" title="constructor">Atomic</span> (<span class="id" title="constructor">Right_idx</span> <span class="id" title="constructor">End_idx</span>)) (<span class="id" title="constructor">Atomic</span> <span class="id" title="constructor">End_idx</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="constructor">And</span> (<span class="id" title="constructor">Atomic</span> (<span class="id" title="constructor">Right_idx</span> <span class="id" title="constructor">End_idx</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="constructor">Or</span> (<span class="id" title="constructor">Atomic</span> (<span class="id" title="constructor">Left_idx</span> <span class="id" title="constructor">End_idx</span>)) (<span class="id" title="constructor">Atomic</span> <span class="id" title="constructor">End_idx</span>)))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="variable">x</span> <span class="id" title="variable">y</span> <span class="id" title="variable">z</span> : <span class="id" title="inductive">nat</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="variable">x</span> &lt; <span class="id" title="variable">y</span> /\ <span class="id" title="variable">y</span> &gt; <span class="id" title="variable">z</span> \/ <span class="id" title="variable">y</span> &gt; <span class="id" title="variable">z</span> /\ <span class="id" title="variable">x</span> &lt; <span class="id" title="variable">S</span> <span class="id" title="variable">y</span> --&gt; <span class="id" title="variable">y</span> &gt; <span class="id" title="variable">z</span> /\ (<span class="id" title="variable">x</span> &lt; <span class="id" title="variable">y</span> \/ <span class="id" title="variable">x</span> &lt; <span class="id" title="variable">S</span> <span class="id" title="variable">y</span>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

ゴールにはみっつの異なる原子式が含まれていて、
3要素の「varmap」が生成されていることがわかります。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

特に自明な定理のために<span class="inlinecode"><span class="id" title="definition">my_tauto</span></span>と<span class="inlinecode"><span class="id" title="tactic">tauto</span></span>によって生成される証明項の反復の
レベルの違いを観察することは面白いかもしれません。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mt4</span> : <span class="id" title="var">True</span> /\ <span class="id" title="var">True</span> /\ <span class="id" title="var">True</span> /\ <span class="id" title="var">True</span> /\ <span class="id" title="var">True</span> /\ <span class="id" title="var">True</span> /\ <span class="id" title="var">False</span> --&gt; <span class="id" title="var">False</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">my_tauto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">mt4</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="lemma">mt4</span> = <br/>
<span class="id" title="definition">partialOut</span><br/>
&nbsp;&nbsp;(<span class="id" title="definition">my_tauto</span> (<span class="id" title="constructor">Empty_vm</span> <span class="id" title="keyword">Prop</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="constructor">Imp</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="constructor">And</span> <span class="id" title="constructor">Truth</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="constructor">And</span> <span class="id" title="constructor">Truth</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="constructor">And</span> <span class="id" title="constructor">Truth</span> (<span class="id" title="constructor">And</span> <span class="id" title="constructor">Truth</span> (<span class="id" title="constructor">And</span> <span class="id" title="constructor">Truth</span> (<span class="id" title="constructor">And</span> <span class="id" title="constructor">Truth</span> <span class="id" title="constructor">Falsehood</span>))))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="constructor">Falsehood</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">False</span> --&gt; <span class="id" title="inductive">False</span>
<div class="paragraph"> </div>

</span>    
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mt4'</span> : <span class="id" title="var">True</span> /\ <span class="id" title="var">True</span> /\ <span class="id" title="var">True</span> /\ <span class="id" title="var">True</span> /\ <span class="id" title="var">True</span> /\ <span class="id" title="var">True</span> /\ <span class="id" title="var">False</span> -&gt; <span class="id" title="var">False</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">tauto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">mt4'</span>.<br/>
</div>

<div class="doc">
 <br/>
<span class="inlinecode"><span class="id" title="lemma">mt4'</span> = <br/>
<span class="id" title="keyword">fun</span> <span class="id" title="variable">H</span> : <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">False</span> =&gt;<br/>
<span class="id" title="definition">and_ind</span><br/>
&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> (<span class="id" title="var">_</span> : <span class="id" title="inductive">True</span>) (<span class="id" title="variable">H1</span> : <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">False</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="definition">and_ind</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> (<span class="id" title="var">_</span> : <span class="id" title="inductive">True</span>) (<span class="id" title="variable">H3</span> : <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">False</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">and_ind</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> (<span class="id" title="var">_</span> : <span class="id" title="inductive">True</span>) (<span class="id" title="var">H5</span> : <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">False</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">and_ind</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> (<span class="id" title="var">_</span> : <span class="id" title="inductive">True</span>) (<span class="id" title="var">H7</span> : <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">False</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">and_ind</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> (<span class="id" title="var">_</span> : <span class="id" title="inductive">True</span>) (<span class="id" title="var">H9</span> : <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">False</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">and_ind</span> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">_</span> : <span class="id" title="inductive">True</span>) (<span class="id" title="var">H11</span> : <span class="id" title="inductive">False</span>) =&gt; <span class="id" title="definition">False_ind</span> <span class="id" title="inductive">False</span> <span class="id" title="var">H11</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">H9</span>) <span class="id" title="var">H7</span>) <span class="id" title="var">H5</span>) <span class="id" title="variable">H3</span>) <span class="id" title="variable">H1</span>) <span class="id" title="variable">H</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">True</span> /\ <span class="id" title="inductive">False</span> -&gt; <span class="id" title="inductive">False</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


<div class="paragraph"> </div>

伝統的な<span class="inlinecode"><span class="id" title="tactic">tauto</span></span>タクティクは、
証明項のサイズの2次(quadratic)的な「爆発(blow-up)」を導入するのに対し、<span class="inlinecode"><span class="id" title="definition">my_tauto</span></span>によって生成される証明は常に線形の大きさを持ちます。 
</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab100"></a><h2 class="section">変数を持つ項の手動の具象化</h2>

</div>
<div class="code">

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

上記の<span class="inlinecode"><span class="id" title="tactic">quote</span></span> タクティクの動作は手品のように見えます。
どういうわけか、それは任意の型の副項(subterms)どうしが等しいかどうかの比較(equality comparison)
を実行するので、これらの副項は同じ具象化された(reified)変数でされるでしょう。
<span class="inlinecode"><span class="id" title="tactic">quote</span></span>はOCamlで実装されていますが、具象化のプロセス(reification process)
をLtacで完全にコードすることができます。
仕事をより簡単にするために、変数を<span class="inlinecode"><span class="id" title="inductive">nat</span></span>として表現し、
参照される変数の値からなる単純なリストにインデックスを付けます。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

プロセスの最初のステップは、項をクロールし、
エンコードする位置に表示されるすべての値の重複のないリストを変数として構築することです。
便利な補助関数(helper function)は、重複を防止ながら、要素をリストに追加ます。
Ltacのパターンマッチングを使用してGallina項についての等値のテスト
(equality test)を実装する方法に注意してください。
これは単純な文法的な等値(syntactic equality)であり、
より豊かな定義による等値(definitional equality)ではありません。
また、異なるリストの要素が異なるGallinaに型を持つことを可能にするために、
ネストされたタプルとしてリストを表現します。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">inList</span> <span class="id" title="var">x</span> <span class="id" title="var">xs</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">xs</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">tt</span> =&gt; <span class="id" title="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id" title="var">x</span>, <span class="id" title="var">_</span>) =&gt; <span class="id" title="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id" title="var">_</span>, ?<span class="id" title="var">xs'</span>) =&gt; <span class="id" title="var">inList</span> <span class="id" title="var">x</span> <span class="id" title="var">xs'</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">addToList</span> <span class="id" title="var">x</span> <span class="id" title="var">xs</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">b</span> := <span class="id" title="var">inList</span> <span class="id" title="var">x</span> <span class="id" title="var">xs</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">b</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">true</span> =&gt; <span class="id" title="var">xs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">false</span> =&gt; <span class="id" title="keyword">constr</span>:((<span class="id" title="var">x</span>, <span class="id" title="var">xs</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

ここで、項を表すために使用する変数値のリストを計算する再帰関数を書くことができます。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">allVars</span> <span class="id" title="var">xs</span> <span class="id" title="var">e</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">e</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">True</span> =&gt; <span class="id" title="var">xs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">False</span> =&gt; <span class="id" title="var">xs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" title="var">e1</span> /\ ?<span class="id" title="var">e2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">xs</span> := <span class="id" title="var">allVars</span> <span class="id" title="var">xs</span> <span class="id" title="var">e1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">allVars</span> <span class="id" title="var">xs</span> <span class="id" title="var">e2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" title="var">e1</span> \/ ?<span class="id" title="var">e2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">xs</span> := <span class="id" title="var">allVars</span> <span class="id" title="var">xs</span> <span class="id" title="var">e1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">allVars</span> <span class="id" title="var">xs</span> <span class="id" title="var">e2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" title="var">e1</span> -&gt; ?<span class="id" title="var">e2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">xs</span> := <span class="id" title="var">allVars</span> <span class="id" title="var">xs</span> <span class="id" title="var">e1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">allVars</span> <span class="id" title="var">xs</span> <span class="id" title="var">e2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="var">addToList</span> <span class="id" title="var">e</span> <span class="id" title="var">xs</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

値をリストの内の位置にマップする方法も必要です。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">lookup</span> <span class="id" title="var">x</span> <span class="id" title="var">xs</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">xs</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id" title="var">x</span>, <span class="id" title="var">_</span>) =&gt; <span class="id" title="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| (<span class="id" title="var">_</span>, ?<span class="id" title="var">xs'</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">n</span> := <span class="id" title="var">lookup</span> <span class="id" title="var">x</span> <span class="id" title="var">xs'</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="var">S</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

次の構成要素(building block)は、許可されたすべての変数値のリストを指定して、
項を具象化する手順です。
変数のリストに含まれていない副項(subterm)を含む項の具象化を試みると、
タクティクの失敗が引き起こされる可能性があるため、
この手続きは部分的(partial)になります(free to make this procedure partial)。
出力項の型は、<span class="inlinecode"><span class="id" title="inductive">index</span></span>が<span class="inlinecode"><span class="id" title="inductive">nat</span></span>に置き換えられた<span class="inlinecode"><span class="id" title="inductive">formula</span></span>のコピーで、
アトミックな式のコンストラクタの型です。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">formula'</span> : <span class="id" title="keyword">Set</span> :=<br/>
| <span class="id" title="var">Atomic'</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">formula'</span><br/>
| <span class="id" title="var">Truth'</span> : <span class="id" title="var">formula'</span><br/>
| <span class="id" title="var">Falsehood'</span> : <span class="id" title="var">formula'</span><br/>
| <span class="id" title="var">And'</span> : <span class="id" title="var">formula'</span> -&gt; <span class="id" title="var">formula'</span> -&gt; <span class="id" title="var">formula'</span><br/>
| <span class="id" title="var">Or'</span> : <span class="id" title="var">formula'</span> -&gt; <span class="id" title="var">formula'</span> -&gt; <span class="id" title="var">formula'</span><br/>
| <span class="id" title="var">Imp'</span> : <span class="id" title="var">formula'</span> -&gt; <span class="id" title="var">formula'</span> -&gt; <span class="id" title="var">formula'</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

私たち自身のLtac手続きを書くときは、ラッパーを導入する必要はなく、
通常の<span class="inlinecode">-&gt;</span>演算子で直接作業することができます。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">reifyTerm</span> <span class="id" title="var">xs</span> <span class="id" title="var">e</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">e</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">True</span> =&gt; <span class="id" title="var">Truth'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">False</span> =&gt; <span class="id" title="var">Falsehood'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" title="var">e1</span> /\ ?<span class="id" title="var">e2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">p1</span> := <span class="id" title="var">reifyTerm</span> <span class="id" title="var">xs</span> <span class="id" title="var">e1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">p2</span> := <span class="id" title="var">reifyTerm</span> <span class="id" title="var">xs</span> <span class="id" title="var">e2</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="var">And'</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" title="var">e1</span> \/ ?<span class="id" title="var">e2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">p1</span> := <span class="id" title="var">reifyTerm</span> <span class="id" title="var">xs</span> <span class="id" title="var">e1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">p2</span> := <span class="id" title="var">reifyTerm</span> <span class="id" title="var">xs</span> <span class="id" title="var">e2</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="var">Or'</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" title="var">e1</span> -&gt; ?<span class="id" title="var">e2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">p1</span> := <span class="id" title="var">reifyTerm</span> <span class="id" title="var">xs</span> <span class="id" title="var">e1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">p2</span> := <span class="id" title="var">reifyTerm</span> <span class="id" title="var">xs</span> <span class="id" title="var">e2</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="var">Imp'</span> <span class="id" title="var">p1</span> <span class="id" title="var">p2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">n</span> := <span class="id" title="var">lookup</span> <span class="id" title="var">e</span> <span class="id" title="var">xs</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="var">Atomic'</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

最後に、すべての作品をまとめています。

</div>
<div class="code">
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">reify</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ |- ?<span class="id" title="var">G</span> ] =&gt; <span class="id" title="keyword">let</span> <span class="id" title="var">xs</span> := <span class="id" title="var">allVars</span> <span class="id" title="var">tt</span> <span class="id" title="var">G</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">p</span> := <span class="id" title="var">reifyTerm</span> <span class="id" title="var">xs</span> <span class="id" title="var">G</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> <span class="id" title="var">p</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

クイックテストは、私たちが正しく具象化(reification)を行っていることを検証します。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">mt3'</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>,<br/>
&nbsp;&nbsp;(<span class="id" title="var">x</span> &lt; <span class="id" title="var">y</span> /\ <span class="id" title="var">y</span> &gt; <span class="id" title="var">z</span>) \/ (<span class="id" title="var">y</span> &gt; <span class="id" title="var">z</span> /\ <span class="id" title="var">x</span> &lt; <span class="id" title="var">S</span> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;-&gt; <span class="id" title="var">y</span> &gt; <span class="id" title="var">z</span> /\ (<span class="id" title="var">x</span> &lt; <span class="id" title="var">y</span> \/ <span class="id" title="var">x</span> &lt; <span class="id" title="var">S</span> <span class="id" title="var">y</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">do</span> 3 <span class="id" title="tactic">intro</span>; <span class="id" title="var">reify</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

私たちの簡単なタクティクは、変換された項を新しい変数として追加します：

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="variable">f</span> := <span class="id" title="constructor">Imp'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="constructor">Or'</span> (<span class="id" title="constructor">And'</span> (<span class="id" title="constructor">Atomic'</span> 2) (<span class="id" title="constructor">Atomic'</span> 1)) (<span class="id" title="constructor">And'</span> (<span class="id" title="constructor">Atomic'</span> 1) (<span class="id" title="constructor">Atomic'</span> 0)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="constructor">And'</span> (<span class="id" title="constructor">Atomic'</span> 1) (<span class="id" title="constructor">Or'</span> (<span class="id" title="constructor">Atomic'</span> 2) (<span class="id" title="constructor">Atomic'</span> 0))) : <span class="id" title="inductive">formula'</span>
<div class="paragraph"> </div>

</span>
</div>
<div class="code">
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

新しい構文型と式の実際の意味を結びつけなければならないので、
リフレクティブなタクティクを完成させるためにはもっと多くの作業が必要ですが、
詳細は以前の<span class="inlinecode"><span class="id" title="tactic">quote</span></span>による実装と同じです。

</div>
<div class="code">

<br/>

<br/>

<br/>
</div>

<div class="doc">
<a name="lab101"></a><h1 class="section">束縛のもとで再帰する具象化タクティクを作る</h1>

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

これまでのすべての例では、量化子や、<span class="inlinecode"><span class="id" title="keyword">fun</span></span>による関数抽象などの項の構文を具現化する形式
から離れていました。
そのような場合は、
異なる副項が自由変数の異なる集合を参照することを許されるという事実によって複雑になります。
このようなハードルを解消するためにはいくつかの巧妙さが必要ですが、
すこしの単純なパターンで十分です。
関数抽象の本体が便利にCoqの関数で表されている単純な依存型の言語の例を考えてみましょう。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">type</span> : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">Nat</span> : <span class="id" title="var">type</span><br/>
| <span class="id" title="var">NatFunc</span> : <span class="id" title="var">type</span> -&gt; <span class="id" title="var">type</span>.<br/>

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">term</span> : <span class="id" title="var">type</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">Const</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">term</span> <span class="id" title="var">Nat</span><br/>
| <span class="id" title="var">Plus</span> : <span class="id" title="var">term</span> <span class="id" title="var">Nat</span> -&gt; <span class="id" title="var">term</span> <span class="id" title="var">Nat</span> -&gt; <span class="id" title="var">term</span> <span class="id" title="var">Nat</span><br/>
| <span class="id" title="var">Abs</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">t</span>, (<span class="id" title="var">nat</span> -&gt; <span class="id" title="var">term</span> <span class="id" title="var">t</span>) -&gt; <span class="id" title="var">term</span> (<span class="id" title="var">NatFunc</span> <span class="id" title="var">t</span>).<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">typeDenote</span> (<span class="id" title="var">t</span> : <span class="id" title="var">type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">t</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Nat</span> =&gt; <span class="id" title="var">nat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">NatFunc</span> <span class="id" title="var">t</span> =&gt; <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">typeDenote</span> <span class="id" title="var">t</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">termDenote</span> <span class="id" title="var">t</span> (<span class="id" title="var">e</span> : <span class="id" title="var">term</span> <span class="id" title="var">t</span>) : <span class="id" title="var">typeDenote</span> <span class="id" title="var">t</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">e</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Const</span> <span class="id" title="var">n</span> =&gt; <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Plus</span> <span class="id" title="var">e1</span> <span class="id" title="var">e2</span> =&gt; <span class="id" title="var">termDenote</span> <span class="id" title="var">e1</span> + <span class="id" title="var">termDenote</span> <span class="id" title="var">e2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">Abs</span> <span class="id" title="var">_</span> <span class="id" title="var">e1</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">termDenote</span> (<span class="id" title="var">e1</span> <span class="id" title="var">x</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

ここでは、具象化のタクティクで素朴(naive)な最初の試みがあります。

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">refl'</span> <span class="id" title="var">e</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">e</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" title="var">E1</span> + ?<span class="id" title="var">E2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">r1</span> := <span class="id" title="var">refl'</span> <span class="id" title="var">E1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">r2</span> := <span class="id" title="var">refl'</span> <span class="id" title="var">E2</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="var">Plus</span> <span class="id" title="var">r1</span> <span class="id" title="var">r2</span>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">nat</span> =&gt; ?<span class="id" title="var">E1</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">r1</span> := <span class="id" title="var">refl'</span> <span class="id" title="var">E1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="var">Abs</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">r1</span> <span class="id" title="var">x</span>))<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="keyword">constr</span>:(<span class="id" title="var">Const</span> <span class="id" title="var">e</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>


<div class="paragraph"> </div>

関数を一般的に扱うために、パターンの変数の形式 <span class="inlinecode">@?<span class="id" title="var">X</span></span>を使用して、
明示的に宣言された新しく導入された変数について<span class="inlinecode"><span class="id" title="var">X</span></span>が言及するようにします。
<span class="inlinecode">@?<span class="id" title="var">X</span></span>の使用のあとには、言及する可能性のあるローカル変数のリストを続ける必要があります。 

<div class="paragraph"> </div>


<div class="paragraph"> </div>

変数<span class="inlinecode"><span class="id" title="var">X</span></span>は、それらの変数の値に渡ってGallina関数を表します。 例えば：
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Reset</span> <span class="id" title="var">refl'</span>.<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">refl'</span> <span class="id" title="var">e</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">e</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| ?<span class="id" title="var">E1</span> + ?<span class="id" title="var">E2</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">r1</span> := <span class="id" title="var">refl'</span> <span class="id" title="var">E1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">r2</span> := <span class="id" title="var">refl'</span> <span class="id" title="var">E2</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="var">Plus</span> <span class="id" title="var">r1</span> <span class="id" title="var">r2</span>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">nat</span> =&gt; @?<span class="id" title="var">E1</span> <span class="id" title="var">x</span> =&gt;              <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">r1</span> := <span class="id" title="var">refl'</span> <span class="id" title="var">E1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="var">Abs</span> <span class="id" title="var">r1</span>)<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="keyword">constr</span>:(<span class="id" title="var">Const</span> <span class="id" title="var">e</span>)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

抽象化の場合<span class="inlinecode"><span class="id" title="var">E1</span></span>を、<span class="inlinecode"><span class="id" title="variable">x</span></span>の値から抽象化した本体の値への関数に、束縛します。
残念ながら、再帰呼び出しは成功すると決まったわけではありません。

<div class="paragraph"> </div>

同じ抽象パターンに一致し、別の再帰呼び出しを実行するなど、無限再帰を使用します。
最後の具象化によって作業手順が得られます。
重要なアイデアは、<span class="inlinecode"><span class="id" title="var">refl'</span></span>へのすべての入力を
＿再帰中に導入された変数の値に対する関数＿ として考えることです。

<div class="paragraph"> </div>

 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Reset</span> <span class="id" title="var">refl'</span>.<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">refl'</span> <span class="id" title="var">e</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="tactic">eval</span> <span class="id" title="tactic">simpl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">e</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : ?<span class="id" title="var">T</span> =&gt; @?<span class="id" title="var">E1</span> <span class="id" title="var">x</span> + @?<span class="id" title="var">E2</span> <span class="id" title="var">x</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">r1</span> := <span class="id" title="var">refl'</span> <span class="id" title="var">E1</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">r2</span> := <span class="id" title="var">refl'</span> <span class="id" title="var">E2</span> <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">Plus</span> (<span class="id" title="var">r1</span> <span class="id" title="var">x</span>) (<span class="id" title="var">r2</span> <span class="id" title="var">x</span>)) <br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="keyword">fun</span> (<span class="id" title="var">x</span> : ?<span class="id" title="var">T</span>) (<span class="id" title="var">y</span> : <span class="id" title="var">nat</span>) =&gt; @?<span class="id" title="var">E1</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">r1</span> := <span class="id" title="var">refl'</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">p</span> : <span class="id" title="var">T</span> * <span class="id" title="var">nat</span> =&gt; <span class="id" title="var">E1</span> (<span class="id" title="var">fst</span> <span class="id" title="var">p</span>) (<span class="id" title="var">snd</span> <span class="id" title="var">p</span>)) <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">constr</span>:(<span class="id" title="keyword">fun</span> <span class="id" title="var">u</span> =&gt; <span class="id" title="var">Abs</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">v</span> =&gt; <span class="id" title="var">r1</span> (<span class="id" title="var">u</span>, <span class="id" title="var">v</span>))) <br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">_</span> =&gt; <span class="id" title="keyword">constr</span>:(<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">Const</span> (<span class="id" title="var">e</span> <span class="id" title="var">x</span>)) <br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode">@?<span class="id" title="var">X</span></span>のパターンでは、関数の形で加算の場合でもどのように動作するのか注意してください。
抽象化の場合、自由変数を表すために使用される型を拡張することによって新しい変数が導入されます。
すべての自由変数を表すために<span class="inlinecode"><span class="id" title="variable">T</span></span>型を使用しました。
抽象化の本体内の自由変数値を表す型の型を<span class="inlinecode"><span class="id" title="variable">T</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="inductive">nat</span></span>に拡張します。
ペアとその射影(projection)による
少しのブックキーピング(a bit of bookkeeping)は、
再帰呼び出しで渡す抽象本体の適切なバージョンを生成します。
このような項の再パッケージングがすべてパターンマッチングを妨げないようにするために、
<span class="inlinecode"><span class="id" title="var">refl'</span></span>の本体の最初の行に関数引数を追加します。

<div class="paragraph"> </div>


<div class="paragraph"> </div>

今やもうひとつのタクティクが、具象化を適用する方法の例を提供します。
具象化できる項どうしの等式であるゴールを考えてみましょう。
このようなゴールを<span class="inlinecode"><span class="id" title="definition">termDenote</span></span>への適切な呼び出しの間で等式に変更したいと考えています。
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">refl</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [ |- ?<span class="id" title="var">E1</span> = ?<span class="id" title="var">E2</span> ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">E1'</span> := <span class="id" title="var">refl'</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> : <span class="id" title="var">unit</span> =&gt; <span class="id" title="var">E1</span>) <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">E2'</span> := <span class="id" title="var">refl'</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> : <span class="id" title="var">unit</span> =&gt; <span class="id" title="var">E2</span>) <span class="id" title="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">termDenote</span> (<span class="id" title="var">E1'</span> <span class="id" title="var">tt</span>) = <span class="id" title="var">termDenote</span> (<span class="id" title="var">E2'</span> <span class="id" title="var">tt</span>));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">cbv</span> <span class="id" title="keyword">beta</span> <span class="id" title="keyword">iota</span> <span class="id" title="keyword">delta</span> [<span class="id" title="var">fst</span> <span class="id" title="var">snd</span>]<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Goal</span> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">nat</span>) =&gt; <span class="id" title="var">x</span> + <span class="id" title="var">y</span> + 13) = (<span class="id" title="keyword">fun</span> (<span class="id" title="var">_</span> <span class="id" title="var">z</span> : <span class="id" title="var">nat</span>) =&gt; <span class="id" title="var">z</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">refl</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="definition">termDenote</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="constructor">Abs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="variable">y</span> : <span class="id" title="inductive">nat</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="constructor">Abs</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y0</span> : <span class="id" title="inductive">nat</span> =&gt; <span class="id" title="constructor">Plus</span> (<span class="id" title="constructor">Plus</span> (<span class="id" title="constructor">Const</span> <span class="id" title="variable">y</span>) (<span class="id" title="constructor">Const</span> <span class="id" title="var">y0</span>)) (<span class="id" title="constructor">Const</span> 13)))) =<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="definition">termDenote</span> (<span class="id" title="constructor">Abs</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> : <span class="id" title="inductive">nat</span> =&gt; <span class="id" title="constructor">Abs</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y0</span> : <span class="id" title="inductive">nat</span> =&gt; <span class="id" title="constructor">Const</span> <span class="id" title="var">y0</span>)))
<div class="paragraph"> </div>

</span>
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Abort</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

ここでのエンコーディングは、Coqの関数を使用して、妥当な条件で束縛を表現しているため、
特定の関数機能を実現するのが難しくなります。

<div class="paragraph"> </div>

また、変数を数値で表現する方法もあります。
これは、項の引数が<span class="inlinecode"><span class="id" title="definition">fst</span></span>と<span class="inlinecode"><span class="id" title="definition">snd</span></span>の合成だけであることを検出することによって、
変数参照を識別する若干スマートな具象化関数を書くことによって行うことができます。
構成の順序から、変数の数値を読み取ることができます。
読者のために詳細を練習問題（しかし、自明なものではありません！）として残しています。
 
</div>
<div class="code">

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>